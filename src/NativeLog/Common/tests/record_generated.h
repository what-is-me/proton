// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RECORD_NLOG_FBS_H_
#define FLATBUFFERS_GENERATED_RECORD_NLOG_FBS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace nlog {
namespace fbs {

struct RecordHeader;
struct RecordHeaderBuilder;

struct Record;
struct RecordBuilder;

struct RecordBatch;
struct RecordBatchBuilder;

struct RecordHeader FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RecordHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::Vector<int8_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct RecordHeaderBuilder {
  typedef RecordHeader Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(RecordHeader::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> value) {
    fbb_.AddOffset(RecordHeader::VT_VALUE, value);
  }
  explicit RecordHeaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RecordHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RecordHeader>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RecordHeader> CreateRecordHeader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> value = 0) {
  RecordHeaderBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RecordHeader> CreateRecordHeaderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const std::vector<int8_t> *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateVector<int8_t>(*value) : 0;
  return nlog::fbs::CreateRecordHeader(
      _fbb,
      key__,
      value__);
}

struct Record FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RecordBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_OFFSET_DELTA = 6,
    VT_KEY = 8,
    VT_VALUE = 10,
    VT_HEADERS = 12
  };
  /// event timestamp
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  /// base_offset + offset_delta is the real offset of this record
  uint16_t offset_delta() const {
    return GetField<uint16_t>(VT_OFFSET_DELTA, 0);
  }
  const ::flatbuffers::Vector<int8_t> *key() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_KEY);
  }
  const ::flatbuffers::Vector<int8_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<nlog::fbs::RecordHeader>> *headers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<nlog::fbs::RecordHeader>> *>(VT_HEADERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<uint16_t>(verifier, VT_OFFSET_DELTA, 2) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyVector(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           VerifyOffset(verifier, VT_HEADERS) &&
           verifier.VerifyVector(headers()) &&
           verifier.VerifyVectorOfTables(headers()) &&
           verifier.EndTable();
  }
};

struct RecordBuilder {
  typedef Record Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(Record::VT_TIMESTAMP, timestamp, 0);
  }
  void add_offset_delta(uint16_t offset_delta) {
    fbb_.AddElement<uint16_t>(Record::VT_OFFSET_DELTA, offset_delta, 0);
  }
  void add_key(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> key) {
    fbb_.AddOffset(Record::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> value) {
    fbb_.AddOffset(Record::VT_VALUE, value);
  }
  void add_headers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<nlog::fbs::RecordHeader>>> headers) {
    fbb_.AddOffset(Record::VT_HEADERS, headers);
  }
  explicit RecordBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Record> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Record>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Record> CreateRecord(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    uint16_t offset_delta = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> key = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> value = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<nlog::fbs::RecordHeader>>> headers = 0) {
  RecordBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_headers(headers);
  builder_.add_value(value);
  builder_.add_key(key);
  builder_.add_offset_delta(offset_delta);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Record> CreateRecordDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    uint16_t offset_delta = 0,
    const std::vector<int8_t> *key = nullptr,
    const std::vector<int8_t> *value = nullptr,
    const std::vector<::flatbuffers::Offset<nlog::fbs::RecordHeader>> *headers = nullptr) {
  auto key__ = key ? _fbb.CreateVector<int8_t>(*key) : 0;
  auto value__ = value ? _fbb.CreateVector<int8_t>(*value) : 0;
  auto headers__ = headers ? _fbb.CreateVector<::flatbuffers::Offset<nlog::fbs::RecordHeader>>(*headers) : 0;
  return nlog::fbs::CreateRecord(
      _fbb,
      timestamp,
      offset_delta,
      key__,
      value__,
      headers__);
}

/// NativeLog clients always ingest data in RecordBatch and prefixed with a 64bit integer
/// called RecordBatchPrefix which contains some special flags and the length of the RecordBatch
/// NativeLog server validates the prefix and also read the payload according to the length
/// [64bits-prefix][RecordBatch]
struct RecordBatch FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RecordBatchBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CRC = 4,
    VT_FLAGS = 6,
    VT_BASE_OFFSET = 8,
    VT_SHARD_LEADER_EPOCH = 10,
    VT_LAST_OFFSET_DELTA = 12,
    VT_APPEND_TIMESTAMP = 14,
    VT_FIRST_TIMESTAMP = 16,
    VT_MAX_TIMESTAMP = 18,
    VT_PRODUCER_ID = 20,
    VT_PRODUCER_EPOCH = 22,
    VT_BASE_SEQUENCE = 24,
    VT_RECORDS = 26
  };
  /// When server receives a RecordBatch, it first needs validate the CRC
  /// and then setup timestamps etc fields, and re-calculates the CRC before persisting
  /// it to storage
  uint32_t crc() const {
    return GetField<uint32_t>(VT_CRC, 0);
  }
  /// 64bit flags has the following layout
  /// [0-3bits][4-54bits][55-62bits][63bit    ]
  ///    |         |          |         |
  /// [version][reserved][magic=159][tombstone]
  /// The magic number is high 8 bits which is a sum of letter `t` (0x74) + letter `+` (0x2B)
  uint64_t flags() const {
    return GetField<uint64_t>(VT_FLAGS, 0);
  }
  int64_t base_offset() const {
    return GetField<int64_t>(VT_BASE_OFFSET, 0);
  }
  int32_t shard_leader_epoch() const {
    return GetField<int32_t>(VT_SHARD_LEADER_EPOCH, 0);
  }
  /// Also serves as LastSequenceDelta
  int32_t last_offset_delta() const {
    return GetField<int32_t>(VT_LAST_OFFSET_DELTA, 0);
  }
  int64_t append_timestamp() const {
    return GetField<int64_t>(VT_APPEND_TIMESTAMP, 0);
  }
  int64_t first_timestamp() const {
    return GetField<int64_t>(VT_FIRST_TIMESTAMP, 0);
  }
  int64_t max_timestamp() const {
    return GetField<int64_t>(VT_MAX_TIMESTAMP, 0);
  }
  int64_t producer_id() const {
    return GetField<int64_t>(VT_PRODUCER_ID, 0);
  }
  int16_t producer_epoch() const {
    return GetField<int16_t>(VT_PRODUCER_EPOCH, 0);
  }
  int32_t base_sequence() const {
    return GetField<int32_t>(VT_BASE_SEQUENCE, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<nlog::fbs::Record>> *records() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<nlog::fbs::Record>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CRC, 4) &&
           VerifyField<uint64_t>(verifier, VT_FLAGS, 8) &&
           VerifyField<int64_t>(verifier, VT_BASE_OFFSET, 8) &&
           VerifyField<int32_t>(verifier, VT_SHARD_LEADER_EPOCH, 4) &&
           VerifyField<int32_t>(verifier, VT_LAST_OFFSET_DELTA, 4) &&
           VerifyField<int64_t>(verifier, VT_APPEND_TIMESTAMP, 8) &&
           VerifyField<int64_t>(verifier, VT_FIRST_TIMESTAMP, 8) &&
           VerifyField<int64_t>(verifier, VT_MAX_TIMESTAMP, 8) &&
           VerifyField<int64_t>(verifier, VT_PRODUCER_ID, 8) &&
           VerifyField<int16_t>(verifier, VT_PRODUCER_EPOCH, 2) &&
           VerifyField<int32_t>(verifier, VT_BASE_SEQUENCE, 4) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(records()) &&
           verifier.VerifyVectorOfTables(records()) &&
           verifier.EndTable();
  }
};

struct RecordBatchBuilder {
  typedef RecordBatch Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_crc(uint32_t crc) {
    fbb_.AddElement<uint32_t>(RecordBatch::VT_CRC, crc, 0);
  }
  void add_flags(uint64_t flags) {
    fbb_.AddElement<uint64_t>(RecordBatch::VT_FLAGS, flags, 0);
  }
  void add_base_offset(int64_t base_offset) {
    fbb_.AddElement<int64_t>(RecordBatch::VT_BASE_OFFSET, base_offset, 0);
  }
  void add_shard_leader_epoch(int32_t shard_leader_epoch) {
    fbb_.AddElement<int32_t>(RecordBatch::VT_SHARD_LEADER_EPOCH, shard_leader_epoch, 0);
  }
  void add_last_offset_delta(int32_t last_offset_delta) {
    fbb_.AddElement<int32_t>(RecordBatch::VT_LAST_OFFSET_DELTA, last_offset_delta, 0);
  }
  void add_append_timestamp(int64_t append_timestamp) {
    fbb_.AddElement<int64_t>(RecordBatch::VT_APPEND_TIMESTAMP, append_timestamp, 0);
  }
  void add_first_timestamp(int64_t first_timestamp) {
    fbb_.AddElement<int64_t>(RecordBatch::VT_FIRST_TIMESTAMP, first_timestamp, 0);
  }
  void add_max_timestamp(int64_t max_timestamp) {
    fbb_.AddElement<int64_t>(RecordBatch::VT_MAX_TIMESTAMP, max_timestamp, 0);
  }
  void add_producer_id(int64_t producer_id) {
    fbb_.AddElement<int64_t>(RecordBatch::VT_PRODUCER_ID, producer_id, 0);
  }
  void add_producer_epoch(int16_t producer_epoch) {
    fbb_.AddElement<int16_t>(RecordBatch::VT_PRODUCER_EPOCH, producer_epoch, 0);
  }
  void add_base_sequence(int32_t base_sequence) {
    fbb_.AddElement<int32_t>(RecordBatch::VT_BASE_SEQUENCE, base_sequence, 0);
  }
  void add_records(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<nlog::fbs::Record>>> records) {
    fbb_.AddOffset(RecordBatch::VT_RECORDS, records);
  }
  explicit RecordBatchBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RecordBatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RecordBatch>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RecordBatch> CreateRecordBatch(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t crc = 0,
    uint64_t flags = 0,
    int64_t base_offset = 0,
    int32_t shard_leader_epoch = 0,
    int32_t last_offset_delta = 0,
    int64_t append_timestamp = 0,
    int64_t first_timestamp = 0,
    int64_t max_timestamp = 0,
    int64_t producer_id = 0,
    int16_t producer_epoch = 0,
    int32_t base_sequence = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<nlog::fbs::Record>>> records = 0) {
  RecordBatchBuilder builder_(_fbb);
  builder_.add_producer_id(producer_id);
  builder_.add_max_timestamp(max_timestamp);
  builder_.add_first_timestamp(first_timestamp);
  builder_.add_append_timestamp(append_timestamp);
  builder_.add_base_offset(base_offset);
  builder_.add_flags(flags);
  builder_.add_records(records);
  builder_.add_base_sequence(base_sequence);
  builder_.add_last_offset_delta(last_offset_delta);
  builder_.add_shard_leader_epoch(shard_leader_epoch);
  builder_.add_crc(crc);
  builder_.add_producer_epoch(producer_epoch);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RecordBatch> CreateRecordBatchDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t crc = 0,
    uint64_t flags = 0,
    int64_t base_offset = 0,
    int32_t shard_leader_epoch = 0,
    int32_t last_offset_delta = 0,
    int64_t append_timestamp = 0,
    int64_t first_timestamp = 0,
    int64_t max_timestamp = 0,
    int64_t producer_id = 0,
    int16_t producer_epoch = 0,
    int32_t base_sequence = 0,
    const std::vector<::flatbuffers::Offset<nlog::fbs::Record>> *records = nullptr) {
  auto records__ = records ? _fbb.CreateVector<::flatbuffers::Offset<nlog::fbs::Record>>(*records) : 0;
  return nlog::fbs::CreateRecordBatch(
      _fbb,
      crc,
      flags,
      base_offset,
      shard_leader_epoch,
      last_offset_delta,
      append_timestamp,
      first_timestamp,
      max_timestamp,
      producer_id,
      producer_epoch,
      base_sequence,
      records__);
}

inline const nlog::fbs::RecordBatch *GetRecordBatch(const void *buf) {
  return ::flatbuffers::GetRoot<nlog::fbs::RecordBatch>(buf);
}

inline const nlog::fbs::RecordBatch *GetSizePrefixedRecordBatch(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<nlog::fbs::RecordBatch>(buf);
}

inline bool VerifyRecordBatchBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<nlog::fbs::RecordBatch>(nullptr);
}

inline bool VerifySizePrefixedRecordBatchBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<nlog::fbs::RecordBatch>(nullptr);
}

inline void FinishRecordBatchBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<nlog::fbs::RecordBatch> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRecordBatchBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<nlog::fbs::RecordBatch> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fbs
}  // namespace nlog

#endif  // FLATBUFFERS_GENERATED_RECORD_NLOG_FBS_H_
