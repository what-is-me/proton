#include <Storages/getStreamShardsOfRemoteStream.h>

#include <Columns/ColumnString.h>
#include <DataTypes/DataTypeString.h>
#include <Interpreters/ClusterProxy/executeQuery.h>
#include <Parsers/ASTCreateQuery.h>
#include <Parsers/ASTFunction.h>
#include <Parsers/ASTSetQuery.h>
#include <Parsers/ParserCreateQuery.h>
#include <Parsers/parseQuery.h>
#include <QueryPipeline/RemoteQueryExecutor.h>
#include <Storages/IStorage.h>

namespace DB
{

UInt32 getStreamShardsOfRemoteStream(const Cluster & cluster, const StorageID & table_id, ContextPtr context)
{
    auto shard_info = cluster.getShardsInfo().front();
    chassert(!shard_info.isLocal());

    /// Request for a table create SQL
    auto query = "SHOW CREATE " + table_id.getFullTableName();

    auto new_context = ClusterProxy::updateSettingsForCluster(cluster, context, context->getSettingsRef());

    Block sample_block{
        {ColumnString::create(), std::make_shared<DataTypeString>(), "statement"},
    };

    /// Execute remote query without restrictions (because it's not real user query, but part of implementation)
    RemoteQueryExecutor executor(shard_info.pool, query, sample_block, new_context);
    SCOPE_EXIT(executor.finish());

    executor.setPoolMode(PoolMode::GET_ONE);
    executor.setMainTable(table_id);

    auto current = executor.read();

    ColumnPtr statement = current.getByName("statement").column;
    chassert(statement->size() == 1);

    auto create_query_str = (*statement)[0].get<const String &>();

    ParserCreateQuery create_parser;
    auto create_ast = parseQuery(create_parser, create_query_str, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
    const auto & create_query_ast = create_ast->as<const ASTCreateQuery &>();

    if (create_query_ast.is_materialized_view)
    {
        /// If the MV has a "INTO" stream, then read the shards from that stream.
        if (create_query_ast.to_table_id.empty())
            return 1;
        else
            return getStreamShardsOfRemoteStream(cluster, create_query_ast.to_table_id, context);
    }

    if (create_query_ast.storage == nullptr)
        return 1;

    /// For random streams, they have null engine.
    /// Even though it's possible to set `shards` on random streams, they are not real shards, it's just the number
    /// of threads the stream uses to generate data. All data generated by random streams have `_tp_shard` = `0`.
    /// Also, checkpointing is meaningless with random streams.
    if (create_query_ast.storage->engine == nullptr)
        return 1;

    auto engine_name = create_query_ast.storage->engine->name;
    if (engine_name == "Stream" || engine_name == "MutableStream")
    {
        auto shards = create_query_ast.storage->engine->arguments->children[0]->as<ASTLiteral &>().value.safeGet<UInt64>();
        return static_cast<UInt32>(shards);
    }

    return 1;
}

}
