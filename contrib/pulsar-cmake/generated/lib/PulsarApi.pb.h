// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PulsarApi.proto
// Protobuf C++ Version: 4.25.5

#ifndef GOOGLE_PROTOBUF_INCLUDED_PulsarApi_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_PulsarApi_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025005 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_util.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_PulsarApi_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_PulsarApi_2eproto {
  static const ::uint32_t offsets[];
};
namespace pulsar {
namespace proto {
class AuthData;
struct AuthDataDefaultTypeInternal;
extern AuthDataDefaultTypeInternal _AuthData_default_instance_;
class BaseCommand;
struct BaseCommandDefaultTypeInternal;
extern BaseCommandDefaultTypeInternal _BaseCommand_default_instance_;
class BrokerEntryMetadata;
struct BrokerEntryMetadataDefaultTypeInternal;
extern BrokerEntryMetadataDefaultTypeInternal _BrokerEntryMetadata_default_instance_;
class CommandAck;
struct CommandAckDefaultTypeInternal;
extern CommandAckDefaultTypeInternal _CommandAck_default_instance_;
class CommandAckResponse;
struct CommandAckResponseDefaultTypeInternal;
extern CommandAckResponseDefaultTypeInternal _CommandAckResponse_default_instance_;
class CommandActiveConsumerChange;
struct CommandActiveConsumerChangeDefaultTypeInternal;
extern CommandActiveConsumerChangeDefaultTypeInternal _CommandActiveConsumerChange_default_instance_;
class CommandAddPartitionToTxn;
struct CommandAddPartitionToTxnDefaultTypeInternal;
extern CommandAddPartitionToTxnDefaultTypeInternal _CommandAddPartitionToTxn_default_instance_;
class CommandAddPartitionToTxnResponse;
struct CommandAddPartitionToTxnResponseDefaultTypeInternal;
extern CommandAddPartitionToTxnResponseDefaultTypeInternal _CommandAddPartitionToTxnResponse_default_instance_;
class CommandAddSubscriptionToTxn;
struct CommandAddSubscriptionToTxnDefaultTypeInternal;
extern CommandAddSubscriptionToTxnDefaultTypeInternal _CommandAddSubscriptionToTxn_default_instance_;
class CommandAddSubscriptionToTxnResponse;
struct CommandAddSubscriptionToTxnResponseDefaultTypeInternal;
extern CommandAddSubscriptionToTxnResponseDefaultTypeInternal _CommandAddSubscriptionToTxnResponse_default_instance_;
class CommandAuthChallenge;
struct CommandAuthChallengeDefaultTypeInternal;
extern CommandAuthChallengeDefaultTypeInternal _CommandAuthChallenge_default_instance_;
class CommandAuthResponse;
struct CommandAuthResponseDefaultTypeInternal;
extern CommandAuthResponseDefaultTypeInternal _CommandAuthResponse_default_instance_;
class CommandCloseConsumer;
struct CommandCloseConsumerDefaultTypeInternal;
extern CommandCloseConsumerDefaultTypeInternal _CommandCloseConsumer_default_instance_;
class CommandCloseProducer;
struct CommandCloseProducerDefaultTypeInternal;
extern CommandCloseProducerDefaultTypeInternal _CommandCloseProducer_default_instance_;
class CommandConnect;
struct CommandConnectDefaultTypeInternal;
extern CommandConnectDefaultTypeInternal _CommandConnect_default_instance_;
class CommandConnected;
struct CommandConnectedDefaultTypeInternal;
extern CommandConnectedDefaultTypeInternal _CommandConnected_default_instance_;
class CommandConsumerStats;
struct CommandConsumerStatsDefaultTypeInternal;
extern CommandConsumerStatsDefaultTypeInternal _CommandConsumerStats_default_instance_;
class CommandConsumerStatsResponse;
struct CommandConsumerStatsResponseDefaultTypeInternal;
extern CommandConsumerStatsResponseDefaultTypeInternal _CommandConsumerStatsResponse_default_instance_;
class CommandEndTxn;
struct CommandEndTxnDefaultTypeInternal;
extern CommandEndTxnDefaultTypeInternal _CommandEndTxn_default_instance_;
class CommandEndTxnOnPartition;
struct CommandEndTxnOnPartitionDefaultTypeInternal;
extern CommandEndTxnOnPartitionDefaultTypeInternal _CommandEndTxnOnPartition_default_instance_;
class CommandEndTxnOnPartitionResponse;
struct CommandEndTxnOnPartitionResponseDefaultTypeInternal;
extern CommandEndTxnOnPartitionResponseDefaultTypeInternal _CommandEndTxnOnPartitionResponse_default_instance_;
class CommandEndTxnOnSubscription;
struct CommandEndTxnOnSubscriptionDefaultTypeInternal;
extern CommandEndTxnOnSubscriptionDefaultTypeInternal _CommandEndTxnOnSubscription_default_instance_;
class CommandEndTxnOnSubscriptionResponse;
struct CommandEndTxnOnSubscriptionResponseDefaultTypeInternal;
extern CommandEndTxnOnSubscriptionResponseDefaultTypeInternal _CommandEndTxnOnSubscriptionResponse_default_instance_;
class CommandEndTxnResponse;
struct CommandEndTxnResponseDefaultTypeInternal;
extern CommandEndTxnResponseDefaultTypeInternal _CommandEndTxnResponse_default_instance_;
class CommandError;
struct CommandErrorDefaultTypeInternal;
extern CommandErrorDefaultTypeInternal _CommandError_default_instance_;
class CommandFlow;
struct CommandFlowDefaultTypeInternal;
extern CommandFlowDefaultTypeInternal _CommandFlow_default_instance_;
class CommandGetLastMessageId;
struct CommandGetLastMessageIdDefaultTypeInternal;
extern CommandGetLastMessageIdDefaultTypeInternal _CommandGetLastMessageId_default_instance_;
class CommandGetLastMessageIdResponse;
struct CommandGetLastMessageIdResponseDefaultTypeInternal;
extern CommandGetLastMessageIdResponseDefaultTypeInternal _CommandGetLastMessageIdResponse_default_instance_;
class CommandGetOrCreateSchema;
struct CommandGetOrCreateSchemaDefaultTypeInternal;
extern CommandGetOrCreateSchemaDefaultTypeInternal _CommandGetOrCreateSchema_default_instance_;
class CommandGetOrCreateSchemaResponse;
struct CommandGetOrCreateSchemaResponseDefaultTypeInternal;
extern CommandGetOrCreateSchemaResponseDefaultTypeInternal _CommandGetOrCreateSchemaResponse_default_instance_;
class CommandGetSchema;
struct CommandGetSchemaDefaultTypeInternal;
extern CommandGetSchemaDefaultTypeInternal _CommandGetSchema_default_instance_;
class CommandGetSchemaResponse;
struct CommandGetSchemaResponseDefaultTypeInternal;
extern CommandGetSchemaResponseDefaultTypeInternal _CommandGetSchemaResponse_default_instance_;
class CommandGetTopicsOfNamespace;
struct CommandGetTopicsOfNamespaceDefaultTypeInternal;
extern CommandGetTopicsOfNamespaceDefaultTypeInternal _CommandGetTopicsOfNamespace_default_instance_;
class CommandGetTopicsOfNamespaceResponse;
struct CommandGetTopicsOfNamespaceResponseDefaultTypeInternal;
extern CommandGetTopicsOfNamespaceResponseDefaultTypeInternal _CommandGetTopicsOfNamespaceResponse_default_instance_;
class CommandLookupTopic;
struct CommandLookupTopicDefaultTypeInternal;
extern CommandLookupTopicDefaultTypeInternal _CommandLookupTopic_default_instance_;
class CommandLookupTopicResponse;
struct CommandLookupTopicResponseDefaultTypeInternal;
extern CommandLookupTopicResponseDefaultTypeInternal _CommandLookupTopicResponse_default_instance_;
class CommandMessage;
struct CommandMessageDefaultTypeInternal;
extern CommandMessageDefaultTypeInternal _CommandMessage_default_instance_;
class CommandNewTxn;
struct CommandNewTxnDefaultTypeInternal;
extern CommandNewTxnDefaultTypeInternal _CommandNewTxn_default_instance_;
class CommandNewTxnResponse;
struct CommandNewTxnResponseDefaultTypeInternal;
extern CommandNewTxnResponseDefaultTypeInternal _CommandNewTxnResponse_default_instance_;
class CommandPartitionedTopicMetadata;
struct CommandPartitionedTopicMetadataDefaultTypeInternal;
extern CommandPartitionedTopicMetadataDefaultTypeInternal _CommandPartitionedTopicMetadata_default_instance_;
class CommandPartitionedTopicMetadataResponse;
struct CommandPartitionedTopicMetadataResponseDefaultTypeInternal;
extern CommandPartitionedTopicMetadataResponseDefaultTypeInternal _CommandPartitionedTopicMetadataResponse_default_instance_;
class CommandPing;
struct CommandPingDefaultTypeInternal;
extern CommandPingDefaultTypeInternal _CommandPing_default_instance_;
class CommandPong;
struct CommandPongDefaultTypeInternal;
extern CommandPongDefaultTypeInternal _CommandPong_default_instance_;
class CommandProducer;
struct CommandProducerDefaultTypeInternal;
extern CommandProducerDefaultTypeInternal _CommandProducer_default_instance_;
class CommandProducerSuccess;
struct CommandProducerSuccessDefaultTypeInternal;
extern CommandProducerSuccessDefaultTypeInternal _CommandProducerSuccess_default_instance_;
class CommandReachedEndOfTopic;
struct CommandReachedEndOfTopicDefaultTypeInternal;
extern CommandReachedEndOfTopicDefaultTypeInternal _CommandReachedEndOfTopic_default_instance_;
class CommandRedeliverUnacknowledgedMessages;
struct CommandRedeliverUnacknowledgedMessagesDefaultTypeInternal;
extern CommandRedeliverUnacknowledgedMessagesDefaultTypeInternal _CommandRedeliverUnacknowledgedMessages_default_instance_;
class CommandSeek;
struct CommandSeekDefaultTypeInternal;
extern CommandSeekDefaultTypeInternal _CommandSeek_default_instance_;
class CommandSend;
struct CommandSendDefaultTypeInternal;
extern CommandSendDefaultTypeInternal _CommandSend_default_instance_;
class CommandSendError;
struct CommandSendErrorDefaultTypeInternal;
extern CommandSendErrorDefaultTypeInternal _CommandSendError_default_instance_;
class CommandSendReceipt;
struct CommandSendReceiptDefaultTypeInternal;
extern CommandSendReceiptDefaultTypeInternal _CommandSendReceipt_default_instance_;
class CommandSubscribe;
struct CommandSubscribeDefaultTypeInternal;
extern CommandSubscribeDefaultTypeInternal _CommandSubscribe_default_instance_;
class CommandSuccess;
struct CommandSuccessDefaultTypeInternal;
extern CommandSuccessDefaultTypeInternal _CommandSuccess_default_instance_;
class CommandTcClientConnectRequest;
struct CommandTcClientConnectRequestDefaultTypeInternal;
extern CommandTcClientConnectRequestDefaultTypeInternal _CommandTcClientConnectRequest_default_instance_;
class CommandTcClientConnectResponse;
struct CommandTcClientConnectResponseDefaultTypeInternal;
extern CommandTcClientConnectResponseDefaultTypeInternal _CommandTcClientConnectResponse_default_instance_;
class CommandTopicMigrated;
struct CommandTopicMigratedDefaultTypeInternal;
extern CommandTopicMigratedDefaultTypeInternal _CommandTopicMigrated_default_instance_;
class CommandUnsubscribe;
struct CommandUnsubscribeDefaultTypeInternal;
extern CommandUnsubscribeDefaultTypeInternal _CommandUnsubscribe_default_instance_;
class CommandWatchTopicList;
struct CommandWatchTopicListDefaultTypeInternal;
extern CommandWatchTopicListDefaultTypeInternal _CommandWatchTopicList_default_instance_;
class CommandWatchTopicListClose;
struct CommandWatchTopicListCloseDefaultTypeInternal;
extern CommandWatchTopicListCloseDefaultTypeInternal _CommandWatchTopicListClose_default_instance_;
class CommandWatchTopicListSuccess;
struct CommandWatchTopicListSuccessDefaultTypeInternal;
extern CommandWatchTopicListSuccessDefaultTypeInternal _CommandWatchTopicListSuccess_default_instance_;
class CommandWatchTopicUpdate;
struct CommandWatchTopicUpdateDefaultTypeInternal;
extern CommandWatchTopicUpdateDefaultTypeInternal _CommandWatchTopicUpdate_default_instance_;
class EncryptionKeys;
struct EncryptionKeysDefaultTypeInternal;
extern EncryptionKeysDefaultTypeInternal _EncryptionKeys_default_instance_;
class FeatureFlags;
struct FeatureFlagsDefaultTypeInternal;
extern FeatureFlagsDefaultTypeInternal _FeatureFlags_default_instance_;
class IntRange;
struct IntRangeDefaultTypeInternal;
extern IntRangeDefaultTypeInternal _IntRange_default_instance_;
class KeyLongValue;
struct KeyLongValueDefaultTypeInternal;
extern KeyLongValueDefaultTypeInternal _KeyLongValue_default_instance_;
class KeySharedMeta;
struct KeySharedMetaDefaultTypeInternal;
extern KeySharedMetaDefaultTypeInternal _KeySharedMeta_default_instance_;
class KeyValue;
struct KeyValueDefaultTypeInternal;
extern KeyValueDefaultTypeInternal _KeyValue_default_instance_;
class MessageIdData;
struct MessageIdDataDefaultTypeInternal;
extern MessageIdDataDefaultTypeInternal _MessageIdData_default_instance_;
class MessageMetadata;
struct MessageMetadataDefaultTypeInternal;
extern MessageMetadataDefaultTypeInternal _MessageMetadata_default_instance_;
class Schema;
struct SchemaDefaultTypeInternal;
extern SchemaDefaultTypeInternal _Schema_default_instance_;
class SingleMessageMetadata;
struct SingleMessageMetadataDefaultTypeInternal;
extern SingleMessageMetadataDefaultTypeInternal _SingleMessageMetadata_default_instance_;
class Subscription;
struct SubscriptionDefaultTypeInternal;
extern SubscriptionDefaultTypeInternal _Subscription_default_instance_;
}  // namespace proto
}  // namespace pulsar
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace pulsar {
namespace proto {
enum Schema_Type : int {
  Schema_Type_None = 0,
  Schema_Type_String = 1,
  Schema_Type_Json = 2,
  Schema_Type_Protobuf = 3,
  Schema_Type_Avro = 4,
  Schema_Type_Bool = 5,
  Schema_Type_Int8 = 6,
  Schema_Type_Int16 = 7,
  Schema_Type_Int32 = 8,
  Schema_Type_Int64 = 9,
  Schema_Type_Float = 10,
  Schema_Type_Double = 11,
  Schema_Type_Date = 12,
  Schema_Type_Time = 13,
  Schema_Type_Timestamp = 14,
  Schema_Type_KeyValue = 15,
  Schema_Type_Instant = 16,
  Schema_Type_LocalDate = 17,
  Schema_Type_LocalTime = 18,
  Schema_Type_LocalDateTime = 19,
  Schema_Type_ProtobufNative = 20,
};

bool Schema_Type_IsValid(int value);
extern const uint32_t Schema_Type_internal_data_[];
constexpr Schema_Type Schema_Type_Type_MIN = static_cast<Schema_Type>(0);
constexpr Schema_Type Schema_Type_Type_MAX = static_cast<Schema_Type>(20);
constexpr int Schema_Type_Type_ARRAYSIZE = 20 + 1;
const std::string& Schema_Type_Name(Schema_Type value);
template <typename T>
const std::string& Schema_Type_Name(T value) {
  static_assert(std::is_same<T, Schema_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Schema_Type_Name(static_cast<Schema_Type>(value));
}
const std::string& Schema_Type_Name(Schema_Type value);
bool Schema_Type_Parse(absl::string_view name, Schema_Type* value);
enum CommandSubscribe_SubType : int {
  CommandSubscribe_SubType_Exclusive = 0,
  CommandSubscribe_SubType_Shared = 1,
  CommandSubscribe_SubType_Failover = 2,
  CommandSubscribe_SubType_Key_Shared = 3,
};

bool CommandSubscribe_SubType_IsValid(int value);
extern const uint32_t CommandSubscribe_SubType_internal_data_[];
constexpr CommandSubscribe_SubType CommandSubscribe_SubType_SubType_MIN = static_cast<CommandSubscribe_SubType>(0);
constexpr CommandSubscribe_SubType CommandSubscribe_SubType_SubType_MAX = static_cast<CommandSubscribe_SubType>(3);
constexpr int CommandSubscribe_SubType_SubType_ARRAYSIZE = 3 + 1;
const std::string& CommandSubscribe_SubType_Name(CommandSubscribe_SubType value);
template <typename T>
const std::string& CommandSubscribe_SubType_Name(T value) {
  static_assert(std::is_same<T, CommandSubscribe_SubType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SubType_Name().");
  return CommandSubscribe_SubType_Name(static_cast<CommandSubscribe_SubType>(value));
}
const std::string& CommandSubscribe_SubType_Name(CommandSubscribe_SubType value);
bool CommandSubscribe_SubType_Parse(absl::string_view name, CommandSubscribe_SubType* value);
enum CommandSubscribe_InitialPosition : int {
  CommandSubscribe_InitialPosition_Latest = 0,
  CommandSubscribe_InitialPosition_Earliest = 1,
};

bool CommandSubscribe_InitialPosition_IsValid(int value);
extern const uint32_t CommandSubscribe_InitialPosition_internal_data_[];
constexpr CommandSubscribe_InitialPosition CommandSubscribe_InitialPosition_InitialPosition_MIN = static_cast<CommandSubscribe_InitialPosition>(0);
constexpr CommandSubscribe_InitialPosition CommandSubscribe_InitialPosition_InitialPosition_MAX = static_cast<CommandSubscribe_InitialPosition>(1);
constexpr int CommandSubscribe_InitialPosition_InitialPosition_ARRAYSIZE = 1 + 1;
const std::string& CommandSubscribe_InitialPosition_Name(CommandSubscribe_InitialPosition value);
template <typename T>
const std::string& CommandSubscribe_InitialPosition_Name(T value) {
  static_assert(std::is_same<T, CommandSubscribe_InitialPosition>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to InitialPosition_Name().");
  return CommandSubscribe_InitialPosition_Name(static_cast<CommandSubscribe_InitialPosition>(value));
}
const std::string& CommandSubscribe_InitialPosition_Name(CommandSubscribe_InitialPosition value);
bool CommandSubscribe_InitialPosition_Parse(absl::string_view name, CommandSubscribe_InitialPosition* value);
enum CommandPartitionedTopicMetadataResponse_LookupType : int {
  CommandPartitionedTopicMetadataResponse_LookupType_Success = 0,
  CommandPartitionedTopicMetadataResponse_LookupType_Failed = 1,
};

bool CommandPartitionedTopicMetadataResponse_LookupType_IsValid(int value);
extern const uint32_t CommandPartitionedTopicMetadataResponse_LookupType_internal_data_[];
constexpr CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse_LookupType_LookupType_MIN = static_cast<CommandPartitionedTopicMetadataResponse_LookupType>(0);
constexpr CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse_LookupType_LookupType_MAX = static_cast<CommandPartitionedTopicMetadataResponse_LookupType>(1);
constexpr int CommandPartitionedTopicMetadataResponse_LookupType_LookupType_ARRAYSIZE = 1 + 1;
const std::string& CommandPartitionedTopicMetadataResponse_LookupType_Name(CommandPartitionedTopicMetadataResponse_LookupType value);
template <typename T>
const std::string& CommandPartitionedTopicMetadataResponse_LookupType_Name(T value) {
  static_assert(std::is_same<T, CommandPartitionedTopicMetadataResponse_LookupType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LookupType_Name().");
  return CommandPartitionedTopicMetadataResponse_LookupType_Name(static_cast<CommandPartitionedTopicMetadataResponse_LookupType>(value));
}
const std::string& CommandPartitionedTopicMetadataResponse_LookupType_Name(CommandPartitionedTopicMetadataResponse_LookupType value);
bool CommandPartitionedTopicMetadataResponse_LookupType_Parse(absl::string_view name, CommandPartitionedTopicMetadataResponse_LookupType* value);
enum CommandLookupTopicResponse_LookupType : int {
  CommandLookupTopicResponse_LookupType_Redirect = 0,
  CommandLookupTopicResponse_LookupType_Connect = 1,
  CommandLookupTopicResponse_LookupType_Failed = 2,
};

bool CommandLookupTopicResponse_LookupType_IsValid(int value);
extern const uint32_t CommandLookupTopicResponse_LookupType_internal_data_[];
constexpr CommandLookupTopicResponse_LookupType CommandLookupTopicResponse_LookupType_LookupType_MIN = static_cast<CommandLookupTopicResponse_LookupType>(0);
constexpr CommandLookupTopicResponse_LookupType CommandLookupTopicResponse_LookupType_LookupType_MAX = static_cast<CommandLookupTopicResponse_LookupType>(2);
constexpr int CommandLookupTopicResponse_LookupType_LookupType_ARRAYSIZE = 2 + 1;
const std::string& CommandLookupTopicResponse_LookupType_Name(CommandLookupTopicResponse_LookupType value);
template <typename T>
const std::string& CommandLookupTopicResponse_LookupType_Name(T value) {
  static_assert(std::is_same<T, CommandLookupTopicResponse_LookupType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LookupType_Name().");
  return CommandLookupTopicResponse_LookupType_Name(static_cast<CommandLookupTopicResponse_LookupType>(value));
}
const std::string& CommandLookupTopicResponse_LookupType_Name(CommandLookupTopicResponse_LookupType value);
bool CommandLookupTopicResponse_LookupType_Parse(absl::string_view name, CommandLookupTopicResponse_LookupType* value);
enum CommandAck_AckType : int {
  CommandAck_AckType_Individual = 0,
  CommandAck_AckType_Cumulative = 1,
};

bool CommandAck_AckType_IsValid(int value);
extern const uint32_t CommandAck_AckType_internal_data_[];
constexpr CommandAck_AckType CommandAck_AckType_AckType_MIN = static_cast<CommandAck_AckType>(0);
constexpr CommandAck_AckType CommandAck_AckType_AckType_MAX = static_cast<CommandAck_AckType>(1);
constexpr int CommandAck_AckType_AckType_ARRAYSIZE = 1 + 1;
const std::string& CommandAck_AckType_Name(CommandAck_AckType value);
template <typename T>
const std::string& CommandAck_AckType_Name(T value) {
  static_assert(std::is_same<T, CommandAck_AckType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AckType_Name().");
  return CommandAck_AckType_Name(static_cast<CommandAck_AckType>(value));
}
const std::string& CommandAck_AckType_Name(CommandAck_AckType value);
bool CommandAck_AckType_Parse(absl::string_view name, CommandAck_AckType* value);
enum CommandAck_ValidationError : int {
  CommandAck_ValidationError_UncompressedSizeCorruption = 0,
  CommandAck_ValidationError_DecompressionError = 1,
  CommandAck_ValidationError_ChecksumMismatch = 2,
  CommandAck_ValidationError_BatchDeSerializeError = 3,
  CommandAck_ValidationError_DecryptionError = 4,
};

bool CommandAck_ValidationError_IsValid(int value);
extern const uint32_t CommandAck_ValidationError_internal_data_[];
constexpr CommandAck_ValidationError CommandAck_ValidationError_ValidationError_MIN = static_cast<CommandAck_ValidationError>(0);
constexpr CommandAck_ValidationError CommandAck_ValidationError_ValidationError_MAX = static_cast<CommandAck_ValidationError>(4);
constexpr int CommandAck_ValidationError_ValidationError_ARRAYSIZE = 4 + 1;
const std::string& CommandAck_ValidationError_Name(CommandAck_ValidationError value);
template <typename T>
const std::string& CommandAck_ValidationError_Name(T value) {
  static_assert(std::is_same<T, CommandAck_ValidationError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ValidationError_Name().");
  return CommandAck_ValidationError_Name(static_cast<CommandAck_ValidationError>(value));
}
const std::string& CommandAck_ValidationError_Name(CommandAck_ValidationError value);
bool CommandAck_ValidationError_Parse(absl::string_view name, CommandAck_ValidationError* value);
enum CommandTopicMigrated_ResourceType : int {
  CommandTopicMigrated_ResourceType_Producer = 0,
  CommandTopicMigrated_ResourceType_Consumer = 1,
};

bool CommandTopicMigrated_ResourceType_IsValid(int value);
extern const uint32_t CommandTopicMigrated_ResourceType_internal_data_[];
constexpr CommandTopicMigrated_ResourceType CommandTopicMigrated_ResourceType_ResourceType_MIN = static_cast<CommandTopicMigrated_ResourceType>(0);
constexpr CommandTopicMigrated_ResourceType CommandTopicMigrated_ResourceType_ResourceType_MAX = static_cast<CommandTopicMigrated_ResourceType>(1);
constexpr int CommandTopicMigrated_ResourceType_ResourceType_ARRAYSIZE = 1 + 1;
const std::string& CommandTopicMigrated_ResourceType_Name(CommandTopicMigrated_ResourceType value);
template <typename T>
const std::string& CommandTopicMigrated_ResourceType_Name(T value) {
  static_assert(std::is_same<T, CommandTopicMigrated_ResourceType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ResourceType_Name().");
  return CommandTopicMigrated_ResourceType_Name(static_cast<CommandTopicMigrated_ResourceType>(value));
}
const std::string& CommandTopicMigrated_ResourceType_Name(CommandTopicMigrated_ResourceType value);
bool CommandTopicMigrated_ResourceType_Parse(absl::string_view name, CommandTopicMigrated_ResourceType* value);
enum CommandGetTopicsOfNamespace_Mode : int {
  CommandGetTopicsOfNamespace_Mode_PERSISTENT = 0,
  CommandGetTopicsOfNamespace_Mode_NON_PERSISTENT = 1,
  CommandGetTopicsOfNamespace_Mode_ALL = 2,
};

bool CommandGetTopicsOfNamespace_Mode_IsValid(int value);
extern const uint32_t CommandGetTopicsOfNamespace_Mode_internal_data_[];
constexpr CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace_Mode_Mode_MIN = static_cast<CommandGetTopicsOfNamespace_Mode>(0);
constexpr CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace_Mode_Mode_MAX = static_cast<CommandGetTopicsOfNamespace_Mode>(2);
constexpr int CommandGetTopicsOfNamespace_Mode_Mode_ARRAYSIZE = 2 + 1;
const std::string& CommandGetTopicsOfNamespace_Mode_Name(CommandGetTopicsOfNamespace_Mode value);
template <typename T>
const std::string& CommandGetTopicsOfNamespace_Mode_Name(T value) {
  static_assert(std::is_same<T, CommandGetTopicsOfNamespace_Mode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Mode_Name().");
  return CommandGetTopicsOfNamespace_Mode_Name(static_cast<CommandGetTopicsOfNamespace_Mode>(value));
}
const std::string& CommandGetTopicsOfNamespace_Mode_Name(CommandGetTopicsOfNamespace_Mode value);
bool CommandGetTopicsOfNamespace_Mode_Parse(absl::string_view name, CommandGetTopicsOfNamespace_Mode* value);
enum BaseCommand_Type : int {
  BaseCommand_Type_CONNECT = 2,
  BaseCommand_Type_CONNECTED = 3,
  BaseCommand_Type_SUBSCRIBE = 4,
  BaseCommand_Type_PRODUCER = 5,
  BaseCommand_Type_SEND = 6,
  BaseCommand_Type_SEND_RECEIPT = 7,
  BaseCommand_Type_SEND_ERROR = 8,
  BaseCommand_Type_MESSAGE = 9,
  BaseCommand_Type_ACK = 10,
  BaseCommand_Type_FLOW = 11,
  BaseCommand_Type_UNSUBSCRIBE = 12,
  BaseCommand_Type_SUCCESS = 13,
  BaseCommand_Type_ERROR = 14,
  BaseCommand_Type_CLOSE_PRODUCER = 15,
  BaseCommand_Type_CLOSE_CONSUMER = 16,
  BaseCommand_Type_PRODUCER_SUCCESS = 17,
  BaseCommand_Type_PING = 18,
  BaseCommand_Type_PONG = 19,
  BaseCommand_Type_REDELIVER_UNACKNOWLEDGED_MESSAGES = 20,
  BaseCommand_Type_PARTITIONED_METADATA = 21,
  BaseCommand_Type_PARTITIONED_METADATA_RESPONSE = 22,
  BaseCommand_Type_LOOKUP = 23,
  BaseCommand_Type_LOOKUP_RESPONSE = 24,
  BaseCommand_Type_CONSUMER_STATS = 25,
  BaseCommand_Type_CONSUMER_STATS_RESPONSE = 26,
  BaseCommand_Type_REACHED_END_OF_TOPIC = 27,
  BaseCommand_Type_SEEK = 28,
  BaseCommand_Type_GET_LAST_MESSAGE_ID = 29,
  BaseCommand_Type_GET_LAST_MESSAGE_ID_RESPONSE = 30,
  BaseCommand_Type_ACTIVE_CONSUMER_CHANGE = 31,
  BaseCommand_Type_GET_TOPICS_OF_NAMESPACE = 32,
  BaseCommand_Type_GET_TOPICS_OF_NAMESPACE_RESPONSE = 33,
  BaseCommand_Type_GET_SCHEMA = 34,
  BaseCommand_Type_GET_SCHEMA_RESPONSE = 35,
  BaseCommand_Type_AUTH_CHALLENGE = 36,
  BaseCommand_Type_AUTH_RESPONSE = 37,
  BaseCommand_Type_ACK_RESPONSE = 38,
  BaseCommand_Type_GET_OR_CREATE_SCHEMA = 39,
  BaseCommand_Type_GET_OR_CREATE_SCHEMA_RESPONSE = 40,
  BaseCommand_Type_NEW_TXN = 50,
  BaseCommand_Type_NEW_TXN_RESPONSE = 51,
  BaseCommand_Type_ADD_PARTITION_TO_TXN = 52,
  BaseCommand_Type_ADD_PARTITION_TO_TXN_RESPONSE = 53,
  BaseCommand_Type_ADD_SUBSCRIPTION_TO_TXN = 54,
  BaseCommand_Type_ADD_SUBSCRIPTION_TO_TXN_RESPONSE = 55,
  BaseCommand_Type_END_TXN = 56,
  BaseCommand_Type_END_TXN_RESPONSE = 57,
  BaseCommand_Type_END_TXN_ON_PARTITION = 58,
  BaseCommand_Type_END_TXN_ON_PARTITION_RESPONSE = 59,
  BaseCommand_Type_END_TXN_ON_SUBSCRIPTION = 60,
  BaseCommand_Type_END_TXN_ON_SUBSCRIPTION_RESPONSE = 61,
  BaseCommand_Type_TC_CLIENT_CONNECT_REQUEST = 62,
  BaseCommand_Type_TC_CLIENT_CONNECT_RESPONSE = 63,
  BaseCommand_Type_WATCH_TOPIC_LIST = 64,
  BaseCommand_Type_WATCH_TOPIC_LIST_SUCCESS = 65,
  BaseCommand_Type_WATCH_TOPIC_UPDATE = 66,
  BaseCommand_Type_WATCH_TOPIC_LIST_CLOSE = 67,
  BaseCommand_Type_TOPIC_MIGRATED = 68,
};

bool BaseCommand_Type_IsValid(int value);
extern const uint32_t BaseCommand_Type_internal_data_[];
constexpr BaseCommand_Type BaseCommand_Type_Type_MIN = static_cast<BaseCommand_Type>(2);
constexpr BaseCommand_Type BaseCommand_Type_Type_MAX = static_cast<BaseCommand_Type>(68);
constexpr int BaseCommand_Type_Type_ARRAYSIZE = 68 + 1;
const std::string& BaseCommand_Type_Name(BaseCommand_Type value);
template <typename T>
const std::string& BaseCommand_Type_Name(T value) {
  static_assert(std::is_same<T, BaseCommand_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return BaseCommand_Type_Name(static_cast<BaseCommand_Type>(value));
}
const std::string& BaseCommand_Type_Name(BaseCommand_Type value);
bool BaseCommand_Type_Parse(absl::string_view name, BaseCommand_Type* value);
enum CompressionType : int {
  NONE = 0,
  LZ4 = 1,
  ZLIB = 2,
  ZSTD = 3,
  SNAPPY = 4,
};

bool CompressionType_IsValid(int value);
extern const uint32_t CompressionType_internal_data_[];
constexpr CompressionType CompressionType_MIN = static_cast<CompressionType>(0);
constexpr CompressionType CompressionType_MAX = static_cast<CompressionType>(4);
constexpr int CompressionType_ARRAYSIZE = 4 + 1;
const std::string& CompressionType_Name(CompressionType value);
template <typename T>
const std::string& CompressionType_Name(T value) {
  static_assert(std::is_same<T, CompressionType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CompressionType_Name().");
  return CompressionType_Name(static_cast<CompressionType>(value));
}
const std::string& CompressionType_Name(CompressionType value);
bool CompressionType_Parse(absl::string_view name, CompressionType* value);
enum ProducerAccessMode : int {
  Shared = 0,
  Exclusive = 1,
  WaitForExclusive = 2,
  ExclusiveWithFencing = 3,
};

bool ProducerAccessMode_IsValid(int value);
extern const uint32_t ProducerAccessMode_internal_data_[];
constexpr ProducerAccessMode ProducerAccessMode_MIN = static_cast<ProducerAccessMode>(0);
constexpr ProducerAccessMode ProducerAccessMode_MAX = static_cast<ProducerAccessMode>(3);
constexpr int ProducerAccessMode_ARRAYSIZE = 3 + 1;
const std::string& ProducerAccessMode_Name(ProducerAccessMode value);
template <typename T>
const std::string& ProducerAccessMode_Name(T value) {
  static_assert(std::is_same<T, ProducerAccessMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ProducerAccessMode_Name().");
  return ProducerAccessMode_Name(static_cast<ProducerAccessMode>(value));
}
const std::string& ProducerAccessMode_Name(ProducerAccessMode value);
bool ProducerAccessMode_Parse(absl::string_view name, ProducerAccessMode* value);
enum ServerError : int {
  UnknownError = 0,
  MetadataError = 1,
  PersistenceError = 2,
  AuthenticationError = 3,
  AuthorizationError = 4,
  ConsumerBusy = 5,
  ServiceNotReady = 6,
  ProducerBlockedQuotaExceededError = 7,
  ProducerBlockedQuotaExceededException = 8,
  ChecksumError = 9,
  UnsupportedVersionError = 10,
  TopicNotFound = 11,
  SubscriptionNotFound = 12,
  ConsumerNotFound = 13,
  TooManyRequests = 14,
  TopicTerminatedError = 15,
  ProducerBusy = 16,
  InvalidTopicName = 17,
  IncompatibleSchema = 18,
  ConsumerAssignError = 19,
  TransactionCoordinatorNotFound = 20,
  InvalidTxnStatus = 21,
  NotAllowedError = 22,
  TransactionConflict = 23,
  TransactionNotFound = 24,
  ProducerFenced = 25,
};

bool ServerError_IsValid(int value);
extern const uint32_t ServerError_internal_data_[];
constexpr ServerError ServerError_MIN = static_cast<ServerError>(0);
constexpr ServerError ServerError_MAX = static_cast<ServerError>(25);
constexpr int ServerError_ARRAYSIZE = 25 + 1;
const std::string& ServerError_Name(ServerError value);
template <typename T>
const std::string& ServerError_Name(T value) {
  static_assert(std::is_same<T, ServerError>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ServerError_Name().");
  return ServerError_Name(static_cast<ServerError>(value));
}
const std::string& ServerError_Name(ServerError value);
bool ServerError_Parse(absl::string_view name, ServerError* value);
enum AuthMethod : int {
  AuthMethodNone = 0,
  AuthMethodYcaV1 = 1,
  AuthMethodAthens = 2,
};

bool AuthMethod_IsValid(int value);
extern const uint32_t AuthMethod_internal_data_[];
constexpr AuthMethod AuthMethod_MIN = static_cast<AuthMethod>(0);
constexpr AuthMethod AuthMethod_MAX = static_cast<AuthMethod>(2);
constexpr int AuthMethod_ARRAYSIZE = 2 + 1;
const std::string& AuthMethod_Name(AuthMethod value);
template <typename T>
const std::string& AuthMethod_Name(T value) {
  static_assert(std::is_same<T, AuthMethod>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AuthMethod_Name().");
  return AuthMethod_Name(static_cast<AuthMethod>(value));
}
const std::string& AuthMethod_Name(AuthMethod value);
bool AuthMethod_Parse(absl::string_view name, AuthMethod* value);
enum ProtocolVersion : int {
  v0 = 0,
  v1 = 1,
  v2 = 2,
  v3 = 3,
  v4 = 4,
  v5 = 5,
  v6 = 6,
  v7 = 7,
  v8 = 8,
  v9 = 9,
  v10 = 10,
  v11 = 11,
  v12 = 12,
  v13 = 13,
  v14 = 14,
  v15 = 15,
  v16 = 16,
  v17 = 17,
  v18 = 18,
  v19 = 19,
  v20 = 20,
};

bool ProtocolVersion_IsValid(int value);
extern const uint32_t ProtocolVersion_internal_data_[];
constexpr ProtocolVersion ProtocolVersion_MIN = static_cast<ProtocolVersion>(0);
constexpr ProtocolVersion ProtocolVersion_MAX = static_cast<ProtocolVersion>(20);
constexpr int ProtocolVersion_ARRAYSIZE = 20 + 1;
const std::string& ProtocolVersion_Name(ProtocolVersion value);
template <typename T>
const std::string& ProtocolVersion_Name(T value) {
  static_assert(std::is_same<T, ProtocolVersion>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ProtocolVersion_Name().");
  return ProtocolVersion_Name(static_cast<ProtocolVersion>(value));
}
const std::string& ProtocolVersion_Name(ProtocolVersion value);
bool ProtocolVersion_Parse(absl::string_view name, ProtocolVersion* value);
enum KeySharedMode : int {
  AUTO_SPLIT = 0,
  STICKY = 1,
};

bool KeySharedMode_IsValid(int value);
extern const uint32_t KeySharedMode_internal_data_[];
constexpr KeySharedMode KeySharedMode_MIN = static_cast<KeySharedMode>(0);
constexpr KeySharedMode KeySharedMode_MAX = static_cast<KeySharedMode>(1);
constexpr int KeySharedMode_ARRAYSIZE = 1 + 1;
const std::string& KeySharedMode_Name(KeySharedMode value);
template <typename T>
const std::string& KeySharedMode_Name(T value) {
  static_assert(std::is_same<T, KeySharedMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to KeySharedMode_Name().");
  return KeySharedMode_Name(static_cast<KeySharedMode>(value));
}
const std::string& KeySharedMode_Name(KeySharedMode value);
bool KeySharedMode_Parse(absl::string_view name, KeySharedMode* value);
enum TxnAction : int {
  COMMIT = 0,
  ABORT = 1,
};

bool TxnAction_IsValid(int value);
extern const uint32_t TxnAction_internal_data_[];
constexpr TxnAction TxnAction_MIN = static_cast<TxnAction>(0);
constexpr TxnAction TxnAction_MAX = static_cast<TxnAction>(1);
constexpr int TxnAction_ARRAYSIZE = 1 + 1;
const std::string& TxnAction_Name(TxnAction value);
template <typename T>
const std::string& TxnAction_Name(T value) {
  static_assert(std::is_same<T, TxnAction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TxnAction_Name().");
  return TxnAction_Name(static_cast<TxnAction>(value));
}
const std::string& TxnAction_Name(TxnAction value);
bool TxnAction_Parse(absl::string_view name, TxnAction* value);

// ===================================================================


// -------------------------------------------------------------------

class Subscription final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.Subscription) */ {
 public:
  inline Subscription() : Subscription(nullptr) {}
  ~Subscription() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Subscription(::google::protobuf::internal::ConstantInitialized);

  inline Subscription(const Subscription& from)
      : Subscription(nullptr, from) {}
  Subscription(Subscription&& from) noexcept
    : Subscription() {
    *this = ::std::move(from);
  }

  inline Subscription& operator=(const Subscription& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subscription& operator=(Subscription&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Subscription& default_instance() {
    return *internal_default_instance();
  }
  static inline const Subscription* internal_default_instance() {
    return reinterpret_cast<const Subscription*>(
               &_Subscription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(Subscription& a, Subscription& b) {
    a.Swap(&b);
  }
  inline void Swap(Subscription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subscription* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Subscription* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Subscription>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Subscription& from);
  void MergeFrom(const Subscription& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Subscription* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.Subscription";
  }
  protected:
  explicit Subscription(::google::protobuf::Arena* arena);
  Subscription(::google::protobuf::Arena* arena, const Subscription& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kSubscriptionFieldNumber = 2,
  };
  // required string topic = 1;
  bool has_topic() const;
  void clear_topic() ;
  const std::string& topic() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topic(Arg_&& arg, Args_... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* value);

  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(
      const std::string& value);
  std::string* _internal_mutable_topic();

  public:
  // required string subscription = 2;
  bool has_subscription() const;
  void clear_subscription() ;
  const std::string& subscription() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subscription(Arg_&& arg, Args_... args);
  std::string* mutable_subscription();
  PROTOBUF_NODISCARD std::string* release_subscription();
  void set_allocated_subscription(std::string* value);

  private:
  const std::string& _internal_subscription() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscription(
      const std::string& value);
  std::string* _internal_mutable_subscription();

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.Subscription)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr topic_;
    ::google::protobuf::internal::ArenaStringPtr subscription_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class MessageIdData final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.MessageIdData) */ {
 public:
  inline MessageIdData() : MessageIdData(nullptr) {}
  ~MessageIdData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MessageIdData(::google::protobuf::internal::ConstantInitialized);

  inline MessageIdData(const MessageIdData& from)
      : MessageIdData(nullptr, from) {}
  MessageIdData(MessageIdData&& from) noexcept
    : MessageIdData() {
    *this = ::std::move(from);
  }

  inline MessageIdData& operator=(const MessageIdData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageIdData& operator=(MessageIdData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MessageIdData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageIdData* internal_default_instance() {
    return reinterpret_cast<const MessageIdData*>(
               &_MessageIdData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MessageIdData& a, MessageIdData& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageIdData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageIdData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageIdData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageIdData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const MessageIdData& from);
  void MergeFrom(const MessageIdData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MessageIdData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.MessageIdData";
  }
  protected:
  explicit MessageIdData(::google::protobuf::Arena* arena);
  MessageIdData(::google::protobuf::Arena* arena, const MessageIdData& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckSetFieldNumber = 5,
    kFirstChunkMessageIdFieldNumber = 7,
    kLedgerIdFieldNumber = 1,
    kEntryIdFieldNumber = 2,
    kBatchSizeFieldNumber = 6,
    kPartitionFieldNumber = 3,
    kBatchIndexFieldNumber = 4,
  };
  // repeated int64 ack_set = 5;
  int ack_set_size() const;
  private:
  int _internal_ack_set_size() const;

  public:
  void clear_ack_set() ;
  ::int64_t ack_set(int index) const;
  void set_ack_set(int index, ::int64_t value);
  void add_ack_set(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& ack_set() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_ack_set();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_ack_set() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_ack_set();

  public:
  // optional .pulsar.proto.MessageIdData first_chunk_message_id = 7;
  bool has_first_chunk_message_id() const;
  void clear_first_chunk_message_id() ;
  const ::pulsar::proto::MessageIdData& first_chunk_message_id() const;
  PROTOBUF_NODISCARD ::pulsar::proto::MessageIdData* release_first_chunk_message_id();
  ::pulsar::proto::MessageIdData* mutable_first_chunk_message_id();
  void set_allocated_first_chunk_message_id(::pulsar::proto::MessageIdData* value);
  void unsafe_arena_set_allocated_first_chunk_message_id(::pulsar::proto::MessageIdData* value);
  ::pulsar::proto::MessageIdData* unsafe_arena_release_first_chunk_message_id();

  private:
  const ::pulsar::proto::MessageIdData& _internal_first_chunk_message_id() const;
  ::pulsar::proto::MessageIdData* _internal_mutable_first_chunk_message_id();

  public:
  // required uint64 ledgerId = 1;
  bool has_ledgerid() const;
  void clear_ledgerid() ;
  ::uint64_t ledgerid() const;
  void set_ledgerid(::uint64_t value);

  private:
  ::uint64_t _internal_ledgerid() const;
  void _internal_set_ledgerid(::uint64_t value);

  public:
  // required uint64 entryId = 2;
  bool has_entryid() const;
  void clear_entryid() ;
  ::uint64_t entryid() const;
  void set_entryid(::uint64_t value);

  private:
  ::uint64_t _internal_entryid() const;
  void _internal_set_entryid(::uint64_t value);

  public:
  // optional int32 batch_size = 6;
  bool has_batch_size() const;
  void clear_batch_size() ;
  ::int32_t batch_size() const;
  void set_batch_size(::int32_t value);

  private:
  ::int32_t _internal_batch_size() const;
  void _internal_set_batch_size(::int32_t value);

  public:
  // optional int32 partition = 3 [default = -1];
  bool has_partition() const;
  void clear_partition() ;
  ::int32_t partition() const;
  void set_partition(::int32_t value);

  private:
  ::int32_t _internal_partition() const;
  void _internal_set_partition(::int32_t value);

  public:
  // optional int32 batch_index = 4 [default = -1];
  bool has_batch_index() const;
  void clear_batch_index() ;
  ::int32_t batch_index() const;
  void set_batch_index(::int32_t value);

  private:
  ::int32_t _internal_batch_index() const;
  void _internal_set_batch_index(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.MessageIdData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> ack_set_;
    ::pulsar::proto::MessageIdData* first_chunk_message_id_;
    ::uint64_t ledgerid_;
    ::uint64_t entryid_;
    ::int32_t batch_size_;
    ::int32_t partition_;
    ::int32_t batch_index_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class KeyValue final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.KeyValue) */ {
 public:
  inline KeyValue() : KeyValue(nullptr) {}
  ~KeyValue() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR KeyValue(::google::protobuf::internal::ConstantInitialized);

  inline KeyValue(const KeyValue& from)
      : KeyValue(nullptr, from) {}
  KeyValue(KeyValue&& from) noexcept
    : KeyValue() {
    *this = ::std::move(from);
  }

  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValue& operator=(KeyValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KeyValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyValue* internal_default_instance() {
    return reinterpret_cast<const KeyValue*>(
               &_KeyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(KeyValue& a, KeyValue& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyValue* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const KeyValue& from);
  void MergeFrom(const KeyValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(KeyValue* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.KeyValue";
  }
  protected:
  explicit KeyValue(::google::protobuf::Arena* arena);
  KeyValue(::google::protobuf::Arena* arena, const KeyValue& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required string key = 1;
  bool has_key() const;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // required string value = 2;
  bool has_value() const;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.KeyValue)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class KeyLongValue final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.KeyLongValue) */ {
 public:
  inline KeyLongValue() : KeyLongValue(nullptr) {}
  ~KeyLongValue() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR KeyLongValue(::google::protobuf::internal::ConstantInitialized);

  inline KeyLongValue(const KeyLongValue& from)
      : KeyLongValue(nullptr, from) {}
  KeyLongValue(KeyLongValue&& from) noexcept
    : KeyLongValue() {
    *this = ::std::move(from);
  }

  inline KeyLongValue& operator=(const KeyLongValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyLongValue& operator=(KeyLongValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KeyLongValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyLongValue* internal_default_instance() {
    return reinterpret_cast<const KeyLongValue*>(
               &_KeyLongValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(KeyLongValue& a, KeyLongValue& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyLongValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyLongValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyLongValue* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyLongValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const KeyLongValue& from);
  void MergeFrom(const KeyLongValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(KeyLongValue* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.KeyLongValue";
  }
  protected:
  explicit KeyLongValue(::google::protobuf::Arena* arena);
  KeyLongValue(::google::protobuf::Arena* arena, const KeyLongValue& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required string key = 1;
  bool has_key() const;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // required uint64 value = 2;
  bool has_value() const;
  void clear_value() ;
  ::uint64_t value() const;
  void set_value(::uint64_t value);

  private:
  ::uint64_t _internal_value() const;
  void _internal_set_value(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.KeyLongValue)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::uint64_t value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class IntRange final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.IntRange) */ {
 public:
  inline IntRange() : IntRange(nullptr) {}
  ~IntRange() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IntRange(::google::protobuf::internal::ConstantInitialized);

  inline IntRange(const IntRange& from)
      : IntRange(nullptr, from) {}
  IntRange(IntRange&& from) noexcept
    : IntRange() {
    *this = ::std::move(from);
  }

  inline IntRange& operator=(const IntRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntRange& operator=(IntRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IntRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntRange* internal_default_instance() {
    return reinterpret_cast<const IntRange*>(
               &_IntRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(IntRange& a, IntRange& b) {
    a.Swap(&b);
  }
  inline void Swap(IntRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntRange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntRange* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntRange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const IntRange& from);
  void MergeFrom(const IntRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IntRange* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.IntRange";
  }
  protected:
  explicit IntRange(::google::protobuf::Arena* arena);
  IntRange(::google::protobuf::Arena* arena, const IntRange& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // required int32 start = 1;
  bool has_start() const;
  void clear_start() ;
  ::int32_t start() const;
  void set_start(::int32_t value);

  private:
  ::int32_t _internal_start() const;
  void _internal_set_start(::int32_t value);

  public:
  // required int32 end = 2;
  bool has_end() const;
  void clear_end() ;
  ::int32_t end() const;
  void set_end(::int32_t value);

  private:
  ::int32_t _internal_end() const;
  void _internal_set_end(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.IntRange)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t start_;
    ::int32_t end_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class FeatureFlags final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.FeatureFlags) */ {
 public:
  inline FeatureFlags() : FeatureFlags(nullptr) {}
  ~FeatureFlags() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FeatureFlags(::google::protobuf::internal::ConstantInitialized);

  inline FeatureFlags(const FeatureFlags& from)
      : FeatureFlags(nullptr, from) {}
  FeatureFlags(FeatureFlags&& from) noexcept
    : FeatureFlags() {
    *this = ::std::move(from);
  }

  inline FeatureFlags& operator=(const FeatureFlags& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeatureFlags& operator=(FeatureFlags&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FeatureFlags& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeatureFlags* internal_default_instance() {
    return reinterpret_cast<const FeatureFlags*>(
               &_FeatureFlags_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FeatureFlags& a, FeatureFlags& b) {
    a.Swap(&b);
  }
  inline void Swap(FeatureFlags* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeatureFlags* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeatureFlags* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeatureFlags>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const FeatureFlags& from);
  void MergeFrom(const FeatureFlags& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FeatureFlags* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.FeatureFlags";
  }
  protected:
  explicit FeatureFlags(::google::protobuf::Arena* arena);
  FeatureFlags(::google::protobuf::Arena* arena, const FeatureFlags& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportsAuthRefreshFieldNumber = 1,
    kSupportsBrokerEntryMetadataFieldNumber = 2,
    kSupportsPartialProducerFieldNumber = 3,
    kSupportsTopicWatchersFieldNumber = 4,
  };
  // optional bool supports_auth_refresh = 1 [default = false];
  bool has_supports_auth_refresh() const;
  void clear_supports_auth_refresh() ;
  bool supports_auth_refresh() const;
  void set_supports_auth_refresh(bool value);

  private:
  bool _internal_supports_auth_refresh() const;
  void _internal_set_supports_auth_refresh(bool value);

  public:
  // optional bool supports_broker_entry_metadata = 2 [default = false];
  bool has_supports_broker_entry_metadata() const;
  void clear_supports_broker_entry_metadata() ;
  bool supports_broker_entry_metadata() const;
  void set_supports_broker_entry_metadata(bool value);

  private:
  bool _internal_supports_broker_entry_metadata() const;
  void _internal_set_supports_broker_entry_metadata(bool value);

  public:
  // optional bool supports_partial_producer = 3 [default = false];
  bool has_supports_partial_producer() const;
  void clear_supports_partial_producer() ;
  bool supports_partial_producer() const;
  void set_supports_partial_producer(bool value);

  private:
  bool _internal_supports_partial_producer() const;
  void _internal_set_supports_partial_producer(bool value);

  public:
  // optional bool supports_topic_watchers = 4 [default = false];
  bool has_supports_topic_watchers() const;
  void clear_supports_topic_watchers() ;
  bool supports_topic_watchers() const;
  void set_supports_topic_watchers(bool value);

  private:
  bool _internal_supports_topic_watchers() const;
  void _internal_set_supports_topic_watchers(bool value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.FeatureFlags)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool supports_auth_refresh_;
    bool supports_broker_entry_metadata_;
    bool supports_partial_producer_;
    bool supports_topic_watchers_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandWatchTopicUpdate final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandWatchTopicUpdate) */ {
 public:
  inline CommandWatchTopicUpdate() : CommandWatchTopicUpdate(nullptr) {}
  ~CommandWatchTopicUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandWatchTopicUpdate(::google::protobuf::internal::ConstantInitialized);

  inline CommandWatchTopicUpdate(const CommandWatchTopicUpdate& from)
      : CommandWatchTopicUpdate(nullptr, from) {}
  CommandWatchTopicUpdate(CommandWatchTopicUpdate&& from) noexcept
    : CommandWatchTopicUpdate() {
    *this = ::std::move(from);
  }

  inline CommandWatchTopicUpdate& operator=(const CommandWatchTopicUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandWatchTopicUpdate& operator=(CommandWatchTopicUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandWatchTopicUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandWatchTopicUpdate* internal_default_instance() {
    return reinterpret_cast<const CommandWatchTopicUpdate*>(
               &_CommandWatchTopicUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(CommandWatchTopicUpdate& a, CommandWatchTopicUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandWatchTopicUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandWatchTopicUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandWatchTopicUpdate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandWatchTopicUpdate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandWatchTopicUpdate& from);
  void MergeFrom(const CommandWatchTopicUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandWatchTopicUpdate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandWatchTopicUpdate";
  }
  protected:
  explicit CommandWatchTopicUpdate(::google::protobuf::Arena* arena);
  CommandWatchTopicUpdate(::google::protobuf::Arena* arena, const CommandWatchTopicUpdate& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewTopicsFieldNumber = 2,
    kDeletedTopicsFieldNumber = 3,
    kTopicsHashFieldNumber = 4,
    kWatcherIdFieldNumber = 1,
  };
  // repeated string new_topics = 2;
  int new_topics_size() const;
  private:
  int _internal_new_topics_size() const;

  public:
  void clear_new_topics() ;
  const std::string& new_topics(int index) const;
  std::string* mutable_new_topics(int index);
  void set_new_topics(int index, const std::string& value);
  void set_new_topics(int index, std::string&& value);
  void set_new_topics(int index, const char* value);
  void set_new_topics(int index, const char* value, std::size_t size);
  void set_new_topics(int index, absl::string_view value);
  std::string* add_new_topics();
  void add_new_topics(const std::string& value);
  void add_new_topics(std::string&& value);
  void add_new_topics(const char* value);
  void add_new_topics(const char* value, std::size_t size);
  void add_new_topics(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& new_topics() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_new_topics();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_new_topics() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_new_topics();

  public:
  // repeated string deleted_topics = 3;
  int deleted_topics_size() const;
  private:
  int _internal_deleted_topics_size() const;

  public:
  void clear_deleted_topics() ;
  const std::string& deleted_topics(int index) const;
  std::string* mutable_deleted_topics(int index);
  void set_deleted_topics(int index, const std::string& value);
  void set_deleted_topics(int index, std::string&& value);
  void set_deleted_topics(int index, const char* value);
  void set_deleted_topics(int index, const char* value, std::size_t size);
  void set_deleted_topics(int index, absl::string_view value);
  std::string* add_deleted_topics();
  void add_deleted_topics(const std::string& value);
  void add_deleted_topics(std::string&& value);
  void add_deleted_topics(const char* value);
  void add_deleted_topics(const char* value, std::size_t size);
  void add_deleted_topics(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& deleted_topics() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_deleted_topics();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_deleted_topics() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_deleted_topics();

  public:
  // required string topics_hash = 4;
  bool has_topics_hash() const;
  void clear_topics_hash() ;
  const std::string& topics_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topics_hash(Arg_&& arg, Args_... args);
  std::string* mutable_topics_hash();
  PROTOBUF_NODISCARD std::string* release_topics_hash();
  void set_allocated_topics_hash(std::string* value);

  private:
  const std::string& _internal_topics_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topics_hash(
      const std::string& value);
  std::string* _internal_mutable_topics_hash();

  public:
  // required uint64 watcher_id = 1;
  bool has_watcher_id() const;
  void clear_watcher_id() ;
  ::uint64_t watcher_id() const;
  void set_watcher_id(::uint64_t value);

  private:
  ::uint64_t _internal_watcher_id() const;
  void _internal_set_watcher_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandWatchTopicUpdate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> new_topics_;
    ::google::protobuf::RepeatedPtrField<std::string> deleted_topics_;
    ::google::protobuf::internal::ArenaStringPtr topics_hash_;
    ::uint64_t watcher_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandWatchTopicListSuccess final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandWatchTopicListSuccess) */ {
 public:
  inline CommandWatchTopicListSuccess() : CommandWatchTopicListSuccess(nullptr) {}
  ~CommandWatchTopicListSuccess() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandWatchTopicListSuccess(::google::protobuf::internal::ConstantInitialized);

  inline CommandWatchTopicListSuccess(const CommandWatchTopicListSuccess& from)
      : CommandWatchTopicListSuccess(nullptr, from) {}
  CommandWatchTopicListSuccess(CommandWatchTopicListSuccess&& from) noexcept
    : CommandWatchTopicListSuccess() {
    *this = ::std::move(from);
  }

  inline CommandWatchTopicListSuccess& operator=(const CommandWatchTopicListSuccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandWatchTopicListSuccess& operator=(CommandWatchTopicListSuccess&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandWatchTopicListSuccess& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandWatchTopicListSuccess* internal_default_instance() {
    return reinterpret_cast<const CommandWatchTopicListSuccess*>(
               &_CommandWatchTopicListSuccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(CommandWatchTopicListSuccess& a, CommandWatchTopicListSuccess& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandWatchTopicListSuccess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandWatchTopicListSuccess* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandWatchTopicListSuccess* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandWatchTopicListSuccess>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandWatchTopicListSuccess& from);
  void MergeFrom(const CommandWatchTopicListSuccess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandWatchTopicListSuccess* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandWatchTopicListSuccess";
  }
  protected:
  explicit CommandWatchTopicListSuccess(::google::protobuf::Arena* arena);
  CommandWatchTopicListSuccess(::google::protobuf::Arena* arena, const CommandWatchTopicListSuccess& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 3,
    kTopicsHashFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kWatcherIdFieldNumber = 2,
  };
  // repeated string topic = 3;
  int topic_size() const;
  private:
  int _internal_topic_size() const;

  public:
  void clear_topic() ;
  const std::string& topic(int index) const;
  std::string* mutable_topic(int index);
  void set_topic(int index, const std::string& value);
  void set_topic(int index, std::string&& value);
  void set_topic(int index, const char* value);
  void set_topic(int index, const char* value, std::size_t size);
  void set_topic(int index, absl::string_view value);
  std::string* add_topic();
  void add_topic(const std::string& value);
  void add_topic(std::string&& value);
  void add_topic(const char* value);
  void add_topic(const char* value, std::size_t size);
  void add_topic(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& topic() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_topic();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_topic() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_topic();

  public:
  // required string topics_hash = 4;
  bool has_topics_hash() const;
  void clear_topics_hash() ;
  const std::string& topics_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topics_hash(Arg_&& arg, Args_... args);
  std::string* mutable_topics_hash();
  PROTOBUF_NODISCARD std::string* release_topics_hash();
  void set_allocated_topics_hash(std::string* value);

  private:
  const std::string& _internal_topics_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topics_hash(
      const std::string& value);
  std::string* _internal_mutable_topics_hash();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // required uint64 watcher_id = 2;
  bool has_watcher_id() const;
  void clear_watcher_id() ;
  ::uint64_t watcher_id() const;
  void set_watcher_id(::uint64_t value);

  private:
  ::uint64_t _internal_watcher_id() const;
  void _internal_set_watcher_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandWatchTopicListSuccess)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> topic_;
    ::google::protobuf::internal::ArenaStringPtr topics_hash_;
    ::uint64_t request_id_;
    ::uint64_t watcher_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandWatchTopicListClose final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandWatchTopicListClose) */ {
 public:
  inline CommandWatchTopicListClose() : CommandWatchTopicListClose(nullptr) {}
  ~CommandWatchTopicListClose() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandWatchTopicListClose(::google::protobuf::internal::ConstantInitialized);

  inline CommandWatchTopicListClose(const CommandWatchTopicListClose& from)
      : CommandWatchTopicListClose(nullptr, from) {}
  CommandWatchTopicListClose(CommandWatchTopicListClose&& from) noexcept
    : CommandWatchTopicListClose() {
    *this = ::std::move(from);
  }

  inline CommandWatchTopicListClose& operator=(const CommandWatchTopicListClose& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandWatchTopicListClose& operator=(CommandWatchTopicListClose&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandWatchTopicListClose& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandWatchTopicListClose* internal_default_instance() {
    return reinterpret_cast<const CommandWatchTopicListClose*>(
               &_CommandWatchTopicListClose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(CommandWatchTopicListClose& a, CommandWatchTopicListClose& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandWatchTopicListClose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandWatchTopicListClose* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandWatchTopicListClose* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandWatchTopicListClose>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandWatchTopicListClose& from);
  void MergeFrom(const CommandWatchTopicListClose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandWatchTopicListClose* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandWatchTopicListClose";
  }
  protected:
  explicit CommandWatchTopicListClose(::google::protobuf::Arena* arena);
  CommandWatchTopicListClose(::google::protobuf::Arena* arena, const CommandWatchTopicListClose& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kWatcherIdFieldNumber = 2,
  };
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // required uint64 watcher_id = 2;
  bool has_watcher_id() const;
  void clear_watcher_id() ;
  ::uint64_t watcher_id() const;
  void set_watcher_id(::uint64_t value);

  private:
  ::uint64_t _internal_watcher_id() const;
  void _internal_set_watcher_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandWatchTopicListClose)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t request_id_;
    ::uint64_t watcher_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandWatchTopicList final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandWatchTopicList) */ {
 public:
  inline CommandWatchTopicList() : CommandWatchTopicList(nullptr) {}
  ~CommandWatchTopicList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandWatchTopicList(::google::protobuf::internal::ConstantInitialized);

  inline CommandWatchTopicList(const CommandWatchTopicList& from)
      : CommandWatchTopicList(nullptr, from) {}
  CommandWatchTopicList(CommandWatchTopicList&& from) noexcept
    : CommandWatchTopicList() {
    *this = ::std::move(from);
  }

  inline CommandWatchTopicList& operator=(const CommandWatchTopicList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandWatchTopicList& operator=(CommandWatchTopicList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandWatchTopicList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandWatchTopicList* internal_default_instance() {
    return reinterpret_cast<const CommandWatchTopicList*>(
               &_CommandWatchTopicList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(CommandWatchTopicList& a, CommandWatchTopicList& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandWatchTopicList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandWatchTopicList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandWatchTopicList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandWatchTopicList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandWatchTopicList& from);
  void MergeFrom(const CommandWatchTopicList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandWatchTopicList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandWatchTopicList";
  }
  protected:
  explicit CommandWatchTopicList(::google::protobuf::Arena* arena);
  CommandWatchTopicList(::google::protobuf::Arena* arena, const CommandWatchTopicList& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceFieldNumber = 3,
    kTopicsPatternFieldNumber = 4,
    kTopicsHashFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kWatcherIdFieldNumber = 2,
  };
  // required string namespace = 3;
  bool has_namespace_() const;
  void clear_namespace_() ;
  const std::string& namespace_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_namespace_(Arg_&& arg, Args_... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* value);

  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(
      const std::string& value);
  std::string* _internal_mutable_namespace_();

  public:
  // required string topics_pattern = 4;
  bool has_topics_pattern() const;
  void clear_topics_pattern() ;
  const std::string& topics_pattern() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topics_pattern(Arg_&& arg, Args_... args);
  std::string* mutable_topics_pattern();
  PROTOBUF_NODISCARD std::string* release_topics_pattern();
  void set_allocated_topics_pattern(std::string* value);

  private:
  const std::string& _internal_topics_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topics_pattern(
      const std::string& value);
  std::string* _internal_mutable_topics_pattern();

  public:
  // optional string topics_hash = 5;
  bool has_topics_hash() const;
  void clear_topics_hash() ;
  const std::string& topics_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topics_hash(Arg_&& arg, Args_... args);
  std::string* mutable_topics_hash();
  PROTOBUF_NODISCARD std::string* release_topics_hash();
  void set_allocated_topics_hash(std::string* value);

  private:
  const std::string& _internal_topics_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topics_hash(
      const std::string& value);
  std::string* _internal_mutable_topics_hash();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // required uint64 watcher_id = 2;
  bool has_watcher_id() const;
  void clear_watcher_id() ;
  ::uint64_t watcher_id() const;
  void set_watcher_id(::uint64_t value);

  private:
  ::uint64_t _internal_watcher_id() const;
  void _internal_set_watcher_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandWatchTopicList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr namespace__;
    ::google::protobuf::internal::ArenaStringPtr topics_pattern_;
    ::google::protobuf::internal::ArenaStringPtr topics_hash_;
    ::uint64_t request_id_;
    ::uint64_t watcher_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandUnsubscribe final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandUnsubscribe) */ {
 public:
  inline CommandUnsubscribe() : CommandUnsubscribe(nullptr) {}
  ~CommandUnsubscribe() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandUnsubscribe(::google::protobuf::internal::ConstantInitialized);

  inline CommandUnsubscribe(const CommandUnsubscribe& from)
      : CommandUnsubscribe(nullptr, from) {}
  CommandUnsubscribe(CommandUnsubscribe&& from) noexcept
    : CommandUnsubscribe() {
    *this = ::std::move(from);
  }

  inline CommandUnsubscribe& operator=(const CommandUnsubscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandUnsubscribe& operator=(CommandUnsubscribe&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandUnsubscribe& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandUnsubscribe* internal_default_instance() {
    return reinterpret_cast<const CommandUnsubscribe*>(
               &_CommandUnsubscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CommandUnsubscribe& a, CommandUnsubscribe& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandUnsubscribe* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandUnsubscribe* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandUnsubscribe* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandUnsubscribe>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandUnsubscribe& from);
  void MergeFrom(const CommandUnsubscribe& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandUnsubscribe* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandUnsubscribe";
  }
  protected:
  explicit CommandUnsubscribe(::google::protobuf::Arena* arena);
  CommandUnsubscribe(::google::protobuf::Arena* arena, const CommandUnsubscribe& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsumerIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
  };
  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  void clear_consumer_id() ;
  ::uint64_t consumer_id() const;
  void set_consumer_id(::uint64_t value);

  private:
  ::uint64_t _internal_consumer_id() const;
  void _internal_set_consumer_id(::uint64_t value);

  public:
  // required uint64 request_id = 2;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandUnsubscribe)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t consumer_id_;
    ::uint64_t request_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandTopicMigrated final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandTopicMigrated) */ {
 public:
  inline CommandTopicMigrated() : CommandTopicMigrated(nullptr) {}
  ~CommandTopicMigrated() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandTopicMigrated(::google::protobuf::internal::ConstantInitialized);

  inline CommandTopicMigrated(const CommandTopicMigrated& from)
      : CommandTopicMigrated(nullptr, from) {}
  CommandTopicMigrated(CommandTopicMigrated&& from) noexcept
    : CommandTopicMigrated() {
    *this = ::std::move(from);
  }

  inline CommandTopicMigrated& operator=(const CommandTopicMigrated& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandTopicMigrated& operator=(CommandTopicMigrated&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandTopicMigrated& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandTopicMigrated* internal_default_instance() {
    return reinterpret_cast<const CommandTopicMigrated*>(
               &_CommandTopicMigrated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CommandTopicMigrated& a, CommandTopicMigrated& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandTopicMigrated* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandTopicMigrated* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandTopicMigrated* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandTopicMigrated>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandTopicMigrated& from);
  void MergeFrom(const CommandTopicMigrated& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandTopicMigrated* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandTopicMigrated";
  }
  protected:
  explicit CommandTopicMigrated(::google::protobuf::Arena* arena);
  CommandTopicMigrated(::google::protobuf::Arena* arena, const CommandTopicMigrated& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using ResourceType = CommandTopicMigrated_ResourceType;
  static constexpr ResourceType Producer = CommandTopicMigrated_ResourceType_Producer;
  static constexpr ResourceType Consumer = CommandTopicMigrated_ResourceType_Consumer;
  static inline bool ResourceType_IsValid(int value) {
    return CommandTopicMigrated_ResourceType_IsValid(value);
  }
  static constexpr ResourceType ResourceType_MIN = CommandTopicMigrated_ResourceType_ResourceType_MIN;
  static constexpr ResourceType ResourceType_MAX = CommandTopicMigrated_ResourceType_ResourceType_MAX;
  static constexpr int ResourceType_ARRAYSIZE = CommandTopicMigrated_ResourceType_ResourceType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& ResourceType_Name(T value) {
    return CommandTopicMigrated_ResourceType_Name(value);
  }
  static inline bool ResourceType_Parse(absl::string_view name, ResourceType* value) {
    return CommandTopicMigrated_ResourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBrokerServiceUrlFieldNumber = 3,
    kBrokerServiceUrlTlsFieldNumber = 4,
    kResourceIdFieldNumber = 1,
    kResourceTypeFieldNumber = 2,
  };
  // optional string brokerServiceUrl = 3;
  bool has_brokerserviceurl() const;
  void clear_brokerserviceurl() ;
  const std::string& brokerserviceurl() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_brokerserviceurl(Arg_&& arg, Args_... args);
  std::string* mutable_brokerserviceurl();
  PROTOBUF_NODISCARD std::string* release_brokerserviceurl();
  void set_allocated_brokerserviceurl(std::string* value);

  private:
  const std::string& _internal_brokerserviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brokerserviceurl(
      const std::string& value);
  std::string* _internal_mutable_brokerserviceurl();

  public:
  // optional string brokerServiceUrlTls = 4;
  bool has_brokerserviceurltls() const;
  void clear_brokerserviceurltls() ;
  const std::string& brokerserviceurltls() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_brokerserviceurltls(Arg_&& arg, Args_... args);
  std::string* mutable_brokerserviceurltls();
  PROTOBUF_NODISCARD std::string* release_brokerserviceurltls();
  void set_allocated_brokerserviceurltls(std::string* value);

  private:
  const std::string& _internal_brokerserviceurltls() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brokerserviceurltls(
      const std::string& value);
  std::string* _internal_mutable_brokerserviceurltls();

  public:
  // required uint64 resource_id = 1;
  bool has_resource_id() const;
  void clear_resource_id() ;
  ::uint64_t resource_id() const;
  void set_resource_id(::uint64_t value);

  private:
  ::uint64_t _internal_resource_id() const;
  void _internal_set_resource_id(::uint64_t value);

  public:
  // required .pulsar.proto.CommandTopicMigrated.ResourceType resource_type = 2;
  bool has_resource_type() const;
  void clear_resource_type() ;
  ::pulsar::proto::CommandTopicMigrated_ResourceType resource_type() const;
  void set_resource_type(::pulsar::proto::CommandTopicMigrated_ResourceType value);

  private:
  ::pulsar::proto::CommandTopicMigrated_ResourceType _internal_resource_type() const;
  void _internal_set_resource_type(::pulsar::proto::CommandTopicMigrated_ResourceType value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandTopicMigrated)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr brokerserviceurl_;
    ::google::protobuf::internal::ArenaStringPtr brokerserviceurltls_;
    ::uint64_t resource_id_;
    int resource_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandTcClientConnectResponse final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandTcClientConnectResponse) */ {
 public:
  inline CommandTcClientConnectResponse() : CommandTcClientConnectResponse(nullptr) {}
  ~CommandTcClientConnectResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandTcClientConnectResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommandTcClientConnectResponse(const CommandTcClientConnectResponse& from)
      : CommandTcClientConnectResponse(nullptr, from) {}
  CommandTcClientConnectResponse(CommandTcClientConnectResponse&& from) noexcept
    : CommandTcClientConnectResponse() {
    *this = ::std::move(from);
  }

  inline CommandTcClientConnectResponse& operator=(const CommandTcClientConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandTcClientConnectResponse& operator=(CommandTcClientConnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandTcClientConnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandTcClientConnectResponse* internal_default_instance() {
    return reinterpret_cast<const CommandTcClientConnectResponse*>(
               &_CommandTcClientConnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(CommandTcClientConnectResponse& a, CommandTcClientConnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandTcClientConnectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandTcClientConnectResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandTcClientConnectResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandTcClientConnectResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandTcClientConnectResponse& from);
  void MergeFrom(const CommandTcClientConnectResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandTcClientConnectResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandTcClientConnectResponse";
  }
  protected:
  explicit CommandTcClientConnectResponse(::google::protobuf::Arena* arena);
  CommandTcClientConnectResponse(::google::protobuf::Arena* arena, const CommandTcClientConnectResponse& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kRequestIdFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // optional string message = 3;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional .pulsar.proto.ServerError error = 2;
  bool has_error() const;
  void clear_error() ;
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);

  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandTcClientConnectResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint64_t request_id_;
    int error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandTcClientConnectRequest final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandTcClientConnectRequest) */ {
 public:
  inline CommandTcClientConnectRequest() : CommandTcClientConnectRequest(nullptr) {}
  ~CommandTcClientConnectRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandTcClientConnectRequest(::google::protobuf::internal::ConstantInitialized);

  inline CommandTcClientConnectRequest(const CommandTcClientConnectRequest& from)
      : CommandTcClientConnectRequest(nullptr, from) {}
  CommandTcClientConnectRequest(CommandTcClientConnectRequest&& from) noexcept
    : CommandTcClientConnectRequest() {
    *this = ::std::move(from);
  }

  inline CommandTcClientConnectRequest& operator=(const CommandTcClientConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandTcClientConnectRequest& operator=(CommandTcClientConnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandTcClientConnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandTcClientConnectRequest* internal_default_instance() {
    return reinterpret_cast<const CommandTcClientConnectRequest*>(
               &_CommandTcClientConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(CommandTcClientConnectRequest& a, CommandTcClientConnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandTcClientConnectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandTcClientConnectRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandTcClientConnectRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandTcClientConnectRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandTcClientConnectRequest& from);
  void MergeFrom(const CommandTcClientConnectRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandTcClientConnectRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandTcClientConnectRequest";
  }
  protected:
  explicit CommandTcClientConnectRequest(::google::protobuf::Arena* arena);
  CommandTcClientConnectRequest(::google::protobuf::Arena* arena, const CommandTcClientConnectRequest& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kTcIdFieldNumber = 2,
  };
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // required uint64 tc_id = 2 [default = 0];
  bool has_tc_id() const;
  void clear_tc_id() ;
  ::uint64_t tc_id() const;
  void set_tc_id(::uint64_t value);

  private:
  ::uint64_t _internal_tc_id() const;
  void _internal_set_tc_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandTcClientConnectRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t request_id_;
    ::uint64_t tc_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandSendError final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandSendError) */ {
 public:
  inline CommandSendError() : CommandSendError(nullptr) {}
  ~CommandSendError() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandSendError(::google::protobuf::internal::ConstantInitialized);

  inline CommandSendError(const CommandSendError& from)
      : CommandSendError(nullptr, from) {}
  CommandSendError(CommandSendError&& from) noexcept
    : CommandSendError() {
    *this = ::std::move(from);
  }

  inline CommandSendError& operator=(const CommandSendError& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandSendError& operator=(CommandSendError&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandSendError& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandSendError* internal_default_instance() {
    return reinterpret_cast<const CommandSendError*>(
               &_CommandSendError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CommandSendError& a, CommandSendError& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandSendError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandSendError* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandSendError* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandSendError>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandSendError& from);
  void MergeFrom(const CommandSendError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandSendError* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandSendError";
  }
  protected:
  explicit CommandSendError(::google::protobuf::Arena* arena);
  CommandSendError(::google::protobuf::Arena* arena, const CommandSendError& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 4,
    kProducerIdFieldNumber = 1,
    kSequenceIdFieldNumber = 2,
    kErrorFieldNumber = 3,
  };
  // required string message = 4;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // required uint64 producer_id = 1;
  bool has_producer_id() const;
  void clear_producer_id() ;
  ::uint64_t producer_id() const;
  void set_producer_id(::uint64_t value);

  private:
  ::uint64_t _internal_producer_id() const;
  void _internal_set_producer_id(::uint64_t value);

  public:
  // required uint64 sequence_id = 2;
  bool has_sequence_id() const;
  void clear_sequence_id() ;
  ::uint64_t sequence_id() const;
  void set_sequence_id(::uint64_t value);

  private:
  ::uint64_t _internal_sequence_id() const;
  void _internal_set_sequence_id(::uint64_t value);

  public:
  // required .pulsar.proto.ServerError error = 3;
  bool has_error() const;
  void clear_error() ;
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);

  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSendError)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint64_t producer_id_;
    ::uint64_t sequence_id_;
    int error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandReachedEndOfTopic final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandReachedEndOfTopic) */ {
 public:
  inline CommandReachedEndOfTopic() : CommandReachedEndOfTopic(nullptr) {}
  ~CommandReachedEndOfTopic() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandReachedEndOfTopic(::google::protobuf::internal::ConstantInitialized);

  inline CommandReachedEndOfTopic(const CommandReachedEndOfTopic& from)
      : CommandReachedEndOfTopic(nullptr, from) {}
  CommandReachedEndOfTopic(CommandReachedEndOfTopic&& from) noexcept
    : CommandReachedEndOfTopic() {
    *this = ::std::move(from);
  }

  inline CommandReachedEndOfTopic& operator=(const CommandReachedEndOfTopic& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandReachedEndOfTopic& operator=(CommandReachedEndOfTopic&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandReachedEndOfTopic& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandReachedEndOfTopic* internal_default_instance() {
    return reinterpret_cast<const CommandReachedEndOfTopic*>(
               &_CommandReachedEndOfTopic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CommandReachedEndOfTopic& a, CommandReachedEndOfTopic& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandReachedEndOfTopic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandReachedEndOfTopic* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandReachedEndOfTopic* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandReachedEndOfTopic>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandReachedEndOfTopic& from);
  void MergeFrom(const CommandReachedEndOfTopic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandReachedEndOfTopic* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandReachedEndOfTopic";
  }
  protected:
  explicit CommandReachedEndOfTopic(::google::protobuf::Arena* arena);
  CommandReachedEndOfTopic(::google::protobuf::Arena* arena, const CommandReachedEndOfTopic& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsumerIdFieldNumber = 1,
  };
  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  void clear_consumer_id() ;
  ::uint64_t consumer_id() const;
  void set_consumer_id(::uint64_t value);

  private:
  ::uint64_t _internal_consumer_id() const;
  void _internal_set_consumer_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandReachedEndOfTopic)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t consumer_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandProducerSuccess final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandProducerSuccess) */ {
 public:
  inline CommandProducerSuccess() : CommandProducerSuccess(nullptr) {}
  ~CommandProducerSuccess() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandProducerSuccess(::google::protobuf::internal::ConstantInitialized);

  inline CommandProducerSuccess(const CommandProducerSuccess& from)
      : CommandProducerSuccess(nullptr, from) {}
  CommandProducerSuccess(CommandProducerSuccess&& from) noexcept
    : CommandProducerSuccess() {
    *this = ::std::move(from);
  }

  inline CommandProducerSuccess& operator=(const CommandProducerSuccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandProducerSuccess& operator=(CommandProducerSuccess&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandProducerSuccess& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandProducerSuccess* internal_default_instance() {
    return reinterpret_cast<const CommandProducerSuccess*>(
               &_CommandProducerSuccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(CommandProducerSuccess& a, CommandProducerSuccess& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandProducerSuccess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandProducerSuccess* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandProducerSuccess* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandProducerSuccess>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandProducerSuccess& from);
  void MergeFrom(const CommandProducerSuccess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandProducerSuccess* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandProducerSuccess";
  }
  protected:
  explicit CommandProducerSuccess(::google::protobuf::Arena* arena);
  CommandProducerSuccess(::google::protobuf::Arena* arena, const CommandProducerSuccess& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProducerNameFieldNumber = 2,
    kSchemaVersionFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kTopicEpochFieldNumber = 5,
    kProducerReadyFieldNumber = 6,
    kLastSequenceIdFieldNumber = 3,
  };
  // required string producer_name = 2;
  bool has_producer_name() const;
  void clear_producer_name() ;
  const std::string& producer_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_producer_name(Arg_&& arg, Args_... args);
  std::string* mutable_producer_name();
  PROTOBUF_NODISCARD std::string* release_producer_name();
  void set_allocated_producer_name(std::string* value);

  private:
  const std::string& _internal_producer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_producer_name(
      const std::string& value);
  std::string* _internal_mutable_producer_name();

  public:
  // optional bytes schema_version = 4;
  bool has_schema_version() const;
  void clear_schema_version() ;
  const std::string& schema_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema_version(Arg_&& arg, Args_... args);
  std::string* mutable_schema_version();
  PROTOBUF_NODISCARD std::string* release_schema_version();
  void set_allocated_schema_version(std::string* value);

  private:
  const std::string& _internal_schema_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_version(
      const std::string& value);
  std::string* _internal_mutable_schema_version();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional uint64 topic_epoch = 5;
  bool has_topic_epoch() const;
  void clear_topic_epoch() ;
  ::uint64_t topic_epoch() const;
  void set_topic_epoch(::uint64_t value);

  private:
  ::uint64_t _internal_topic_epoch() const;
  void _internal_set_topic_epoch(::uint64_t value);

  public:
  // optional bool producer_ready = 6 [default = true];
  bool has_producer_ready() const;
  void clear_producer_ready() ;
  bool producer_ready() const;
  void set_producer_ready(bool value);

  private:
  bool _internal_producer_ready() const;
  void _internal_set_producer_ready(bool value);

  public:
  // optional int64 last_sequence_id = 3 [default = -1];
  bool has_last_sequence_id() const;
  void clear_last_sequence_id() ;
  ::int64_t last_sequence_id() const;
  void set_last_sequence_id(::int64_t value);

  private:
  ::int64_t _internal_last_sequence_id() const;
  void _internal_set_last_sequence_id(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandProducerSuccess)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr producer_name_;
    ::google::protobuf::internal::ArenaStringPtr schema_version_;
    ::uint64_t request_id_;
    ::uint64_t topic_epoch_;
    bool producer_ready_;
    ::int64_t last_sequence_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandPong final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandPong) */ {
 public:
  inline CommandPong() : CommandPong(nullptr) {}
  ~CommandPong() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandPong(::google::protobuf::internal::ConstantInitialized);

  inline CommandPong(const CommandPong& from)
      : CommandPong(nullptr, from) {}
  CommandPong(CommandPong&& from) noexcept
    : CommandPong() {
    *this = ::std::move(from);
  }

  inline CommandPong& operator=(const CommandPong& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandPong& operator=(CommandPong&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandPong& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandPong* internal_default_instance() {
    return reinterpret_cast<const CommandPong*>(
               &_CommandPong_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(CommandPong& a, CommandPong& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandPong* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandPong* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandPong* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandPong>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandPong& from);
  void MergeFrom(const CommandPong& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandPong* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandPong";
  }
  protected:
  explicit CommandPong(::google::protobuf::Arena* arena);
  CommandPong(::google::protobuf::Arena* arena, const CommandPong& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandPong)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandPing final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandPing) */ {
 public:
  inline CommandPing() : CommandPing(nullptr) {}
  ~CommandPing() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandPing(::google::protobuf::internal::ConstantInitialized);

  inline CommandPing(const CommandPing& from)
      : CommandPing(nullptr, from) {}
  CommandPing(CommandPing&& from) noexcept
    : CommandPing() {
    *this = ::std::move(from);
  }

  inline CommandPing& operator=(const CommandPing& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandPing& operator=(CommandPing&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandPing& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandPing* internal_default_instance() {
    return reinterpret_cast<const CommandPing*>(
               &_CommandPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(CommandPing& a, CommandPing& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandPing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandPing* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandPing* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandPing>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandPing& from);
  void MergeFrom(const CommandPing& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandPing* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandPing";
  }
  protected:
  explicit CommandPing(::google::protobuf::Arena* arena);
  CommandPing(::google::protobuf::Arena* arena, const CommandPing& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandPing)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandPartitionedTopicMetadataResponse final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandPartitionedTopicMetadataResponse) */ {
 public:
  inline CommandPartitionedTopicMetadataResponse() : CommandPartitionedTopicMetadataResponse(nullptr) {}
  ~CommandPartitionedTopicMetadataResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandPartitionedTopicMetadataResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommandPartitionedTopicMetadataResponse(const CommandPartitionedTopicMetadataResponse& from)
      : CommandPartitionedTopicMetadataResponse(nullptr, from) {}
  CommandPartitionedTopicMetadataResponse(CommandPartitionedTopicMetadataResponse&& from) noexcept
    : CommandPartitionedTopicMetadataResponse() {
    *this = ::std::move(from);
  }

  inline CommandPartitionedTopicMetadataResponse& operator=(const CommandPartitionedTopicMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandPartitionedTopicMetadataResponse& operator=(CommandPartitionedTopicMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandPartitionedTopicMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandPartitionedTopicMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const CommandPartitionedTopicMetadataResponse*>(
               &_CommandPartitionedTopicMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CommandPartitionedTopicMetadataResponse& a, CommandPartitionedTopicMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandPartitionedTopicMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandPartitionedTopicMetadataResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandPartitionedTopicMetadataResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandPartitionedTopicMetadataResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandPartitionedTopicMetadataResponse& from);
  void MergeFrom(const CommandPartitionedTopicMetadataResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandPartitionedTopicMetadataResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandPartitionedTopicMetadataResponse";
  }
  protected:
  explicit CommandPartitionedTopicMetadataResponse(::google::protobuf::Arena* arena);
  CommandPartitionedTopicMetadataResponse(::google::protobuf::Arena* arena, const CommandPartitionedTopicMetadataResponse& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using LookupType = CommandPartitionedTopicMetadataResponse_LookupType;
  static constexpr LookupType Success = CommandPartitionedTopicMetadataResponse_LookupType_Success;
  static constexpr LookupType Failed = CommandPartitionedTopicMetadataResponse_LookupType_Failed;
  static inline bool LookupType_IsValid(int value) {
    return CommandPartitionedTopicMetadataResponse_LookupType_IsValid(value);
  }
  static constexpr LookupType LookupType_MIN = CommandPartitionedTopicMetadataResponse_LookupType_LookupType_MIN;
  static constexpr LookupType LookupType_MAX = CommandPartitionedTopicMetadataResponse_LookupType_LookupType_MAX;
  static constexpr int LookupType_ARRAYSIZE = CommandPartitionedTopicMetadataResponse_LookupType_LookupType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& LookupType_Name(T value) {
    return CommandPartitionedTopicMetadataResponse_LookupType_Name(value);
  }
  static inline bool LookupType_Parse(absl::string_view name, LookupType* value) {
    return CommandPartitionedTopicMetadataResponse_LookupType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 5,
    kRequestIdFieldNumber = 2,
    kPartitionsFieldNumber = 1,
    kResponseFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // optional string message = 5;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // required uint64 request_id = 2;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional uint32 partitions = 1;
  bool has_partitions() const;
  void clear_partitions() ;
  ::uint32_t partitions() const;
  void set_partitions(::uint32_t value);

  private:
  ::uint32_t _internal_partitions() const;
  void _internal_set_partitions(::uint32_t value);

  public:
  // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse.LookupType response = 3;
  bool has_response() const;
  void clear_response() ;
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType response() const;
  void set_response(::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType value);

  private:
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType _internal_response() const;
  void _internal_set_response(::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType value);

  public:
  // optional .pulsar.proto.ServerError error = 4;
  bool has_error() const;
  void clear_error() ;
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);

  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandPartitionedTopicMetadataResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint64_t request_id_;
    ::uint32_t partitions_;
    int response_;
    int error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandPartitionedTopicMetadata final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandPartitionedTopicMetadata) */ {
 public:
  inline CommandPartitionedTopicMetadata() : CommandPartitionedTopicMetadata(nullptr) {}
  ~CommandPartitionedTopicMetadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandPartitionedTopicMetadata(::google::protobuf::internal::ConstantInitialized);

  inline CommandPartitionedTopicMetadata(const CommandPartitionedTopicMetadata& from)
      : CommandPartitionedTopicMetadata(nullptr, from) {}
  CommandPartitionedTopicMetadata(CommandPartitionedTopicMetadata&& from) noexcept
    : CommandPartitionedTopicMetadata() {
    *this = ::std::move(from);
  }

  inline CommandPartitionedTopicMetadata& operator=(const CommandPartitionedTopicMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandPartitionedTopicMetadata& operator=(CommandPartitionedTopicMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandPartitionedTopicMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandPartitionedTopicMetadata* internal_default_instance() {
    return reinterpret_cast<const CommandPartitionedTopicMetadata*>(
               &_CommandPartitionedTopicMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CommandPartitionedTopicMetadata& a, CommandPartitionedTopicMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandPartitionedTopicMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandPartitionedTopicMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandPartitionedTopicMetadata* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandPartitionedTopicMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandPartitionedTopicMetadata& from);
  void MergeFrom(const CommandPartitionedTopicMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandPartitionedTopicMetadata* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandPartitionedTopicMetadata";
  }
  protected:
  explicit CommandPartitionedTopicMetadata(::google::protobuf::Arena* arena);
  CommandPartitionedTopicMetadata(::google::protobuf::Arena* arena, const CommandPartitionedTopicMetadata& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kOriginalPrincipalFieldNumber = 3,
    kOriginalAuthDataFieldNumber = 4,
    kOriginalAuthMethodFieldNumber = 5,
    kRequestIdFieldNumber = 2,
  };
  // required string topic = 1;
  bool has_topic() const;
  void clear_topic() ;
  const std::string& topic() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topic(Arg_&& arg, Args_... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* value);

  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(
      const std::string& value);
  std::string* _internal_mutable_topic();

  public:
  // optional string original_principal = 3;
  bool has_original_principal() const;
  void clear_original_principal() ;
  const std::string& original_principal() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_original_principal(Arg_&& arg, Args_... args);
  std::string* mutable_original_principal();
  PROTOBUF_NODISCARD std::string* release_original_principal();
  void set_allocated_original_principal(std::string* value);

  private:
  const std::string& _internal_original_principal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_principal(
      const std::string& value);
  std::string* _internal_mutable_original_principal();

  public:
  // optional string original_auth_data = 4;
  bool has_original_auth_data() const;
  void clear_original_auth_data() ;
  const std::string& original_auth_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_original_auth_data(Arg_&& arg, Args_... args);
  std::string* mutable_original_auth_data();
  PROTOBUF_NODISCARD std::string* release_original_auth_data();
  void set_allocated_original_auth_data(std::string* value);

  private:
  const std::string& _internal_original_auth_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_auth_data(
      const std::string& value);
  std::string* _internal_mutable_original_auth_data();

  public:
  // optional string original_auth_method = 5;
  bool has_original_auth_method() const;
  void clear_original_auth_method() ;
  const std::string& original_auth_method() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_original_auth_method(Arg_&& arg, Args_... args);
  std::string* mutable_original_auth_method();
  PROTOBUF_NODISCARD std::string* release_original_auth_method();
  void set_allocated_original_auth_method(std::string* value);

  private:
  const std::string& _internal_original_auth_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_auth_method(
      const std::string& value);
  std::string* _internal_mutable_original_auth_method();

  public:
  // required uint64 request_id = 2;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandPartitionedTopicMetadata)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr topic_;
    ::google::protobuf::internal::ArenaStringPtr original_principal_;
    ::google::protobuf::internal::ArenaStringPtr original_auth_data_;
    ::google::protobuf::internal::ArenaStringPtr original_auth_method_;
    ::uint64_t request_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandNewTxnResponse final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandNewTxnResponse) */ {
 public:
  inline CommandNewTxnResponse() : CommandNewTxnResponse(nullptr) {}
  ~CommandNewTxnResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandNewTxnResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommandNewTxnResponse(const CommandNewTxnResponse& from)
      : CommandNewTxnResponse(nullptr, from) {}
  CommandNewTxnResponse(CommandNewTxnResponse&& from) noexcept
    : CommandNewTxnResponse() {
    *this = ::std::move(from);
  }

  inline CommandNewTxnResponse& operator=(const CommandNewTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandNewTxnResponse& operator=(CommandNewTxnResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandNewTxnResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandNewTxnResponse* internal_default_instance() {
    return reinterpret_cast<const CommandNewTxnResponse*>(
               &_CommandNewTxnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(CommandNewTxnResponse& a, CommandNewTxnResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandNewTxnResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandNewTxnResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandNewTxnResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandNewTxnResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandNewTxnResponse& from);
  void MergeFrom(const CommandNewTxnResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandNewTxnResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandNewTxnResponse";
  }
  protected:
  explicit CommandNewTxnResponse(::google::protobuf::Arena* arena);
  CommandNewTxnResponse(::google::protobuf::Arena* arena, const CommandNewTxnResponse& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // optional string message = 5;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  void clear_txnid_least_bits() ;
  ::uint64_t txnid_least_bits() const;
  void set_txnid_least_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::uint64_t value);

  public:
  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  void clear_txnid_most_bits() ;
  ::uint64_t txnid_most_bits() const;
  void set_txnid_most_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::uint64_t value);

  public:
  // optional .pulsar.proto.ServerError error = 4;
  bool has_error() const;
  void clear_error() ;
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);

  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandNewTxnResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint64_t request_id_;
    ::uint64_t txnid_least_bits_;
    ::uint64_t txnid_most_bits_;
    int error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandNewTxn final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandNewTxn) */ {
 public:
  inline CommandNewTxn() : CommandNewTxn(nullptr) {}
  ~CommandNewTxn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandNewTxn(::google::protobuf::internal::ConstantInitialized);

  inline CommandNewTxn(const CommandNewTxn& from)
      : CommandNewTxn(nullptr, from) {}
  CommandNewTxn(CommandNewTxn&& from) noexcept
    : CommandNewTxn() {
    *this = ::std::move(from);
  }

  inline CommandNewTxn& operator=(const CommandNewTxn& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandNewTxn& operator=(CommandNewTxn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandNewTxn& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandNewTxn* internal_default_instance() {
    return reinterpret_cast<const CommandNewTxn*>(
               &_CommandNewTxn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(CommandNewTxn& a, CommandNewTxn& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandNewTxn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandNewTxn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandNewTxn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandNewTxn>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandNewTxn& from);
  void MergeFrom(const CommandNewTxn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandNewTxn* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandNewTxn";
  }
  protected:
  explicit CommandNewTxn(::google::protobuf::Arena* arena);
  CommandNewTxn(::google::protobuf::Arena* arena, const CommandNewTxn& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kTxnTtlSecondsFieldNumber = 2,
    kTcIdFieldNumber = 3,
  };
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional uint64 txn_ttl_seconds = 2 [default = 0];
  bool has_txn_ttl_seconds() const;
  void clear_txn_ttl_seconds() ;
  ::uint64_t txn_ttl_seconds() const;
  void set_txn_ttl_seconds(::uint64_t value);

  private:
  ::uint64_t _internal_txn_ttl_seconds() const;
  void _internal_set_txn_ttl_seconds(::uint64_t value);

  public:
  // optional uint64 tc_id = 3 [default = 0];
  bool has_tc_id() const;
  void clear_tc_id() ;
  ::uint64_t tc_id() const;
  void set_tc_id(::uint64_t value);

  private:
  ::uint64_t _internal_tc_id() const;
  void _internal_set_tc_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandNewTxn)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t request_id_;
    ::uint64_t txn_ttl_seconds_;
    ::uint64_t tc_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandLookupTopicResponse final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandLookupTopicResponse) */ {
 public:
  inline CommandLookupTopicResponse() : CommandLookupTopicResponse(nullptr) {}
  ~CommandLookupTopicResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandLookupTopicResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommandLookupTopicResponse(const CommandLookupTopicResponse& from)
      : CommandLookupTopicResponse(nullptr, from) {}
  CommandLookupTopicResponse(CommandLookupTopicResponse&& from) noexcept
    : CommandLookupTopicResponse() {
    *this = ::std::move(from);
  }

  inline CommandLookupTopicResponse& operator=(const CommandLookupTopicResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandLookupTopicResponse& operator=(CommandLookupTopicResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandLookupTopicResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandLookupTopicResponse* internal_default_instance() {
    return reinterpret_cast<const CommandLookupTopicResponse*>(
               &_CommandLookupTopicResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CommandLookupTopicResponse& a, CommandLookupTopicResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandLookupTopicResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandLookupTopicResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandLookupTopicResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandLookupTopicResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandLookupTopicResponse& from);
  void MergeFrom(const CommandLookupTopicResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandLookupTopicResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandLookupTopicResponse";
  }
  protected:
  explicit CommandLookupTopicResponse(::google::protobuf::Arena* arena);
  CommandLookupTopicResponse(::google::protobuf::Arena* arena, const CommandLookupTopicResponse& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using LookupType = CommandLookupTopicResponse_LookupType;
  static constexpr LookupType Redirect = CommandLookupTopicResponse_LookupType_Redirect;
  static constexpr LookupType Connect = CommandLookupTopicResponse_LookupType_Connect;
  static constexpr LookupType Failed = CommandLookupTopicResponse_LookupType_Failed;
  static inline bool LookupType_IsValid(int value) {
    return CommandLookupTopicResponse_LookupType_IsValid(value);
  }
  static constexpr LookupType LookupType_MIN = CommandLookupTopicResponse_LookupType_LookupType_MIN;
  static constexpr LookupType LookupType_MAX = CommandLookupTopicResponse_LookupType_LookupType_MAX;
  static constexpr int LookupType_ARRAYSIZE = CommandLookupTopicResponse_LookupType_LookupType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& LookupType_Name(T value) {
    return CommandLookupTopicResponse_LookupType_Name(value);
  }
  static inline bool LookupType_Parse(absl::string_view name, LookupType* value) {
    return CommandLookupTopicResponse_LookupType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBrokerServiceUrlFieldNumber = 1,
    kBrokerServiceUrlTlsFieldNumber = 2,
    kMessageFieldNumber = 7,
    kRequestIdFieldNumber = 4,
    kResponseFieldNumber = 3,
    kErrorFieldNumber = 6,
    kAuthoritativeFieldNumber = 5,
    kProxyThroughServiceUrlFieldNumber = 8,
  };
  // optional string brokerServiceUrl = 1;
  bool has_brokerserviceurl() const;
  void clear_brokerserviceurl() ;
  const std::string& brokerserviceurl() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_brokerserviceurl(Arg_&& arg, Args_... args);
  std::string* mutable_brokerserviceurl();
  PROTOBUF_NODISCARD std::string* release_brokerserviceurl();
  void set_allocated_brokerserviceurl(std::string* value);

  private:
  const std::string& _internal_brokerserviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brokerserviceurl(
      const std::string& value);
  std::string* _internal_mutable_brokerserviceurl();

  public:
  // optional string brokerServiceUrlTls = 2;
  bool has_brokerserviceurltls() const;
  void clear_brokerserviceurltls() ;
  const std::string& brokerserviceurltls() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_brokerserviceurltls(Arg_&& arg, Args_... args);
  std::string* mutable_brokerserviceurltls();
  PROTOBUF_NODISCARD std::string* release_brokerserviceurltls();
  void set_allocated_brokerserviceurltls(std::string* value);

  private:
  const std::string& _internal_brokerserviceurltls() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brokerserviceurltls(
      const std::string& value);
  std::string* _internal_mutable_brokerserviceurltls();

  public:
  // optional string message = 7;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // required uint64 request_id = 4;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional .pulsar.proto.CommandLookupTopicResponse.LookupType response = 3;
  bool has_response() const;
  void clear_response() ;
  ::pulsar::proto::CommandLookupTopicResponse_LookupType response() const;
  void set_response(::pulsar::proto::CommandLookupTopicResponse_LookupType value);

  private:
  ::pulsar::proto::CommandLookupTopicResponse_LookupType _internal_response() const;
  void _internal_set_response(::pulsar::proto::CommandLookupTopicResponse_LookupType value);

  public:
  // optional .pulsar.proto.ServerError error = 6;
  bool has_error() const;
  void clear_error() ;
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);

  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);

  public:
  // optional bool authoritative = 5 [default = false];
  bool has_authoritative() const;
  void clear_authoritative() ;
  bool authoritative() const;
  void set_authoritative(bool value);

  private:
  bool _internal_authoritative() const;
  void _internal_set_authoritative(bool value);

  public:
  // optional bool proxy_through_service_url = 8 [default = false];
  bool has_proxy_through_service_url() const;
  void clear_proxy_through_service_url() ;
  bool proxy_through_service_url() const;
  void set_proxy_through_service_url(bool value);

  private:
  bool _internal_proxy_through_service_url() const;
  void _internal_set_proxy_through_service_url(bool value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandLookupTopicResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr brokerserviceurl_;
    ::google::protobuf::internal::ArenaStringPtr brokerserviceurltls_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint64_t request_id_;
    int response_;
    int error_;
    bool authoritative_;
    bool proxy_through_service_url_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandLookupTopic final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandLookupTopic) */ {
 public:
  inline CommandLookupTopic() : CommandLookupTopic(nullptr) {}
  ~CommandLookupTopic() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandLookupTopic(::google::protobuf::internal::ConstantInitialized);

  inline CommandLookupTopic(const CommandLookupTopic& from)
      : CommandLookupTopic(nullptr, from) {}
  CommandLookupTopic(CommandLookupTopic&& from) noexcept
    : CommandLookupTopic() {
    *this = ::std::move(from);
  }

  inline CommandLookupTopic& operator=(const CommandLookupTopic& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandLookupTopic& operator=(CommandLookupTopic&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandLookupTopic& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandLookupTopic* internal_default_instance() {
    return reinterpret_cast<const CommandLookupTopic*>(
               &_CommandLookupTopic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CommandLookupTopic& a, CommandLookupTopic& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandLookupTopic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandLookupTopic* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandLookupTopic* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandLookupTopic>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandLookupTopic& from);
  void MergeFrom(const CommandLookupTopic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandLookupTopic* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandLookupTopic";
  }
  protected:
  explicit CommandLookupTopic(::google::protobuf::Arena* arena);
  CommandLookupTopic(::google::protobuf::Arena* arena, const CommandLookupTopic& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kOriginalPrincipalFieldNumber = 4,
    kOriginalAuthDataFieldNumber = 5,
    kOriginalAuthMethodFieldNumber = 6,
    kAdvertisedListenerNameFieldNumber = 7,
    kRequestIdFieldNumber = 2,
    kAuthoritativeFieldNumber = 3,
  };
  // required string topic = 1;
  bool has_topic() const;
  void clear_topic() ;
  const std::string& topic() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topic(Arg_&& arg, Args_... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* value);

  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(
      const std::string& value);
  std::string* _internal_mutable_topic();

  public:
  // optional string original_principal = 4;
  bool has_original_principal() const;
  void clear_original_principal() ;
  const std::string& original_principal() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_original_principal(Arg_&& arg, Args_... args);
  std::string* mutable_original_principal();
  PROTOBUF_NODISCARD std::string* release_original_principal();
  void set_allocated_original_principal(std::string* value);

  private:
  const std::string& _internal_original_principal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_principal(
      const std::string& value);
  std::string* _internal_mutable_original_principal();

  public:
  // optional string original_auth_data = 5;
  bool has_original_auth_data() const;
  void clear_original_auth_data() ;
  const std::string& original_auth_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_original_auth_data(Arg_&& arg, Args_... args);
  std::string* mutable_original_auth_data();
  PROTOBUF_NODISCARD std::string* release_original_auth_data();
  void set_allocated_original_auth_data(std::string* value);

  private:
  const std::string& _internal_original_auth_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_auth_data(
      const std::string& value);
  std::string* _internal_mutable_original_auth_data();

  public:
  // optional string original_auth_method = 6;
  bool has_original_auth_method() const;
  void clear_original_auth_method() ;
  const std::string& original_auth_method() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_original_auth_method(Arg_&& arg, Args_... args);
  std::string* mutable_original_auth_method();
  PROTOBUF_NODISCARD std::string* release_original_auth_method();
  void set_allocated_original_auth_method(std::string* value);

  private:
  const std::string& _internal_original_auth_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_auth_method(
      const std::string& value);
  std::string* _internal_mutable_original_auth_method();

  public:
  // optional string advertised_listener_name = 7;
  bool has_advertised_listener_name() const;
  void clear_advertised_listener_name() ;
  const std::string& advertised_listener_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_advertised_listener_name(Arg_&& arg, Args_... args);
  std::string* mutable_advertised_listener_name();
  PROTOBUF_NODISCARD std::string* release_advertised_listener_name();
  void set_allocated_advertised_listener_name(std::string* value);

  private:
  const std::string& _internal_advertised_listener_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_advertised_listener_name(
      const std::string& value);
  std::string* _internal_mutable_advertised_listener_name();

  public:
  // required uint64 request_id = 2;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional bool authoritative = 3 [default = false];
  bool has_authoritative() const;
  void clear_authoritative() ;
  bool authoritative() const;
  void set_authoritative(bool value);

  private:
  bool _internal_authoritative() const;
  void _internal_set_authoritative(bool value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandLookupTopic)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr topic_;
    ::google::protobuf::internal::ArenaStringPtr original_principal_;
    ::google::protobuf::internal::ArenaStringPtr original_auth_data_;
    ::google::protobuf::internal::ArenaStringPtr original_auth_method_;
    ::google::protobuf::internal::ArenaStringPtr advertised_listener_name_;
    ::uint64_t request_id_;
    bool authoritative_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandGetTopicsOfNamespaceResponse final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandGetTopicsOfNamespaceResponse) */ {
 public:
  inline CommandGetTopicsOfNamespaceResponse() : CommandGetTopicsOfNamespaceResponse(nullptr) {}
  ~CommandGetTopicsOfNamespaceResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetTopicsOfNamespaceResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommandGetTopicsOfNamespaceResponse(const CommandGetTopicsOfNamespaceResponse& from)
      : CommandGetTopicsOfNamespaceResponse(nullptr, from) {}
  CommandGetTopicsOfNamespaceResponse(CommandGetTopicsOfNamespaceResponse&& from) noexcept
    : CommandGetTopicsOfNamespaceResponse() {
    *this = ::std::move(from);
  }

  inline CommandGetTopicsOfNamespaceResponse& operator=(const CommandGetTopicsOfNamespaceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetTopicsOfNamespaceResponse& operator=(CommandGetTopicsOfNamespaceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandGetTopicsOfNamespaceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGetTopicsOfNamespaceResponse* internal_default_instance() {
    return reinterpret_cast<const CommandGetTopicsOfNamespaceResponse*>(
               &_CommandGetTopicsOfNamespaceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(CommandGetTopicsOfNamespaceResponse& a, CommandGetTopicsOfNamespaceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandGetTopicsOfNamespaceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetTopicsOfNamespaceResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetTopicsOfNamespaceResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandGetTopicsOfNamespaceResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandGetTopicsOfNamespaceResponse& from);
  void MergeFrom(const CommandGetTopicsOfNamespaceResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandGetTopicsOfNamespaceResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandGetTopicsOfNamespaceResponse";
  }
  protected:
  explicit CommandGetTopicsOfNamespaceResponse(::google::protobuf::Arena* arena);
  CommandGetTopicsOfNamespaceResponse(::google::protobuf::Arena* arena, const CommandGetTopicsOfNamespaceResponse& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicsFieldNumber = 2,
    kTopicsHashFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kFilteredFieldNumber = 3,
    kChangedFieldNumber = 5,
  };
  // repeated string topics = 2;
  int topics_size() const;
  private:
  int _internal_topics_size() const;

  public:
  void clear_topics() ;
  const std::string& topics(int index) const;
  std::string* mutable_topics(int index);
  void set_topics(int index, const std::string& value);
  void set_topics(int index, std::string&& value);
  void set_topics(int index, const char* value);
  void set_topics(int index, const char* value, std::size_t size);
  void set_topics(int index, absl::string_view value);
  std::string* add_topics();
  void add_topics(const std::string& value);
  void add_topics(std::string&& value);
  void add_topics(const char* value);
  void add_topics(const char* value, std::size_t size);
  void add_topics(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& topics() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_topics();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_topics() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_topics();

  public:
  // optional string topics_hash = 4;
  bool has_topics_hash() const;
  void clear_topics_hash() ;
  const std::string& topics_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topics_hash(Arg_&& arg, Args_... args);
  std::string* mutable_topics_hash();
  PROTOBUF_NODISCARD std::string* release_topics_hash();
  void set_allocated_topics_hash(std::string* value);

  private:
  const std::string& _internal_topics_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topics_hash(
      const std::string& value);
  std::string* _internal_mutable_topics_hash();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional bool filtered = 3 [default = false];
  bool has_filtered() const;
  void clear_filtered() ;
  bool filtered() const;
  void set_filtered(bool value);

  private:
  bool _internal_filtered() const;
  void _internal_set_filtered(bool value);

  public:
  // optional bool changed = 5 [default = true];
  bool has_changed() const;
  void clear_changed() ;
  bool changed() const;
  void set_changed(bool value);

  private:
  bool _internal_changed() const;
  void _internal_set_changed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> topics_;
    ::google::protobuf::internal::ArenaStringPtr topics_hash_;
    ::uint64_t request_id_;
    bool filtered_;
    bool changed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandGetTopicsOfNamespace final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandGetTopicsOfNamespace) */ {
 public:
  inline CommandGetTopicsOfNamespace() : CommandGetTopicsOfNamespace(nullptr) {}
  ~CommandGetTopicsOfNamespace() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetTopicsOfNamespace(::google::protobuf::internal::ConstantInitialized);

  inline CommandGetTopicsOfNamespace(const CommandGetTopicsOfNamespace& from)
      : CommandGetTopicsOfNamespace(nullptr, from) {}
  CommandGetTopicsOfNamespace(CommandGetTopicsOfNamespace&& from) noexcept
    : CommandGetTopicsOfNamespace() {
    *this = ::std::move(from);
  }

  inline CommandGetTopicsOfNamespace& operator=(const CommandGetTopicsOfNamespace& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetTopicsOfNamespace& operator=(CommandGetTopicsOfNamespace&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandGetTopicsOfNamespace& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGetTopicsOfNamespace* internal_default_instance() {
    return reinterpret_cast<const CommandGetTopicsOfNamespace*>(
               &_CommandGetTopicsOfNamespace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(CommandGetTopicsOfNamespace& a, CommandGetTopicsOfNamespace& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandGetTopicsOfNamespace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetTopicsOfNamespace* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetTopicsOfNamespace* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandGetTopicsOfNamespace>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandGetTopicsOfNamespace& from);
  void MergeFrom(const CommandGetTopicsOfNamespace& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandGetTopicsOfNamespace* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandGetTopicsOfNamespace";
  }
  protected:
  explicit CommandGetTopicsOfNamespace(::google::protobuf::Arena* arena);
  CommandGetTopicsOfNamespace(::google::protobuf::Arena* arena, const CommandGetTopicsOfNamespace& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Mode = CommandGetTopicsOfNamespace_Mode;
  static constexpr Mode PERSISTENT = CommandGetTopicsOfNamespace_Mode_PERSISTENT;
  static constexpr Mode NON_PERSISTENT = CommandGetTopicsOfNamespace_Mode_NON_PERSISTENT;
  static constexpr Mode ALL = CommandGetTopicsOfNamespace_Mode_ALL;
  static inline bool Mode_IsValid(int value) {
    return CommandGetTopicsOfNamespace_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN = CommandGetTopicsOfNamespace_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX = CommandGetTopicsOfNamespace_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE = CommandGetTopicsOfNamespace_Mode_Mode_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Mode_Name(T value) {
    return CommandGetTopicsOfNamespace_Mode_Name(value);
  }
  static inline bool Mode_Parse(absl::string_view name, Mode* value) {
    return CommandGetTopicsOfNamespace_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceFieldNumber = 2,
    kTopicsPatternFieldNumber = 4,
    kTopicsHashFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kModeFieldNumber = 3,
  };
  // required string namespace = 2;
  bool has_namespace_() const;
  void clear_namespace_() ;
  const std::string& namespace_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_namespace_(Arg_&& arg, Args_... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* value);

  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(
      const std::string& value);
  std::string* _internal_mutable_namespace_();

  public:
  // optional string topics_pattern = 4;
  bool has_topics_pattern() const;
  void clear_topics_pattern() ;
  const std::string& topics_pattern() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topics_pattern(Arg_&& arg, Args_... args);
  std::string* mutable_topics_pattern();
  PROTOBUF_NODISCARD std::string* release_topics_pattern();
  void set_allocated_topics_pattern(std::string* value);

  private:
  const std::string& _internal_topics_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topics_pattern(
      const std::string& value);
  std::string* _internal_mutable_topics_pattern();

  public:
  // optional string topics_hash = 5;
  bool has_topics_hash() const;
  void clear_topics_hash() ;
  const std::string& topics_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topics_hash(Arg_&& arg, Args_... args);
  std::string* mutable_topics_hash();
  PROTOBUF_NODISCARD std::string* release_topics_hash();
  void set_allocated_topics_hash(std::string* value);

  private:
  const std::string& _internal_topics_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topics_hash(
      const std::string& value);
  std::string* _internal_mutable_topics_hash();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional .pulsar.proto.CommandGetTopicsOfNamespace.Mode mode = 3 [default = PERSISTENT];
  bool has_mode() const;
  void clear_mode() ;
  ::pulsar::proto::CommandGetTopicsOfNamespace_Mode mode() const;
  void set_mode(::pulsar::proto::CommandGetTopicsOfNamespace_Mode value);

  private:
  ::pulsar::proto::CommandGetTopicsOfNamespace_Mode _internal_mode() const;
  void _internal_set_mode(::pulsar::proto::CommandGetTopicsOfNamespace_Mode value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetTopicsOfNamespace)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr namespace__;
    ::google::protobuf::internal::ArenaStringPtr topics_pattern_;
    ::google::protobuf::internal::ArenaStringPtr topics_hash_;
    ::uint64_t request_id_;
    int mode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandGetSchema final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandGetSchema) */ {
 public:
  inline CommandGetSchema() : CommandGetSchema(nullptr) {}
  ~CommandGetSchema() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetSchema(::google::protobuf::internal::ConstantInitialized);

  inline CommandGetSchema(const CommandGetSchema& from)
      : CommandGetSchema(nullptr, from) {}
  CommandGetSchema(CommandGetSchema&& from) noexcept
    : CommandGetSchema() {
    *this = ::std::move(from);
  }

  inline CommandGetSchema& operator=(const CommandGetSchema& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetSchema& operator=(CommandGetSchema&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandGetSchema& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGetSchema* internal_default_instance() {
    return reinterpret_cast<const CommandGetSchema*>(
               &_CommandGetSchema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(CommandGetSchema& a, CommandGetSchema& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandGetSchema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetSchema* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetSchema* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandGetSchema>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandGetSchema& from);
  void MergeFrom(const CommandGetSchema& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandGetSchema* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandGetSchema";
  }
  protected:
  explicit CommandGetSchema(::google::protobuf::Arena* arena);
  CommandGetSchema(::google::protobuf::Arena* arena, const CommandGetSchema& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 2,
    kSchemaVersionFieldNumber = 3,
    kRequestIdFieldNumber = 1,
  };
  // required string topic = 2;
  bool has_topic() const;
  void clear_topic() ;
  const std::string& topic() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topic(Arg_&& arg, Args_... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* value);

  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(
      const std::string& value);
  std::string* _internal_mutable_topic();

  public:
  // optional bytes schema_version = 3;
  bool has_schema_version() const;
  void clear_schema_version() ;
  const std::string& schema_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema_version(Arg_&& arg, Args_... args);
  std::string* mutable_schema_version();
  PROTOBUF_NODISCARD std::string* release_schema_version();
  void set_allocated_schema_version(std::string* value);

  private:
  const std::string& _internal_schema_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_version(
      const std::string& value);
  std::string* _internal_mutable_schema_version();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetSchema)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr topic_;
    ::google::protobuf::internal::ArenaStringPtr schema_version_;
    ::uint64_t request_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandGetOrCreateSchemaResponse final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandGetOrCreateSchemaResponse) */ {
 public:
  inline CommandGetOrCreateSchemaResponse() : CommandGetOrCreateSchemaResponse(nullptr) {}
  ~CommandGetOrCreateSchemaResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetOrCreateSchemaResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommandGetOrCreateSchemaResponse(const CommandGetOrCreateSchemaResponse& from)
      : CommandGetOrCreateSchemaResponse(nullptr, from) {}
  CommandGetOrCreateSchemaResponse(CommandGetOrCreateSchemaResponse&& from) noexcept
    : CommandGetOrCreateSchemaResponse() {
    *this = ::std::move(from);
  }

  inline CommandGetOrCreateSchemaResponse& operator=(const CommandGetOrCreateSchemaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetOrCreateSchemaResponse& operator=(CommandGetOrCreateSchemaResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandGetOrCreateSchemaResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGetOrCreateSchemaResponse* internal_default_instance() {
    return reinterpret_cast<const CommandGetOrCreateSchemaResponse*>(
               &_CommandGetOrCreateSchemaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(CommandGetOrCreateSchemaResponse& a, CommandGetOrCreateSchemaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandGetOrCreateSchemaResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetOrCreateSchemaResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetOrCreateSchemaResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandGetOrCreateSchemaResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandGetOrCreateSchemaResponse& from);
  void MergeFrom(const CommandGetOrCreateSchemaResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandGetOrCreateSchemaResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandGetOrCreateSchemaResponse";
  }
  protected:
  explicit CommandGetOrCreateSchemaResponse(::google::protobuf::Arena* arena);
  CommandGetOrCreateSchemaResponse(::google::protobuf::Arena* arena, const CommandGetOrCreateSchemaResponse& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kSchemaVersionFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // optional string error_message = 3;
  bool has_error_message() const;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // optional bytes schema_version = 4;
  bool has_schema_version() const;
  void clear_schema_version() ;
  const std::string& schema_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema_version(Arg_&& arg, Args_... args);
  std::string* mutable_schema_version();
  PROTOBUF_NODISCARD std::string* release_schema_version();
  void set_allocated_schema_version(std::string* value);

  private:
  const std::string& _internal_schema_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_version(
      const std::string& value);
  std::string* _internal_mutable_schema_version();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional .pulsar.proto.ServerError error_code = 2;
  bool has_error_code() const;
  void clear_error_code() ;
  ::pulsar::proto::ServerError error_code() const;
  void set_error_code(::pulsar::proto::ServerError value);

  private:
  ::pulsar::proto::ServerError _internal_error_code() const;
  void _internal_set_error_code(::pulsar::proto::ServerError value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetOrCreateSchemaResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::google::protobuf::internal::ArenaStringPtr schema_version_;
    ::uint64_t request_id_;
    int error_code_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandGetLastMessageId final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandGetLastMessageId) */ {
 public:
  inline CommandGetLastMessageId() : CommandGetLastMessageId(nullptr) {}
  ~CommandGetLastMessageId() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetLastMessageId(::google::protobuf::internal::ConstantInitialized);

  inline CommandGetLastMessageId(const CommandGetLastMessageId& from)
      : CommandGetLastMessageId(nullptr, from) {}
  CommandGetLastMessageId(CommandGetLastMessageId&& from) noexcept
    : CommandGetLastMessageId() {
    *this = ::std::move(from);
  }

  inline CommandGetLastMessageId& operator=(const CommandGetLastMessageId& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetLastMessageId& operator=(CommandGetLastMessageId&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandGetLastMessageId& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGetLastMessageId* internal_default_instance() {
    return reinterpret_cast<const CommandGetLastMessageId*>(
               &_CommandGetLastMessageId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(CommandGetLastMessageId& a, CommandGetLastMessageId& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandGetLastMessageId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetLastMessageId* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetLastMessageId* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandGetLastMessageId>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandGetLastMessageId& from);
  void MergeFrom(const CommandGetLastMessageId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandGetLastMessageId* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandGetLastMessageId";
  }
  protected:
  explicit CommandGetLastMessageId(::google::protobuf::Arena* arena);
  CommandGetLastMessageId(::google::protobuf::Arena* arena, const CommandGetLastMessageId& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsumerIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
  };
  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  void clear_consumer_id() ;
  ::uint64_t consumer_id() const;
  void set_consumer_id(::uint64_t value);

  private:
  ::uint64_t _internal_consumer_id() const;
  void _internal_set_consumer_id(::uint64_t value);

  public:
  // required uint64 request_id = 2;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetLastMessageId)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t consumer_id_;
    ::uint64_t request_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandFlow final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandFlow) */ {
 public:
  inline CommandFlow() : CommandFlow(nullptr) {}
  ~CommandFlow() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandFlow(::google::protobuf::internal::ConstantInitialized);

  inline CommandFlow(const CommandFlow& from)
      : CommandFlow(nullptr, from) {}
  CommandFlow(CommandFlow&& from) noexcept
    : CommandFlow() {
    *this = ::std::move(from);
  }

  inline CommandFlow& operator=(const CommandFlow& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandFlow& operator=(CommandFlow&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandFlow& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandFlow* internal_default_instance() {
    return reinterpret_cast<const CommandFlow*>(
               &_CommandFlow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CommandFlow& a, CommandFlow& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandFlow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandFlow* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandFlow* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandFlow>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandFlow& from);
  void MergeFrom(const CommandFlow& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandFlow* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandFlow";
  }
  protected:
  explicit CommandFlow(::google::protobuf::Arena* arena);
  CommandFlow(::google::protobuf::Arena* arena, const CommandFlow& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsumerIdFieldNumber = 1,
    kMessagePermitsFieldNumber = 2,
  };
  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  void clear_consumer_id() ;
  ::uint64_t consumer_id() const;
  void set_consumer_id(::uint64_t value);

  private:
  ::uint64_t _internal_consumer_id() const;
  void _internal_set_consumer_id(::uint64_t value);

  public:
  // required uint32 messagePermits = 2;
  bool has_messagepermits() const;
  void clear_messagepermits() ;
  ::uint32_t messagepermits() const;
  void set_messagepermits(::uint32_t value);

  private:
  ::uint32_t _internal_messagepermits() const;
  void _internal_set_messagepermits(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandFlow)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t consumer_id_;
    ::uint32_t messagepermits_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandError final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandError) */ {
 public:
  inline CommandError() : CommandError(nullptr) {}
  ~CommandError() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandError(::google::protobuf::internal::ConstantInitialized);

  inline CommandError(const CommandError& from)
      : CommandError(nullptr, from) {}
  CommandError(CommandError&& from) noexcept
    : CommandError() {
    *this = ::std::move(from);
  }

  inline CommandError& operator=(const CommandError& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandError& operator=(CommandError&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandError& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandError* internal_default_instance() {
    return reinterpret_cast<const CommandError*>(
               &_CommandError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(CommandError& a, CommandError& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandError* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandError* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandError>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandError& from);
  void MergeFrom(const CommandError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandError* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandError";
  }
  protected:
  explicit CommandError(::google::protobuf::Arena* arena);
  CommandError(::google::protobuf::Arena* arena, const CommandError& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kRequestIdFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // required string message = 3;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // required .pulsar.proto.ServerError error = 2;
  bool has_error() const;
  void clear_error() ;
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);

  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandError)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint64_t request_id_;
    int error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandEndTxnResponse final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandEndTxnResponse) */ {
 public:
  inline CommandEndTxnResponse() : CommandEndTxnResponse(nullptr) {}
  ~CommandEndTxnResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandEndTxnResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommandEndTxnResponse(const CommandEndTxnResponse& from)
      : CommandEndTxnResponse(nullptr, from) {}
  CommandEndTxnResponse(CommandEndTxnResponse&& from) noexcept
    : CommandEndTxnResponse() {
    *this = ::std::move(from);
  }

  inline CommandEndTxnResponse& operator=(const CommandEndTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandEndTxnResponse& operator=(CommandEndTxnResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandEndTxnResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandEndTxnResponse* internal_default_instance() {
    return reinterpret_cast<const CommandEndTxnResponse*>(
               &_CommandEndTxnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(CommandEndTxnResponse& a, CommandEndTxnResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandEndTxnResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandEndTxnResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandEndTxnResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandEndTxnResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandEndTxnResponse& from);
  void MergeFrom(const CommandEndTxnResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandEndTxnResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandEndTxnResponse";
  }
  protected:
  explicit CommandEndTxnResponse(::google::protobuf::Arena* arena);
  CommandEndTxnResponse(::google::protobuf::Arena* arena, const CommandEndTxnResponse& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // optional string message = 5;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  void clear_txnid_least_bits() ;
  ::uint64_t txnid_least_bits() const;
  void set_txnid_least_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::uint64_t value);

  public:
  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  void clear_txnid_most_bits() ;
  ::uint64_t txnid_most_bits() const;
  void set_txnid_most_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::uint64_t value);

  public:
  // optional .pulsar.proto.ServerError error = 4;
  bool has_error() const;
  void clear_error() ;
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);

  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandEndTxnResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint64_t request_id_;
    ::uint64_t txnid_least_bits_;
    ::uint64_t txnid_most_bits_;
    int error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandEndTxnOnSubscriptionResponse final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandEndTxnOnSubscriptionResponse) */ {
 public:
  inline CommandEndTxnOnSubscriptionResponse() : CommandEndTxnOnSubscriptionResponse(nullptr) {}
  ~CommandEndTxnOnSubscriptionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandEndTxnOnSubscriptionResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommandEndTxnOnSubscriptionResponse(const CommandEndTxnOnSubscriptionResponse& from)
      : CommandEndTxnOnSubscriptionResponse(nullptr, from) {}
  CommandEndTxnOnSubscriptionResponse(CommandEndTxnOnSubscriptionResponse&& from) noexcept
    : CommandEndTxnOnSubscriptionResponse() {
    *this = ::std::move(from);
  }

  inline CommandEndTxnOnSubscriptionResponse& operator=(const CommandEndTxnOnSubscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandEndTxnOnSubscriptionResponse& operator=(CommandEndTxnOnSubscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandEndTxnOnSubscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandEndTxnOnSubscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const CommandEndTxnOnSubscriptionResponse*>(
               &_CommandEndTxnOnSubscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(CommandEndTxnOnSubscriptionResponse& a, CommandEndTxnOnSubscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandEndTxnOnSubscriptionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandEndTxnOnSubscriptionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandEndTxnOnSubscriptionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandEndTxnOnSubscriptionResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandEndTxnOnSubscriptionResponse& from);
  void MergeFrom(const CommandEndTxnOnSubscriptionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandEndTxnOnSubscriptionResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandEndTxnOnSubscriptionResponse";
  }
  protected:
  explicit CommandEndTxnOnSubscriptionResponse(::google::protobuf::Arena* arena);
  CommandEndTxnOnSubscriptionResponse(::google::protobuf::Arena* arena, const CommandEndTxnOnSubscriptionResponse& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // optional string message = 5;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  void clear_txnid_least_bits() ;
  ::uint64_t txnid_least_bits() const;
  void set_txnid_least_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::uint64_t value);

  public:
  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  void clear_txnid_most_bits() ;
  ::uint64_t txnid_most_bits() const;
  void set_txnid_most_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::uint64_t value);

  public:
  // optional .pulsar.proto.ServerError error = 4;
  bool has_error() const;
  void clear_error() ;
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);

  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint64_t request_id_;
    ::uint64_t txnid_least_bits_;
    ::uint64_t txnid_most_bits_;
    int error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandEndTxnOnPartitionResponse final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandEndTxnOnPartitionResponse) */ {
 public:
  inline CommandEndTxnOnPartitionResponse() : CommandEndTxnOnPartitionResponse(nullptr) {}
  ~CommandEndTxnOnPartitionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandEndTxnOnPartitionResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommandEndTxnOnPartitionResponse(const CommandEndTxnOnPartitionResponse& from)
      : CommandEndTxnOnPartitionResponse(nullptr, from) {}
  CommandEndTxnOnPartitionResponse(CommandEndTxnOnPartitionResponse&& from) noexcept
    : CommandEndTxnOnPartitionResponse() {
    *this = ::std::move(from);
  }

  inline CommandEndTxnOnPartitionResponse& operator=(const CommandEndTxnOnPartitionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandEndTxnOnPartitionResponse& operator=(CommandEndTxnOnPartitionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandEndTxnOnPartitionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandEndTxnOnPartitionResponse* internal_default_instance() {
    return reinterpret_cast<const CommandEndTxnOnPartitionResponse*>(
               &_CommandEndTxnOnPartitionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(CommandEndTxnOnPartitionResponse& a, CommandEndTxnOnPartitionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandEndTxnOnPartitionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandEndTxnOnPartitionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandEndTxnOnPartitionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandEndTxnOnPartitionResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandEndTxnOnPartitionResponse& from);
  void MergeFrom(const CommandEndTxnOnPartitionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandEndTxnOnPartitionResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandEndTxnOnPartitionResponse";
  }
  protected:
  explicit CommandEndTxnOnPartitionResponse(::google::protobuf::Arena* arena);
  CommandEndTxnOnPartitionResponse(::google::protobuf::Arena* arena, const CommandEndTxnOnPartitionResponse& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // optional string message = 5;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  void clear_txnid_least_bits() ;
  ::uint64_t txnid_least_bits() const;
  void set_txnid_least_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::uint64_t value);

  public:
  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  void clear_txnid_most_bits() ;
  ::uint64_t txnid_most_bits() const;
  void set_txnid_most_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::uint64_t value);

  public:
  // optional .pulsar.proto.ServerError error = 4;
  bool has_error() const;
  void clear_error() ;
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);

  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandEndTxnOnPartitionResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint64_t request_id_;
    ::uint64_t txnid_least_bits_;
    ::uint64_t txnid_most_bits_;
    int error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandEndTxnOnPartition final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandEndTxnOnPartition) */ {
 public:
  inline CommandEndTxnOnPartition() : CommandEndTxnOnPartition(nullptr) {}
  ~CommandEndTxnOnPartition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandEndTxnOnPartition(::google::protobuf::internal::ConstantInitialized);

  inline CommandEndTxnOnPartition(const CommandEndTxnOnPartition& from)
      : CommandEndTxnOnPartition(nullptr, from) {}
  CommandEndTxnOnPartition(CommandEndTxnOnPartition&& from) noexcept
    : CommandEndTxnOnPartition() {
    *this = ::std::move(from);
  }

  inline CommandEndTxnOnPartition& operator=(const CommandEndTxnOnPartition& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandEndTxnOnPartition& operator=(CommandEndTxnOnPartition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandEndTxnOnPartition& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandEndTxnOnPartition* internal_default_instance() {
    return reinterpret_cast<const CommandEndTxnOnPartition*>(
               &_CommandEndTxnOnPartition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(CommandEndTxnOnPartition& a, CommandEndTxnOnPartition& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandEndTxnOnPartition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandEndTxnOnPartition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandEndTxnOnPartition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandEndTxnOnPartition>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandEndTxnOnPartition& from);
  void MergeFrom(const CommandEndTxnOnPartition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandEndTxnOnPartition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandEndTxnOnPartition";
  }
  protected:
  explicit CommandEndTxnOnPartition(::google::protobuf::Arena* arena);
  CommandEndTxnOnPartition(::google::protobuf::Arena* arena, const CommandEndTxnOnPartition& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kTxnidLeastBitsOfLowWatermarkFieldNumber = 6,
    kTxnActionFieldNumber = 5,
  };
  // optional string topic = 4;
  bool has_topic() const;
  void clear_topic() ;
  const std::string& topic() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topic(Arg_&& arg, Args_... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* value);

  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(
      const std::string& value);
  std::string* _internal_mutable_topic();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  void clear_txnid_least_bits() ;
  ::uint64_t txnid_least_bits() const;
  void set_txnid_least_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::uint64_t value);

  public:
  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  void clear_txnid_most_bits() ;
  ::uint64_t txnid_most_bits() const;
  void set_txnid_most_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::uint64_t value);

  public:
  // optional uint64 txnid_least_bits_of_low_watermark = 6;
  bool has_txnid_least_bits_of_low_watermark() const;
  void clear_txnid_least_bits_of_low_watermark() ;
  ::uint64_t txnid_least_bits_of_low_watermark() const;
  void set_txnid_least_bits_of_low_watermark(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_least_bits_of_low_watermark() const;
  void _internal_set_txnid_least_bits_of_low_watermark(::uint64_t value);

  public:
  // optional .pulsar.proto.TxnAction txn_action = 5;
  bool has_txn_action() const;
  void clear_txn_action() ;
  ::pulsar::proto::TxnAction txn_action() const;
  void set_txn_action(::pulsar::proto::TxnAction value);

  private:
  ::pulsar::proto::TxnAction _internal_txn_action() const;
  void _internal_set_txn_action(::pulsar::proto::TxnAction value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandEndTxnOnPartition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr topic_;
    ::uint64_t request_id_;
    ::uint64_t txnid_least_bits_;
    ::uint64_t txnid_most_bits_;
    ::uint64_t txnid_least_bits_of_low_watermark_;
    int txn_action_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandEndTxn final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandEndTxn) */ {
 public:
  inline CommandEndTxn() : CommandEndTxn(nullptr) {}
  ~CommandEndTxn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandEndTxn(::google::protobuf::internal::ConstantInitialized);

  inline CommandEndTxn(const CommandEndTxn& from)
      : CommandEndTxn(nullptr, from) {}
  CommandEndTxn(CommandEndTxn&& from) noexcept
    : CommandEndTxn() {
    *this = ::std::move(from);
  }

  inline CommandEndTxn& operator=(const CommandEndTxn& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandEndTxn& operator=(CommandEndTxn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandEndTxn& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandEndTxn* internal_default_instance() {
    return reinterpret_cast<const CommandEndTxn*>(
               &_CommandEndTxn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(CommandEndTxn& a, CommandEndTxn& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandEndTxn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandEndTxn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandEndTxn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandEndTxn>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandEndTxn& from);
  void MergeFrom(const CommandEndTxn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandEndTxn* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandEndTxn";
  }
  protected:
  explicit CommandEndTxn(::google::protobuf::Arena* arena);
  CommandEndTxn(::google::protobuf::Arena* arena, const CommandEndTxn& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kTxnActionFieldNumber = 4,
  };
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  void clear_txnid_least_bits() ;
  ::uint64_t txnid_least_bits() const;
  void set_txnid_least_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::uint64_t value);

  public:
  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  void clear_txnid_most_bits() ;
  ::uint64_t txnid_most_bits() const;
  void set_txnid_most_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::uint64_t value);

  public:
  // optional .pulsar.proto.TxnAction txn_action = 4;
  bool has_txn_action() const;
  void clear_txn_action() ;
  ::pulsar::proto::TxnAction txn_action() const;
  void set_txn_action(::pulsar::proto::TxnAction value);

  private:
  ::pulsar::proto::TxnAction _internal_txn_action() const;
  void _internal_set_txn_action(::pulsar::proto::TxnAction value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandEndTxn)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t request_id_;
    ::uint64_t txnid_least_bits_;
    ::uint64_t txnid_most_bits_;
    int txn_action_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandConsumerStatsResponse final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandConsumerStatsResponse) */ {
 public:
  inline CommandConsumerStatsResponse() : CommandConsumerStatsResponse(nullptr) {}
  ~CommandConsumerStatsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandConsumerStatsResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommandConsumerStatsResponse(const CommandConsumerStatsResponse& from)
      : CommandConsumerStatsResponse(nullptr, from) {}
  CommandConsumerStatsResponse(CommandConsumerStatsResponse&& from) noexcept
    : CommandConsumerStatsResponse() {
    *this = ::std::move(from);
  }

  inline CommandConsumerStatsResponse& operator=(const CommandConsumerStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandConsumerStatsResponse& operator=(CommandConsumerStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandConsumerStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandConsumerStatsResponse* internal_default_instance() {
    return reinterpret_cast<const CommandConsumerStatsResponse*>(
               &_CommandConsumerStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(CommandConsumerStatsResponse& a, CommandConsumerStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandConsumerStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandConsumerStatsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandConsumerStatsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandConsumerStatsResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandConsumerStatsResponse& from);
  void MergeFrom(const CommandConsumerStatsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandConsumerStatsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandConsumerStatsResponse";
  }
  protected:
  explicit CommandConsumerStatsResponse(::google::protobuf::Arena* arena);
  CommandConsumerStatsResponse(::google::protobuf::Arena* arena, const CommandConsumerStatsResponse& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kConsumerNameFieldNumber = 7,
    kAddressFieldNumber = 11,
    kConnectedSinceFieldNumber = 12,
    kTypeFieldNumber = 13,
    kRequestIdFieldNumber = 1,
    kMsgRateOutFieldNumber = 4,
    kMsgThroughputOutFieldNumber = 5,
    kMsgRateRedeliverFieldNumber = 6,
    kErrorCodeFieldNumber = 2,
    kBlockedConsumerOnUnackedMsgsFieldNumber = 10,
    kAvailablePermitsFieldNumber = 8,
    kUnackedMessagesFieldNumber = 9,
    kMsgRateExpiredFieldNumber = 14,
    kMsgBacklogFieldNumber = 15,
    kMessageAckRateFieldNumber = 16,
  };
  // optional string error_message = 3;
  bool has_error_message() const;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // optional string consumerName = 7;
  bool has_consumername() const;
  void clear_consumername() ;
  const std::string& consumername() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_consumername(Arg_&& arg, Args_... args);
  std::string* mutable_consumername();
  PROTOBUF_NODISCARD std::string* release_consumername();
  void set_allocated_consumername(std::string* value);

  private:
  const std::string& _internal_consumername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_consumername(
      const std::string& value);
  std::string* _internal_mutable_consumername();

  public:
  // optional string address = 11;
  bool has_address() const;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // optional string connectedSince = 12;
  bool has_connectedsince() const;
  void clear_connectedsince() ;
  const std::string& connectedsince() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_connectedsince(Arg_&& arg, Args_... args);
  std::string* mutable_connectedsince();
  PROTOBUF_NODISCARD std::string* release_connectedsince();
  void set_allocated_connectedsince(std::string* value);

  private:
  const std::string& _internal_connectedsince() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectedsince(
      const std::string& value);
  std::string* _internal_mutable_connectedsince();

  public:
  // optional string type = 13;
  bool has_type() const;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional double msgRateOut = 4;
  bool has_msgrateout() const;
  void clear_msgrateout() ;
  double msgrateout() const;
  void set_msgrateout(double value);

  private:
  double _internal_msgrateout() const;
  void _internal_set_msgrateout(double value);

  public:
  // optional double msgThroughputOut = 5;
  bool has_msgthroughputout() const;
  void clear_msgthroughputout() ;
  double msgthroughputout() const;
  void set_msgthroughputout(double value);

  private:
  double _internal_msgthroughputout() const;
  void _internal_set_msgthroughputout(double value);

  public:
  // optional double msgRateRedeliver = 6;
  bool has_msgrateredeliver() const;
  void clear_msgrateredeliver() ;
  double msgrateredeliver() const;
  void set_msgrateredeliver(double value);

  private:
  double _internal_msgrateredeliver() const;
  void _internal_set_msgrateredeliver(double value);

  public:
  // optional .pulsar.proto.ServerError error_code = 2;
  bool has_error_code() const;
  void clear_error_code() ;
  ::pulsar::proto::ServerError error_code() const;
  void set_error_code(::pulsar::proto::ServerError value);

  private:
  ::pulsar::proto::ServerError _internal_error_code() const;
  void _internal_set_error_code(::pulsar::proto::ServerError value);

  public:
  // optional bool blockedConsumerOnUnackedMsgs = 10;
  bool has_blockedconsumeronunackedmsgs() const;
  void clear_blockedconsumeronunackedmsgs() ;
  bool blockedconsumeronunackedmsgs() const;
  void set_blockedconsumeronunackedmsgs(bool value);

  private:
  bool _internal_blockedconsumeronunackedmsgs() const;
  void _internal_set_blockedconsumeronunackedmsgs(bool value);

  public:
  // optional uint64 availablePermits = 8;
  bool has_availablepermits() const;
  void clear_availablepermits() ;
  ::uint64_t availablepermits() const;
  void set_availablepermits(::uint64_t value);

  private:
  ::uint64_t _internal_availablepermits() const;
  void _internal_set_availablepermits(::uint64_t value);

  public:
  // optional uint64 unackedMessages = 9;
  bool has_unackedmessages() const;
  void clear_unackedmessages() ;
  ::uint64_t unackedmessages() const;
  void set_unackedmessages(::uint64_t value);

  private:
  ::uint64_t _internal_unackedmessages() const;
  void _internal_set_unackedmessages(::uint64_t value);

  public:
  // optional double msgRateExpired = 14;
  bool has_msgrateexpired() const;
  void clear_msgrateexpired() ;
  double msgrateexpired() const;
  void set_msgrateexpired(double value);

  private:
  double _internal_msgrateexpired() const;
  void _internal_set_msgrateexpired(double value);

  public:
  // optional uint64 msgBacklog = 15;
  bool has_msgbacklog() const;
  void clear_msgbacklog() ;
  ::uint64_t msgbacklog() const;
  void set_msgbacklog(::uint64_t value);

  private:
  ::uint64_t _internal_msgbacklog() const;
  void _internal_set_msgbacklog(::uint64_t value);

  public:
  // optional double messageAckRate = 16;
  bool has_messageackrate() const;
  void clear_messageackrate() ;
  double messageackrate() const;
  void set_messageackrate(double value);

  private:
  double _internal_messageackrate() const;
  void _internal_set_messageackrate(double value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandConsumerStatsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 16, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::google::protobuf::internal::ArenaStringPtr consumername_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::ArenaStringPtr connectedsince_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::uint64_t request_id_;
    double msgrateout_;
    double msgthroughputout_;
    double msgrateredeliver_;
    int error_code_;
    bool blockedconsumeronunackedmsgs_;
    ::uint64_t availablepermits_;
    ::uint64_t unackedmessages_;
    double msgrateexpired_;
    ::uint64_t msgbacklog_;
    double messageackrate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandConsumerStats final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandConsumerStats) */ {
 public:
  inline CommandConsumerStats() : CommandConsumerStats(nullptr) {}
  ~CommandConsumerStats() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandConsumerStats(::google::protobuf::internal::ConstantInitialized);

  inline CommandConsumerStats(const CommandConsumerStats& from)
      : CommandConsumerStats(nullptr, from) {}
  CommandConsumerStats(CommandConsumerStats&& from) noexcept
    : CommandConsumerStats() {
    *this = ::std::move(from);
  }

  inline CommandConsumerStats& operator=(const CommandConsumerStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandConsumerStats& operator=(CommandConsumerStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandConsumerStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandConsumerStats* internal_default_instance() {
    return reinterpret_cast<const CommandConsumerStats*>(
               &_CommandConsumerStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(CommandConsumerStats& a, CommandConsumerStats& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandConsumerStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandConsumerStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandConsumerStats* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandConsumerStats>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandConsumerStats& from);
  void MergeFrom(const CommandConsumerStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandConsumerStats* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandConsumerStats";
  }
  protected:
  explicit CommandConsumerStats(::google::protobuf::Arena* arena);
  CommandConsumerStats(::google::protobuf::Arena* arena, const CommandConsumerStats& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kConsumerIdFieldNumber = 4,
  };
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // required uint64 consumer_id = 4;
  bool has_consumer_id() const;
  void clear_consumer_id() ;
  ::uint64_t consumer_id() const;
  void set_consumer_id(::uint64_t value);

  private:
  ::uint64_t _internal_consumer_id() const;
  void _internal_set_consumer_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandConsumerStats)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t request_id_;
    ::uint64_t consumer_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandCloseProducer final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandCloseProducer) */ {
 public:
  inline CommandCloseProducer() : CommandCloseProducer(nullptr) {}
  ~CommandCloseProducer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandCloseProducer(::google::protobuf::internal::ConstantInitialized);

  inline CommandCloseProducer(const CommandCloseProducer& from)
      : CommandCloseProducer(nullptr, from) {}
  CommandCloseProducer(CommandCloseProducer&& from) noexcept
    : CommandCloseProducer() {
    *this = ::std::move(from);
  }

  inline CommandCloseProducer& operator=(const CommandCloseProducer& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandCloseProducer& operator=(CommandCloseProducer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandCloseProducer& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandCloseProducer* internal_default_instance() {
    return reinterpret_cast<const CommandCloseProducer*>(
               &_CommandCloseProducer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(CommandCloseProducer& a, CommandCloseProducer& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandCloseProducer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandCloseProducer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandCloseProducer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandCloseProducer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandCloseProducer& from);
  void MergeFrom(const CommandCloseProducer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandCloseProducer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandCloseProducer";
  }
  protected:
  explicit CommandCloseProducer(::google::protobuf::Arena* arena);
  CommandCloseProducer(::google::protobuf::Arena* arena, const CommandCloseProducer& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssignedBrokerServiceUrlFieldNumber = 3,
    kAssignedBrokerServiceUrlTlsFieldNumber = 4,
    kProducerIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
  };
  // optional string assignedBrokerServiceUrl = 3;
  bool has_assignedbrokerserviceurl() const;
  void clear_assignedbrokerserviceurl() ;
  const std::string& assignedbrokerserviceurl() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_assignedbrokerserviceurl(Arg_&& arg, Args_... args);
  std::string* mutable_assignedbrokerserviceurl();
  PROTOBUF_NODISCARD std::string* release_assignedbrokerserviceurl();
  void set_allocated_assignedbrokerserviceurl(std::string* value);

  private:
  const std::string& _internal_assignedbrokerserviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assignedbrokerserviceurl(
      const std::string& value);
  std::string* _internal_mutable_assignedbrokerserviceurl();

  public:
  // optional string assignedBrokerServiceUrlTls = 4;
  bool has_assignedbrokerserviceurltls() const;
  void clear_assignedbrokerserviceurltls() ;
  const std::string& assignedbrokerserviceurltls() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_assignedbrokerserviceurltls(Arg_&& arg, Args_... args);
  std::string* mutable_assignedbrokerserviceurltls();
  PROTOBUF_NODISCARD std::string* release_assignedbrokerserviceurltls();
  void set_allocated_assignedbrokerserviceurltls(std::string* value);

  private:
  const std::string& _internal_assignedbrokerserviceurltls() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assignedbrokerserviceurltls(
      const std::string& value);
  std::string* _internal_mutable_assignedbrokerserviceurltls();

  public:
  // required uint64 producer_id = 1;
  bool has_producer_id() const;
  void clear_producer_id() ;
  ::uint64_t producer_id() const;
  void set_producer_id(::uint64_t value);

  private:
  ::uint64_t _internal_producer_id() const;
  void _internal_set_producer_id(::uint64_t value);

  public:
  // required uint64 request_id = 2;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandCloseProducer)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr assignedbrokerserviceurl_;
    ::google::protobuf::internal::ArenaStringPtr assignedbrokerserviceurltls_;
    ::uint64_t producer_id_;
    ::uint64_t request_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandCloseConsumer final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandCloseConsumer) */ {
 public:
  inline CommandCloseConsumer() : CommandCloseConsumer(nullptr) {}
  ~CommandCloseConsumer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandCloseConsumer(::google::protobuf::internal::ConstantInitialized);

  inline CommandCloseConsumer(const CommandCloseConsumer& from)
      : CommandCloseConsumer(nullptr, from) {}
  CommandCloseConsumer(CommandCloseConsumer&& from) noexcept
    : CommandCloseConsumer() {
    *this = ::std::move(from);
  }

  inline CommandCloseConsumer& operator=(const CommandCloseConsumer& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandCloseConsumer& operator=(CommandCloseConsumer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandCloseConsumer& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandCloseConsumer* internal_default_instance() {
    return reinterpret_cast<const CommandCloseConsumer*>(
               &_CommandCloseConsumer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CommandCloseConsumer& a, CommandCloseConsumer& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandCloseConsumer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandCloseConsumer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandCloseConsumer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandCloseConsumer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandCloseConsumer& from);
  void MergeFrom(const CommandCloseConsumer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandCloseConsumer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandCloseConsumer";
  }
  protected:
  explicit CommandCloseConsumer(::google::protobuf::Arena* arena);
  CommandCloseConsumer(::google::protobuf::Arena* arena, const CommandCloseConsumer& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssignedBrokerServiceUrlFieldNumber = 3,
    kAssignedBrokerServiceUrlTlsFieldNumber = 4,
    kConsumerIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
  };
  // optional string assignedBrokerServiceUrl = 3;
  bool has_assignedbrokerserviceurl() const;
  void clear_assignedbrokerserviceurl() ;
  const std::string& assignedbrokerserviceurl() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_assignedbrokerserviceurl(Arg_&& arg, Args_... args);
  std::string* mutable_assignedbrokerserviceurl();
  PROTOBUF_NODISCARD std::string* release_assignedbrokerserviceurl();
  void set_allocated_assignedbrokerserviceurl(std::string* value);

  private:
  const std::string& _internal_assignedbrokerserviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assignedbrokerserviceurl(
      const std::string& value);
  std::string* _internal_mutable_assignedbrokerserviceurl();

  public:
  // optional string assignedBrokerServiceUrlTls = 4;
  bool has_assignedbrokerserviceurltls() const;
  void clear_assignedbrokerserviceurltls() ;
  const std::string& assignedbrokerserviceurltls() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_assignedbrokerserviceurltls(Arg_&& arg, Args_... args);
  std::string* mutable_assignedbrokerserviceurltls();
  PROTOBUF_NODISCARD std::string* release_assignedbrokerserviceurltls();
  void set_allocated_assignedbrokerserviceurltls(std::string* value);

  private:
  const std::string& _internal_assignedbrokerserviceurltls() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assignedbrokerserviceurltls(
      const std::string& value);
  std::string* _internal_mutable_assignedbrokerserviceurltls();

  public:
  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  void clear_consumer_id() ;
  ::uint64_t consumer_id() const;
  void set_consumer_id(::uint64_t value);

  private:
  ::uint64_t _internal_consumer_id() const;
  void _internal_set_consumer_id(::uint64_t value);

  public:
  // required uint64 request_id = 2;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandCloseConsumer)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr assignedbrokerserviceurl_;
    ::google::protobuf::internal::ArenaStringPtr assignedbrokerserviceurltls_;
    ::uint64_t consumer_id_;
    ::uint64_t request_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandAddSubscriptionToTxnResponse final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandAddSubscriptionToTxnResponse) */ {
 public:
  inline CommandAddSubscriptionToTxnResponse() : CommandAddSubscriptionToTxnResponse(nullptr) {}
  ~CommandAddSubscriptionToTxnResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandAddSubscriptionToTxnResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommandAddSubscriptionToTxnResponse(const CommandAddSubscriptionToTxnResponse& from)
      : CommandAddSubscriptionToTxnResponse(nullptr, from) {}
  CommandAddSubscriptionToTxnResponse(CommandAddSubscriptionToTxnResponse&& from) noexcept
    : CommandAddSubscriptionToTxnResponse() {
    *this = ::std::move(from);
  }

  inline CommandAddSubscriptionToTxnResponse& operator=(const CommandAddSubscriptionToTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandAddSubscriptionToTxnResponse& operator=(CommandAddSubscriptionToTxnResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandAddSubscriptionToTxnResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandAddSubscriptionToTxnResponse* internal_default_instance() {
    return reinterpret_cast<const CommandAddSubscriptionToTxnResponse*>(
               &_CommandAddSubscriptionToTxnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(CommandAddSubscriptionToTxnResponse& a, CommandAddSubscriptionToTxnResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandAddSubscriptionToTxnResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandAddSubscriptionToTxnResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandAddSubscriptionToTxnResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandAddSubscriptionToTxnResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandAddSubscriptionToTxnResponse& from);
  void MergeFrom(const CommandAddSubscriptionToTxnResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandAddSubscriptionToTxnResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandAddSubscriptionToTxnResponse";
  }
  protected:
  explicit CommandAddSubscriptionToTxnResponse(::google::protobuf::Arena* arena);
  CommandAddSubscriptionToTxnResponse(::google::protobuf::Arena* arena, const CommandAddSubscriptionToTxnResponse& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // optional string message = 5;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  void clear_txnid_least_bits() ;
  ::uint64_t txnid_least_bits() const;
  void set_txnid_least_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::uint64_t value);

  public:
  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  void clear_txnid_most_bits() ;
  ::uint64_t txnid_most_bits() const;
  void set_txnid_most_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::uint64_t value);

  public:
  // optional .pulsar.proto.ServerError error = 4;
  bool has_error() const;
  void clear_error() ;
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);

  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAddSubscriptionToTxnResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint64_t request_id_;
    ::uint64_t txnid_least_bits_;
    ::uint64_t txnid_most_bits_;
    int error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandAddPartitionToTxnResponse final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandAddPartitionToTxnResponse) */ {
 public:
  inline CommandAddPartitionToTxnResponse() : CommandAddPartitionToTxnResponse(nullptr) {}
  ~CommandAddPartitionToTxnResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandAddPartitionToTxnResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommandAddPartitionToTxnResponse(const CommandAddPartitionToTxnResponse& from)
      : CommandAddPartitionToTxnResponse(nullptr, from) {}
  CommandAddPartitionToTxnResponse(CommandAddPartitionToTxnResponse&& from) noexcept
    : CommandAddPartitionToTxnResponse() {
    *this = ::std::move(from);
  }

  inline CommandAddPartitionToTxnResponse& operator=(const CommandAddPartitionToTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandAddPartitionToTxnResponse& operator=(CommandAddPartitionToTxnResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandAddPartitionToTxnResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandAddPartitionToTxnResponse* internal_default_instance() {
    return reinterpret_cast<const CommandAddPartitionToTxnResponse*>(
               &_CommandAddPartitionToTxnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(CommandAddPartitionToTxnResponse& a, CommandAddPartitionToTxnResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandAddPartitionToTxnResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandAddPartitionToTxnResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandAddPartitionToTxnResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandAddPartitionToTxnResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandAddPartitionToTxnResponse& from);
  void MergeFrom(const CommandAddPartitionToTxnResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandAddPartitionToTxnResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandAddPartitionToTxnResponse";
  }
  protected:
  explicit CommandAddPartitionToTxnResponse(::google::protobuf::Arena* arena);
  CommandAddPartitionToTxnResponse(::google::protobuf::Arena* arena, const CommandAddPartitionToTxnResponse& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 5,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kErrorFieldNumber = 4,
  };
  // optional string message = 5;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  void clear_txnid_least_bits() ;
  ::uint64_t txnid_least_bits() const;
  void set_txnid_least_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::uint64_t value);

  public:
  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  void clear_txnid_most_bits() ;
  ::uint64_t txnid_most_bits() const;
  void set_txnid_most_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::uint64_t value);

  public:
  // optional .pulsar.proto.ServerError error = 4;
  bool has_error() const;
  void clear_error() ;
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);

  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAddPartitionToTxnResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint64_t request_id_;
    ::uint64_t txnid_least_bits_;
    ::uint64_t txnid_most_bits_;
    int error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandAddPartitionToTxn final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandAddPartitionToTxn) */ {
 public:
  inline CommandAddPartitionToTxn() : CommandAddPartitionToTxn(nullptr) {}
  ~CommandAddPartitionToTxn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandAddPartitionToTxn(::google::protobuf::internal::ConstantInitialized);

  inline CommandAddPartitionToTxn(const CommandAddPartitionToTxn& from)
      : CommandAddPartitionToTxn(nullptr, from) {}
  CommandAddPartitionToTxn(CommandAddPartitionToTxn&& from) noexcept
    : CommandAddPartitionToTxn() {
    *this = ::std::move(from);
  }

  inline CommandAddPartitionToTxn& operator=(const CommandAddPartitionToTxn& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandAddPartitionToTxn& operator=(CommandAddPartitionToTxn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandAddPartitionToTxn& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandAddPartitionToTxn* internal_default_instance() {
    return reinterpret_cast<const CommandAddPartitionToTxn*>(
               &_CommandAddPartitionToTxn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(CommandAddPartitionToTxn& a, CommandAddPartitionToTxn& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandAddPartitionToTxn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandAddPartitionToTxn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandAddPartitionToTxn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandAddPartitionToTxn>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandAddPartitionToTxn& from);
  void MergeFrom(const CommandAddPartitionToTxn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandAddPartitionToTxn* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandAddPartitionToTxn";
  }
  protected:
  explicit CommandAddPartitionToTxn(::google::protobuf::Arena* arena);
  CommandAddPartitionToTxn(::google::protobuf::Arena* arena, const CommandAddPartitionToTxn& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionsFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
  };
  // repeated string partitions = 4;
  int partitions_size() const;
  private:
  int _internal_partitions_size() const;

  public:
  void clear_partitions() ;
  const std::string& partitions(int index) const;
  std::string* mutable_partitions(int index);
  void set_partitions(int index, const std::string& value);
  void set_partitions(int index, std::string&& value);
  void set_partitions(int index, const char* value);
  void set_partitions(int index, const char* value, std::size_t size);
  void set_partitions(int index, absl::string_view value);
  std::string* add_partitions();
  void add_partitions(const std::string& value);
  void add_partitions(std::string&& value);
  void add_partitions(const char* value);
  void add_partitions(const char* value, std::size_t size);
  void add_partitions(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& partitions() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_partitions();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_partitions() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_partitions();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  void clear_txnid_least_bits() ;
  ::uint64_t txnid_least_bits() const;
  void set_txnid_least_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::uint64_t value);

  public:
  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  void clear_txnid_most_bits() ;
  ::uint64_t txnid_most_bits() const;
  void set_txnid_most_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAddPartitionToTxn)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> partitions_;
    ::uint64_t request_id_;
    ::uint64_t txnid_least_bits_;
    ::uint64_t txnid_most_bits_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandActiveConsumerChange final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandActiveConsumerChange) */ {
 public:
  inline CommandActiveConsumerChange() : CommandActiveConsumerChange(nullptr) {}
  ~CommandActiveConsumerChange() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandActiveConsumerChange(::google::protobuf::internal::ConstantInitialized);

  inline CommandActiveConsumerChange(const CommandActiveConsumerChange& from)
      : CommandActiveConsumerChange(nullptr, from) {}
  CommandActiveConsumerChange(CommandActiveConsumerChange&& from) noexcept
    : CommandActiveConsumerChange() {
    *this = ::std::move(from);
  }

  inline CommandActiveConsumerChange& operator=(const CommandActiveConsumerChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandActiveConsumerChange& operator=(CommandActiveConsumerChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandActiveConsumerChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandActiveConsumerChange* internal_default_instance() {
    return reinterpret_cast<const CommandActiveConsumerChange*>(
               &_CommandActiveConsumerChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CommandActiveConsumerChange& a, CommandActiveConsumerChange& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandActiveConsumerChange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandActiveConsumerChange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandActiveConsumerChange* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandActiveConsumerChange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandActiveConsumerChange& from);
  void MergeFrom(const CommandActiveConsumerChange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandActiveConsumerChange* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandActiveConsumerChange";
  }
  protected:
  explicit CommandActiveConsumerChange(::google::protobuf::Arena* arena);
  CommandActiveConsumerChange(::google::protobuf::Arena* arena, const CommandActiveConsumerChange& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsumerIdFieldNumber = 1,
    kIsActiveFieldNumber = 2,
  };
  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  void clear_consumer_id() ;
  ::uint64_t consumer_id() const;
  void set_consumer_id(::uint64_t value);

  private:
  ::uint64_t _internal_consumer_id() const;
  void _internal_set_consumer_id(::uint64_t value);

  public:
  // optional bool is_active = 2 [default = false];
  bool has_is_active() const;
  void clear_is_active() ;
  bool is_active() const;
  void set_is_active(bool value);

  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandActiveConsumerChange)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t consumer_id_;
    bool is_active_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandAckResponse final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandAckResponse) */ {
 public:
  inline CommandAckResponse() : CommandAckResponse(nullptr) {}
  ~CommandAckResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandAckResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommandAckResponse(const CommandAckResponse& from)
      : CommandAckResponse(nullptr, from) {}
  CommandAckResponse(CommandAckResponse&& from) noexcept
    : CommandAckResponse() {
    *this = ::std::move(from);
  }

  inline CommandAckResponse& operator=(const CommandAckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandAckResponse& operator=(CommandAckResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandAckResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandAckResponse* internal_default_instance() {
    return reinterpret_cast<const CommandAckResponse*>(
               &_CommandAckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CommandAckResponse& a, CommandAckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandAckResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandAckResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandAckResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandAckResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandAckResponse& from);
  void MergeFrom(const CommandAckResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandAckResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandAckResponse";
  }
  protected:
  explicit CommandAckResponse(::google::protobuf::Arena* arena);
  CommandAckResponse(::google::protobuf::Arena* arena, const CommandAckResponse& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 5,
    kConsumerIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kRequestIdFieldNumber = 6,
    kErrorFieldNumber = 4,
  };
  // optional string message = 5;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  void clear_consumer_id() ;
  ::uint64_t consumer_id() const;
  void set_consumer_id(::uint64_t value);

  private:
  ::uint64_t _internal_consumer_id() const;
  void _internal_set_consumer_id(::uint64_t value);

  public:
  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  void clear_txnid_least_bits() ;
  ::uint64_t txnid_least_bits() const;
  void set_txnid_least_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::uint64_t value);

  public:
  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  void clear_txnid_most_bits() ;
  ::uint64_t txnid_most_bits() const;
  void set_txnid_most_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::uint64_t value);

  public:
  // optional uint64 request_id = 6;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional .pulsar.proto.ServerError error = 4;
  bool has_error() const;
  void clear_error() ;
  ::pulsar::proto::ServerError error() const;
  void set_error(::pulsar::proto::ServerError value);

  private:
  ::pulsar::proto::ServerError _internal_error() const;
  void _internal_set_error(::pulsar::proto::ServerError value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAckResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint64_t consumer_id_;
    ::uint64_t txnid_least_bits_;
    ::uint64_t txnid_most_bits_;
    ::uint64_t request_id_;
    int error_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class BrokerEntryMetadata final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.BrokerEntryMetadata) */ {
 public:
  inline BrokerEntryMetadata() : BrokerEntryMetadata(nullptr) {}
  ~BrokerEntryMetadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BrokerEntryMetadata(::google::protobuf::internal::ConstantInitialized);

  inline BrokerEntryMetadata(const BrokerEntryMetadata& from)
      : BrokerEntryMetadata(nullptr, from) {}
  BrokerEntryMetadata(BrokerEntryMetadata&& from) noexcept
    : BrokerEntryMetadata() {
    *this = ::std::move(from);
  }

  inline BrokerEntryMetadata& operator=(const BrokerEntryMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrokerEntryMetadata& operator=(BrokerEntryMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BrokerEntryMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const BrokerEntryMetadata* internal_default_instance() {
    return reinterpret_cast<const BrokerEntryMetadata*>(
               &_BrokerEntryMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BrokerEntryMetadata& a, BrokerEntryMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(BrokerEntryMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrokerEntryMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BrokerEntryMetadata* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BrokerEntryMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const BrokerEntryMetadata& from);
  void MergeFrom(const BrokerEntryMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BrokerEntryMetadata* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.BrokerEntryMetadata";
  }
  protected:
  explicit BrokerEntryMetadata(::google::protobuf::Arena* arena);
  BrokerEntryMetadata(::google::protobuf::Arena* arena, const BrokerEntryMetadata& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBrokerTimestampFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // optional uint64 broker_timestamp = 1;
  bool has_broker_timestamp() const;
  void clear_broker_timestamp() ;
  ::uint64_t broker_timestamp() const;
  void set_broker_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_broker_timestamp() const;
  void _internal_set_broker_timestamp(::uint64_t value);

  public:
  // optional uint64 index = 2;
  bool has_index() const;
  void clear_index() ;
  ::uint64_t index() const;
  void set_index(::uint64_t value);

  private:
  ::uint64_t _internal_index() const;
  void _internal_set_index(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.BrokerEntryMetadata)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t broker_timestamp_;
    ::uint64_t index_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class AuthData final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.AuthData) */ {
 public:
  inline AuthData() : AuthData(nullptr) {}
  ~AuthData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AuthData(::google::protobuf::internal::ConstantInitialized);

  inline AuthData(const AuthData& from)
      : AuthData(nullptr, from) {}
  AuthData(AuthData&& from) noexcept
    : AuthData() {
    *this = ::std::move(from);
  }

  inline AuthData& operator=(const AuthData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthData& operator=(AuthData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AuthData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthData* internal_default_instance() {
    return reinterpret_cast<const AuthData*>(
               &_AuthData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AuthData& a, AuthData& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const AuthData& from);
  void MergeFrom(const AuthData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AuthData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.AuthData";
  }
  protected:
  explicit AuthData(::google::protobuf::Arena* arena);
  AuthData(::google::protobuf::Arena* arena, const AuthData& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthMethodNameFieldNumber = 1,
    kAuthDataFieldNumber = 2,
  };
  // optional string auth_method_name = 1;
  bool has_auth_method_name() const;
  void clear_auth_method_name() ;
  const std::string& auth_method_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_auth_method_name(Arg_&& arg, Args_... args);
  std::string* mutable_auth_method_name();
  PROTOBUF_NODISCARD std::string* release_auth_method_name();
  void set_allocated_auth_method_name(std::string* value);

  private:
  const std::string& _internal_auth_method_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_method_name(
      const std::string& value);
  std::string* _internal_mutable_auth_method_name();

  public:
  // optional bytes auth_data = 2;
  bool has_auth_data() const;
  void clear_auth_data() ;
  const std::string& auth_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_auth_data(Arg_&& arg, Args_... args);
  std::string* mutable_auth_data();
  PROTOBUF_NODISCARD std::string* release_auth_data();
  void set_allocated_auth_data(std::string* value);

  private:
  const std::string& _internal_auth_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_data(
      const std::string& value);
  std::string* _internal_mutable_auth_data();

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.AuthData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr auth_method_name_;
    ::google::protobuf::internal::ArenaStringPtr auth_data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class SingleMessageMetadata final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.SingleMessageMetadata) */ {
 public:
  inline SingleMessageMetadata() : SingleMessageMetadata(nullptr) {}
  ~SingleMessageMetadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SingleMessageMetadata(::google::protobuf::internal::ConstantInitialized);

  inline SingleMessageMetadata(const SingleMessageMetadata& from)
      : SingleMessageMetadata(nullptr, from) {}
  SingleMessageMetadata(SingleMessageMetadata&& from) noexcept
    : SingleMessageMetadata() {
    *this = ::std::move(from);
  }

  inline SingleMessageMetadata& operator=(const SingleMessageMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleMessageMetadata& operator=(SingleMessageMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SingleMessageMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleMessageMetadata* internal_default_instance() {
    return reinterpret_cast<const SingleMessageMetadata*>(
               &_SingleMessageMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SingleMessageMetadata& a, SingleMessageMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleMessageMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleMessageMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SingleMessageMetadata* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SingleMessageMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const SingleMessageMetadata& from);
  void MergeFrom(const SingleMessageMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SingleMessageMetadata* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.SingleMessageMetadata";
  }
  protected:
  explicit SingleMessageMetadata(::google::protobuf::Arena* arena);
  SingleMessageMetadata(::google::protobuf::Arena* arena, const SingleMessageMetadata& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 1,
    kPartitionKeyFieldNumber = 2,
    kOrderingKeyFieldNumber = 7,
    kEventTimeFieldNumber = 5,
    kPayloadSizeFieldNumber = 3,
    kCompactedOutFieldNumber = 4,
    kPartitionKeyB64EncodedFieldNumber = 6,
    kNullValueFieldNumber = 9,
    kNullPartitionKeyFieldNumber = 10,
    kSequenceIdFieldNumber = 8,
  };
  // repeated .pulsar.proto.KeyValue properties = 1;
  int properties_size() const;
  private:
  int _internal_properties_size() const;

  public:
  void clear_properties() ;
  ::pulsar::proto::KeyValue* mutable_properties(int index);
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_properties();
  private:
  const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>& _internal_properties() const;
  ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>* _internal_mutable_properties();
  public:
  const ::pulsar::proto::KeyValue& properties(int index) const;
  ::pulsar::proto::KeyValue* add_properties();
  const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      properties() const;
  // optional string partition_key = 2;
  bool has_partition_key() const;
  void clear_partition_key() ;
  const std::string& partition_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_partition_key(Arg_&& arg, Args_... args);
  std::string* mutable_partition_key();
  PROTOBUF_NODISCARD std::string* release_partition_key();
  void set_allocated_partition_key(std::string* value);

  private:
  const std::string& _internal_partition_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition_key(
      const std::string& value);
  std::string* _internal_mutable_partition_key();

  public:
  // optional bytes ordering_key = 7;
  bool has_ordering_key() const;
  void clear_ordering_key() ;
  const std::string& ordering_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ordering_key(Arg_&& arg, Args_... args);
  std::string* mutable_ordering_key();
  PROTOBUF_NODISCARD std::string* release_ordering_key();
  void set_allocated_ordering_key(std::string* value);

  private:
  const std::string& _internal_ordering_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ordering_key(
      const std::string& value);
  std::string* _internal_mutable_ordering_key();

  public:
  // optional uint64 event_time = 5 [default = 0];
  bool has_event_time() const;
  void clear_event_time() ;
  ::uint64_t event_time() const;
  void set_event_time(::uint64_t value);

  private:
  ::uint64_t _internal_event_time() const;
  void _internal_set_event_time(::uint64_t value);

  public:
  // required int32 payload_size = 3;
  bool has_payload_size() const;
  void clear_payload_size() ;
  ::int32_t payload_size() const;
  void set_payload_size(::int32_t value);

  private:
  ::int32_t _internal_payload_size() const;
  void _internal_set_payload_size(::int32_t value);

  public:
  // optional bool compacted_out = 4 [default = false];
  bool has_compacted_out() const;
  void clear_compacted_out() ;
  bool compacted_out() const;
  void set_compacted_out(bool value);

  private:
  bool _internal_compacted_out() const;
  void _internal_set_compacted_out(bool value);

  public:
  // optional bool partition_key_b64_encoded = 6 [default = false];
  bool has_partition_key_b64_encoded() const;
  void clear_partition_key_b64_encoded() ;
  bool partition_key_b64_encoded() const;
  void set_partition_key_b64_encoded(bool value);

  private:
  bool _internal_partition_key_b64_encoded() const;
  void _internal_set_partition_key_b64_encoded(bool value);

  public:
  // optional bool null_value = 9 [default = false];
  bool has_null_value() const;
  void clear_null_value() ;
  bool null_value() const;
  void set_null_value(bool value);

  private:
  bool _internal_null_value() const;
  void _internal_set_null_value(bool value);

  public:
  // optional bool null_partition_key = 10 [default = false];
  bool has_null_partition_key() const;
  void clear_null_partition_key() ;
  bool null_partition_key() const;
  void set_null_partition_key(bool value);

  private:
  bool _internal_null_partition_key() const;
  void _internal_set_null_partition_key(bool value);

  public:
  // optional uint64 sequence_id = 8;
  bool has_sequence_id() const;
  void clear_sequence_id() ;
  ::uint64_t sequence_id() const;
  void set_sequence_id(::uint64_t value);

  private:
  ::uint64_t _internal_sequence_id() const;
  void _internal_set_sequence_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.SingleMessageMetadata)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue > properties_;
    ::google::protobuf::internal::ArenaStringPtr partition_key_;
    ::google::protobuf::internal::ArenaStringPtr ordering_key_;
    ::uint64_t event_time_;
    ::int32_t payload_size_;
    bool compacted_out_;
    bool partition_key_b64_encoded_;
    bool null_value_;
    bool null_partition_key_;
    ::uint64_t sequence_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class Schema final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.Schema) */ {
 public:
  inline Schema() : Schema(nullptr) {}
  ~Schema() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Schema(::google::protobuf::internal::ConstantInitialized);

  inline Schema(const Schema& from)
      : Schema(nullptr, from) {}
  Schema(Schema&& from) noexcept
    : Schema() {
    *this = ::std::move(from);
  }

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }
  inline Schema& operator=(Schema&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Schema& default_instance() {
    return *internal_default_instance();
  }
  static inline const Schema* internal_default_instance() {
    return reinterpret_cast<const Schema*>(
               &_Schema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Schema& a, Schema& b) {
    a.Swap(&b);
  }
  inline void Swap(Schema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Schema* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Schema* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Schema>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Schema& from);
  void MergeFrom(const Schema& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Schema* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.Schema";
  }
  protected:
  explicit Schema(::google::protobuf::Arena* arena);
  Schema(::google::protobuf::Arena* arena, const Schema& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Type = Schema_Type;
  static constexpr Type None = Schema_Type_None;
  static constexpr Type String = Schema_Type_String;
  static constexpr Type Json = Schema_Type_Json;
  static constexpr Type Protobuf = Schema_Type_Protobuf;
  static constexpr Type Avro = Schema_Type_Avro;
  static constexpr Type Bool = Schema_Type_Bool;
  static constexpr Type Int8 = Schema_Type_Int8;
  static constexpr Type Int16 = Schema_Type_Int16;
  static constexpr Type Int32 = Schema_Type_Int32;
  static constexpr Type Int64 = Schema_Type_Int64;
  static constexpr Type Float = Schema_Type_Float;
  static constexpr Type Double = Schema_Type_Double;
  static constexpr Type Date = Schema_Type_Date;
  static constexpr Type Time = Schema_Type_Time;
  static constexpr Type Timestamp = Schema_Type_Timestamp;
  static constexpr Type KeyValue = Schema_Type_KeyValue;
  static constexpr Type Instant = Schema_Type_Instant;
  static constexpr Type LocalDate = Schema_Type_LocalDate;
  static constexpr Type LocalTime = Schema_Type_LocalTime;
  static constexpr Type LocalDateTime = Schema_Type_LocalDateTime;
  static constexpr Type ProtobufNative = Schema_Type_ProtobufNative;
  static inline bool Type_IsValid(int value) {
    return Schema_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Schema_Type_Type_MIN;
  static constexpr Type Type_MAX = Schema_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Schema_Type_Type_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Schema_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Schema_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 5,
    kNameFieldNumber = 1,
    kSchemaDataFieldNumber = 3,
    kTypeFieldNumber = 4,
  };
  // repeated .pulsar.proto.KeyValue properties = 5;
  int properties_size() const;
  private:
  int _internal_properties_size() const;

  public:
  void clear_properties() ;
  ::pulsar::proto::KeyValue* mutable_properties(int index);
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_properties();
  private:
  const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>& _internal_properties() const;
  ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>* _internal_mutable_properties();
  public:
  const ::pulsar::proto::KeyValue& properties(int index) const;
  ::pulsar::proto::KeyValue* add_properties();
  const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      properties() const;
  // required string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // required bytes schema_data = 3;
  bool has_schema_data() const;
  void clear_schema_data() ;
  const std::string& schema_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema_data(Arg_&& arg, Args_... args);
  std::string* mutable_schema_data();
  PROTOBUF_NODISCARD std::string* release_schema_data();
  void set_allocated_schema_data(std::string* value);

  private:
  const std::string& _internal_schema_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_data(
      const std::string& value);
  std::string* _internal_mutable_schema_data();

  public:
  // required .pulsar.proto.Schema.Type type = 4;
  bool has_type() const;
  void clear_type() ;
  ::pulsar::proto::Schema_Type type() const;
  void set_type(::pulsar::proto::Schema_Type value);

  private:
  ::pulsar::proto::Schema_Type _internal_type() const;
  void _internal_set_type(::pulsar::proto::Schema_Type value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.Schema)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue > properties_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr schema_data_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class KeySharedMeta final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.KeySharedMeta) */ {
 public:
  inline KeySharedMeta() : KeySharedMeta(nullptr) {}
  ~KeySharedMeta() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR KeySharedMeta(::google::protobuf::internal::ConstantInitialized);

  inline KeySharedMeta(const KeySharedMeta& from)
      : KeySharedMeta(nullptr, from) {}
  KeySharedMeta(KeySharedMeta&& from) noexcept
    : KeySharedMeta() {
    *this = ::std::move(from);
  }

  inline KeySharedMeta& operator=(const KeySharedMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeySharedMeta& operator=(KeySharedMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KeySharedMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeySharedMeta* internal_default_instance() {
    return reinterpret_cast<const KeySharedMeta*>(
               &_KeySharedMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(KeySharedMeta& a, KeySharedMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(KeySharedMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeySharedMeta* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeySharedMeta* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeySharedMeta>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const KeySharedMeta& from);
  void MergeFrom(const KeySharedMeta& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(KeySharedMeta* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.KeySharedMeta";
  }
  protected:
  explicit KeySharedMeta(::google::protobuf::Arena* arena);
  KeySharedMeta(::google::protobuf::Arena* arena, const KeySharedMeta& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashRangesFieldNumber = 3,
    kKeySharedModeFieldNumber = 1,
    kAllowOutOfOrderDeliveryFieldNumber = 4,
  };
  // repeated .pulsar.proto.IntRange hashRanges = 3;
  int hashranges_size() const;
  private:
  int _internal_hashranges_size() const;

  public:
  void clear_hashranges() ;
  ::pulsar::proto::IntRange* mutable_hashranges(int index);
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::IntRange >*
      mutable_hashranges();
  private:
  const ::google::protobuf::RepeatedPtrField<::pulsar::proto::IntRange>& _internal_hashranges() const;
  ::google::protobuf::RepeatedPtrField<::pulsar::proto::IntRange>* _internal_mutable_hashranges();
  public:
  const ::pulsar::proto::IntRange& hashranges(int index) const;
  ::pulsar::proto::IntRange* add_hashranges();
  const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::IntRange >&
      hashranges() const;
  // required .pulsar.proto.KeySharedMode keySharedMode = 1;
  bool has_keysharedmode() const;
  void clear_keysharedmode() ;
  ::pulsar::proto::KeySharedMode keysharedmode() const;
  void set_keysharedmode(::pulsar::proto::KeySharedMode value);

  private:
  ::pulsar::proto::KeySharedMode _internal_keysharedmode() const;
  void _internal_set_keysharedmode(::pulsar::proto::KeySharedMode value);

  public:
  // optional bool allowOutOfOrderDelivery = 4 [default = false];
  bool has_allowoutoforderdelivery() const;
  void clear_allowoutoforderdelivery() ;
  bool allowoutoforderdelivery() const;
  void set_allowoutoforderdelivery(bool value);

  private:
  bool _internal_allowoutoforderdelivery() const;
  void _internal_set_allowoutoforderdelivery(bool value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.KeySharedMeta)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::pulsar::proto::IntRange > hashranges_;
    int keysharedmode_;
    bool allowoutoforderdelivery_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class EncryptionKeys final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.EncryptionKeys) */ {
 public:
  inline EncryptionKeys() : EncryptionKeys(nullptr) {}
  ~EncryptionKeys() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EncryptionKeys(::google::protobuf::internal::ConstantInitialized);

  inline EncryptionKeys(const EncryptionKeys& from)
      : EncryptionKeys(nullptr, from) {}
  EncryptionKeys(EncryptionKeys&& from) noexcept
    : EncryptionKeys() {
    *this = ::std::move(from);
  }

  inline EncryptionKeys& operator=(const EncryptionKeys& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncryptionKeys& operator=(EncryptionKeys&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EncryptionKeys& default_instance() {
    return *internal_default_instance();
  }
  static inline const EncryptionKeys* internal_default_instance() {
    return reinterpret_cast<const EncryptionKeys*>(
               &_EncryptionKeys_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EncryptionKeys& a, EncryptionKeys& b) {
    a.Swap(&b);
  }
  inline void Swap(EncryptionKeys* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncryptionKeys* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncryptionKeys* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EncryptionKeys>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const EncryptionKeys& from);
  void MergeFrom(const EncryptionKeys& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EncryptionKeys* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.EncryptionKeys";
  }
  protected:
  explicit EncryptionKeys(::google::protobuf::Arena* arena);
  EncryptionKeys(::google::protobuf::Arena* arena, const EncryptionKeys& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 3,
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // repeated .pulsar.proto.KeyValue metadata = 3;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  ::pulsar::proto::KeyValue* mutable_metadata(int index);
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_metadata();
  private:
  const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>& _internal_metadata() const;
  ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>* _internal_mutable_metadata();
  public:
  const ::pulsar::proto::KeyValue& metadata(int index) const;
  ::pulsar::proto::KeyValue* add_metadata();
  const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      metadata() const;
  // required string key = 1;
  bool has_key() const;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // required bytes value = 2;
  bool has_value() const;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.EncryptionKeys)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue > metadata_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandSendReceipt final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandSendReceipt) */ {
 public:
  inline CommandSendReceipt() : CommandSendReceipt(nullptr) {}
  ~CommandSendReceipt() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandSendReceipt(::google::protobuf::internal::ConstantInitialized);

  inline CommandSendReceipt(const CommandSendReceipt& from)
      : CommandSendReceipt(nullptr, from) {}
  CommandSendReceipt(CommandSendReceipt&& from) noexcept
    : CommandSendReceipt() {
    *this = ::std::move(from);
  }

  inline CommandSendReceipt& operator=(const CommandSendReceipt& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandSendReceipt& operator=(CommandSendReceipt&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandSendReceipt& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandSendReceipt* internal_default_instance() {
    return reinterpret_cast<const CommandSendReceipt*>(
               &_CommandSendReceipt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CommandSendReceipt& a, CommandSendReceipt& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandSendReceipt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandSendReceipt* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandSendReceipt* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandSendReceipt>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandSendReceipt& from);
  void MergeFrom(const CommandSendReceipt& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandSendReceipt* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandSendReceipt";
  }
  protected:
  explicit CommandSendReceipt(::google::protobuf::Arena* arena);
  CommandSendReceipt(::google::protobuf::Arena* arena, const CommandSendReceipt& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 3,
    kProducerIdFieldNumber = 1,
    kSequenceIdFieldNumber = 2,
    kHighestSequenceIdFieldNumber = 4,
  };
  // optional .pulsar.proto.MessageIdData message_id = 3;
  bool has_message_id() const;
  void clear_message_id() ;
  const ::pulsar::proto::MessageIdData& message_id() const;
  PROTOBUF_NODISCARD ::pulsar::proto::MessageIdData* release_message_id();
  ::pulsar::proto::MessageIdData* mutable_message_id();
  void set_allocated_message_id(::pulsar::proto::MessageIdData* value);
  void unsafe_arena_set_allocated_message_id(::pulsar::proto::MessageIdData* value);
  ::pulsar::proto::MessageIdData* unsafe_arena_release_message_id();

  private:
  const ::pulsar::proto::MessageIdData& _internal_message_id() const;
  ::pulsar::proto::MessageIdData* _internal_mutable_message_id();

  public:
  // required uint64 producer_id = 1;
  bool has_producer_id() const;
  void clear_producer_id() ;
  ::uint64_t producer_id() const;
  void set_producer_id(::uint64_t value);

  private:
  ::uint64_t _internal_producer_id() const;
  void _internal_set_producer_id(::uint64_t value);

  public:
  // required uint64 sequence_id = 2;
  bool has_sequence_id() const;
  void clear_sequence_id() ;
  ::uint64_t sequence_id() const;
  void set_sequence_id(::uint64_t value);

  private:
  ::uint64_t _internal_sequence_id() const;
  void _internal_set_sequence_id(::uint64_t value);

  public:
  // optional uint64 highest_sequence_id = 4 [default = 0];
  bool has_highest_sequence_id() const;
  void clear_highest_sequence_id() ;
  ::uint64_t highest_sequence_id() const;
  void set_highest_sequence_id(::uint64_t value);

  private:
  ::uint64_t _internal_highest_sequence_id() const;
  void _internal_set_highest_sequence_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSendReceipt)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::pulsar::proto::MessageIdData* message_id_;
    ::uint64_t producer_id_;
    ::uint64_t sequence_id_;
    ::uint64_t highest_sequence_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandSend final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandSend) */ {
 public:
  inline CommandSend() : CommandSend(nullptr) {}
  ~CommandSend() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandSend(::google::protobuf::internal::ConstantInitialized);

  inline CommandSend(const CommandSend& from)
      : CommandSend(nullptr, from) {}
  CommandSend(CommandSend&& from) noexcept
    : CommandSend() {
    *this = ::std::move(from);
  }

  inline CommandSend& operator=(const CommandSend& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandSend& operator=(CommandSend&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandSend& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandSend* internal_default_instance() {
    return reinterpret_cast<const CommandSend*>(
               &_CommandSend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CommandSend& a, CommandSend& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandSend* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandSend* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandSend* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandSend>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandSend& from);
  void MergeFrom(const CommandSend& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandSend* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandSend";
  }
  protected:
  explicit CommandSend(::google::protobuf::Arena* arena);
  CommandSend(::google::protobuf::Arena* arena, const CommandSend& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 9,
    kProducerIdFieldNumber = 1,
    kSequenceIdFieldNumber = 2,
    kTxnidLeastBitsFieldNumber = 4,
    kTxnidMostBitsFieldNumber = 5,
    kHighestSequenceIdFieldNumber = 6,
    kIsChunkFieldNumber = 7,
    kMarkerFieldNumber = 8,
    kNumMessagesFieldNumber = 3,
  };
  // optional .pulsar.proto.MessageIdData message_id = 9;
  bool has_message_id() const;
  void clear_message_id() ;
  const ::pulsar::proto::MessageIdData& message_id() const;
  PROTOBUF_NODISCARD ::pulsar::proto::MessageIdData* release_message_id();
  ::pulsar::proto::MessageIdData* mutable_message_id();
  void set_allocated_message_id(::pulsar::proto::MessageIdData* value);
  void unsafe_arena_set_allocated_message_id(::pulsar::proto::MessageIdData* value);
  ::pulsar::proto::MessageIdData* unsafe_arena_release_message_id();

  private:
  const ::pulsar::proto::MessageIdData& _internal_message_id() const;
  ::pulsar::proto::MessageIdData* _internal_mutable_message_id();

  public:
  // required uint64 producer_id = 1;
  bool has_producer_id() const;
  void clear_producer_id() ;
  ::uint64_t producer_id() const;
  void set_producer_id(::uint64_t value);

  private:
  ::uint64_t _internal_producer_id() const;
  void _internal_set_producer_id(::uint64_t value);

  public:
  // required uint64 sequence_id = 2;
  bool has_sequence_id() const;
  void clear_sequence_id() ;
  ::uint64_t sequence_id() const;
  void set_sequence_id(::uint64_t value);

  private:
  ::uint64_t _internal_sequence_id() const;
  void _internal_set_sequence_id(::uint64_t value);

  public:
  // optional uint64 txnid_least_bits = 4 [default = 0];
  bool has_txnid_least_bits() const;
  void clear_txnid_least_bits() ;
  ::uint64_t txnid_least_bits() const;
  void set_txnid_least_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::uint64_t value);

  public:
  // optional uint64 txnid_most_bits = 5 [default = 0];
  bool has_txnid_most_bits() const;
  void clear_txnid_most_bits() ;
  ::uint64_t txnid_most_bits() const;
  void set_txnid_most_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::uint64_t value);

  public:
  // optional uint64 highest_sequence_id = 6 [default = 0];
  bool has_highest_sequence_id() const;
  void clear_highest_sequence_id() ;
  ::uint64_t highest_sequence_id() const;
  void set_highest_sequence_id(::uint64_t value);

  private:
  ::uint64_t _internal_highest_sequence_id() const;
  void _internal_set_highest_sequence_id(::uint64_t value);

  public:
  // optional bool is_chunk = 7 [default = false];
  bool has_is_chunk() const;
  void clear_is_chunk() ;
  bool is_chunk() const;
  void set_is_chunk(bool value);

  private:
  bool _internal_is_chunk() const;
  void _internal_set_is_chunk(bool value);

  public:
  // optional bool marker = 8 [default = false];
  bool has_marker() const;
  void clear_marker() ;
  bool marker() const;
  void set_marker(bool value);

  private:
  bool _internal_marker() const;
  void _internal_set_marker(bool value);

  public:
  // optional int32 num_messages = 3 [default = 1];
  bool has_num_messages() const;
  void clear_num_messages() ;
  ::int32_t num_messages() const;
  void set_num_messages(::int32_t value);

  private:
  ::int32_t _internal_num_messages() const;
  void _internal_set_num_messages(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSend)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::pulsar::proto::MessageIdData* message_id_;
    ::uint64_t producer_id_;
    ::uint64_t sequence_id_;
    ::uint64_t txnid_least_bits_;
    ::uint64_t txnid_most_bits_;
    ::uint64_t highest_sequence_id_;
    bool is_chunk_;
    bool marker_;
    ::int32_t num_messages_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandSeek final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandSeek) */ {
 public:
  inline CommandSeek() : CommandSeek(nullptr) {}
  ~CommandSeek() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandSeek(::google::protobuf::internal::ConstantInitialized);

  inline CommandSeek(const CommandSeek& from)
      : CommandSeek(nullptr, from) {}
  CommandSeek(CommandSeek&& from) noexcept
    : CommandSeek() {
    *this = ::std::move(from);
  }

  inline CommandSeek& operator=(const CommandSeek& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandSeek& operator=(CommandSeek&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandSeek& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandSeek* internal_default_instance() {
    return reinterpret_cast<const CommandSeek*>(
               &_CommandSeek_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CommandSeek& a, CommandSeek& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandSeek* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandSeek* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandSeek* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandSeek>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandSeek& from);
  void MergeFrom(const CommandSeek& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandSeek* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandSeek";
  }
  protected:
  explicit CommandSeek(::google::protobuf::Arena* arena);
  CommandSeek(::google::protobuf::Arena* arena, const CommandSeek& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 3,
    kConsumerIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
    kMessagePublishTimeFieldNumber = 4,
  };
  // optional .pulsar.proto.MessageIdData message_id = 3;
  bool has_message_id() const;
  void clear_message_id() ;
  const ::pulsar::proto::MessageIdData& message_id() const;
  PROTOBUF_NODISCARD ::pulsar::proto::MessageIdData* release_message_id();
  ::pulsar::proto::MessageIdData* mutable_message_id();
  void set_allocated_message_id(::pulsar::proto::MessageIdData* value);
  void unsafe_arena_set_allocated_message_id(::pulsar::proto::MessageIdData* value);
  ::pulsar::proto::MessageIdData* unsafe_arena_release_message_id();

  private:
  const ::pulsar::proto::MessageIdData& _internal_message_id() const;
  ::pulsar::proto::MessageIdData* _internal_mutable_message_id();

  public:
  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  void clear_consumer_id() ;
  ::uint64_t consumer_id() const;
  void set_consumer_id(::uint64_t value);

  private:
  ::uint64_t _internal_consumer_id() const;
  void _internal_set_consumer_id(::uint64_t value);

  public:
  // required uint64 request_id = 2;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional uint64 message_publish_time = 4;
  bool has_message_publish_time() const;
  void clear_message_publish_time() ;
  ::uint64_t message_publish_time() const;
  void set_message_publish_time(::uint64_t value);

  private:
  ::uint64_t _internal_message_publish_time() const;
  void _internal_set_message_publish_time(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSeek)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::pulsar::proto::MessageIdData* message_id_;
    ::uint64_t consumer_id_;
    ::uint64_t request_id_;
    ::uint64_t message_publish_time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandRedeliverUnacknowledgedMessages final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandRedeliverUnacknowledgedMessages) */ {
 public:
  inline CommandRedeliverUnacknowledgedMessages() : CommandRedeliverUnacknowledgedMessages(nullptr) {}
  ~CommandRedeliverUnacknowledgedMessages() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandRedeliverUnacknowledgedMessages(::google::protobuf::internal::ConstantInitialized);

  inline CommandRedeliverUnacknowledgedMessages(const CommandRedeliverUnacknowledgedMessages& from)
      : CommandRedeliverUnacknowledgedMessages(nullptr, from) {}
  CommandRedeliverUnacknowledgedMessages(CommandRedeliverUnacknowledgedMessages&& from) noexcept
    : CommandRedeliverUnacknowledgedMessages() {
    *this = ::std::move(from);
  }

  inline CommandRedeliverUnacknowledgedMessages& operator=(const CommandRedeliverUnacknowledgedMessages& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandRedeliverUnacknowledgedMessages& operator=(CommandRedeliverUnacknowledgedMessages&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandRedeliverUnacknowledgedMessages& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandRedeliverUnacknowledgedMessages* internal_default_instance() {
    return reinterpret_cast<const CommandRedeliverUnacknowledgedMessages*>(
               &_CommandRedeliverUnacknowledgedMessages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CommandRedeliverUnacknowledgedMessages& a, CommandRedeliverUnacknowledgedMessages& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandRedeliverUnacknowledgedMessages* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandRedeliverUnacknowledgedMessages* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandRedeliverUnacknowledgedMessages* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandRedeliverUnacknowledgedMessages>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandRedeliverUnacknowledgedMessages& from);
  void MergeFrom(const CommandRedeliverUnacknowledgedMessages& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandRedeliverUnacknowledgedMessages* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandRedeliverUnacknowledgedMessages";
  }
  protected:
  explicit CommandRedeliverUnacknowledgedMessages(::google::protobuf::Arena* arena);
  CommandRedeliverUnacknowledgedMessages(::google::protobuf::Arena* arena, const CommandRedeliverUnacknowledgedMessages& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdsFieldNumber = 2,
    kConsumerIdFieldNumber = 1,
    kConsumerEpochFieldNumber = 3,
  };
  // repeated .pulsar.proto.MessageIdData message_ids = 2;
  int message_ids_size() const;
  private:
  int _internal_message_ids_size() const;

  public:
  void clear_message_ids() ;
  ::pulsar::proto::MessageIdData* mutable_message_ids(int index);
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::MessageIdData >*
      mutable_message_ids();
  private:
  const ::google::protobuf::RepeatedPtrField<::pulsar::proto::MessageIdData>& _internal_message_ids() const;
  ::google::protobuf::RepeatedPtrField<::pulsar::proto::MessageIdData>* _internal_mutable_message_ids();
  public:
  const ::pulsar::proto::MessageIdData& message_ids(int index) const;
  ::pulsar::proto::MessageIdData* add_message_ids();
  const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::MessageIdData >&
      message_ids() const;
  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  void clear_consumer_id() ;
  ::uint64_t consumer_id() const;
  void set_consumer_id(::uint64_t value);

  private:
  ::uint64_t _internal_consumer_id() const;
  void _internal_set_consumer_id(::uint64_t value);

  public:
  // optional uint64 consumer_epoch = 3;
  bool has_consumer_epoch() const;
  void clear_consumer_epoch() ;
  ::uint64_t consumer_epoch() const;
  void set_consumer_epoch(::uint64_t value);

  private:
  ::uint64_t _internal_consumer_epoch() const;
  void _internal_set_consumer_epoch(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::pulsar::proto::MessageIdData > message_ids_;
    ::uint64_t consumer_id_;
    ::uint64_t consumer_epoch_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandMessage final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandMessage) */ {
 public:
  inline CommandMessage() : CommandMessage(nullptr) {}
  ~CommandMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandMessage(::google::protobuf::internal::ConstantInitialized);

  inline CommandMessage(const CommandMessage& from)
      : CommandMessage(nullptr, from) {}
  CommandMessage(CommandMessage&& from) noexcept
    : CommandMessage() {
    *this = ::std::move(from);
  }

  inline CommandMessage& operator=(const CommandMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandMessage& operator=(CommandMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandMessage* internal_default_instance() {
    return reinterpret_cast<const CommandMessage*>(
               &_CommandMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CommandMessage& a, CommandMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandMessage& from);
  void MergeFrom(const CommandMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandMessage";
  }
  protected:
  explicit CommandMessage(::google::protobuf::Arena* arena);
  CommandMessage(::google::protobuf::Arena* arena, const CommandMessage& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckSetFieldNumber = 4,
    kMessageIdFieldNumber = 2,
    kConsumerIdFieldNumber = 1,
    kConsumerEpochFieldNumber = 5,
    kRedeliveryCountFieldNumber = 3,
  };
  // repeated int64 ack_set = 4;
  int ack_set_size() const;
  private:
  int _internal_ack_set_size() const;

  public:
  void clear_ack_set() ;
  ::int64_t ack_set(int index) const;
  void set_ack_set(int index, ::int64_t value);
  void add_ack_set(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& ack_set() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_ack_set();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_ack_set() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_ack_set();

  public:
  // required .pulsar.proto.MessageIdData message_id = 2;
  bool has_message_id() const;
  void clear_message_id() ;
  const ::pulsar::proto::MessageIdData& message_id() const;
  PROTOBUF_NODISCARD ::pulsar::proto::MessageIdData* release_message_id();
  ::pulsar::proto::MessageIdData* mutable_message_id();
  void set_allocated_message_id(::pulsar::proto::MessageIdData* value);
  void unsafe_arena_set_allocated_message_id(::pulsar::proto::MessageIdData* value);
  ::pulsar::proto::MessageIdData* unsafe_arena_release_message_id();

  private:
  const ::pulsar::proto::MessageIdData& _internal_message_id() const;
  ::pulsar::proto::MessageIdData* _internal_mutable_message_id();

  public:
  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  void clear_consumer_id() ;
  ::uint64_t consumer_id() const;
  void set_consumer_id(::uint64_t value);

  private:
  ::uint64_t _internal_consumer_id() const;
  void _internal_set_consumer_id(::uint64_t value);

  public:
  // optional uint64 consumer_epoch = 5;
  bool has_consumer_epoch() const;
  void clear_consumer_epoch() ;
  ::uint64_t consumer_epoch() const;
  void set_consumer_epoch(::uint64_t value);

  private:
  ::uint64_t _internal_consumer_epoch() const;
  void _internal_set_consumer_epoch(::uint64_t value);

  public:
  // optional uint32 redelivery_count = 3 [default = 0];
  bool has_redelivery_count() const;
  void clear_redelivery_count() ;
  ::uint32_t redelivery_count() const;
  void set_redelivery_count(::uint32_t value);

  private:
  ::uint32_t _internal_redelivery_count() const;
  void _internal_set_redelivery_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> ack_set_;
    ::pulsar::proto::MessageIdData* message_id_;
    ::uint64_t consumer_id_;
    ::uint64_t consumer_epoch_;
    ::uint32_t redelivery_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandGetLastMessageIdResponse final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandGetLastMessageIdResponse) */ {
 public:
  inline CommandGetLastMessageIdResponse() : CommandGetLastMessageIdResponse(nullptr) {}
  ~CommandGetLastMessageIdResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetLastMessageIdResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommandGetLastMessageIdResponse(const CommandGetLastMessageIdResponse& from)
      : CommandGetLastMessageIdResponse(nullptr, from) {}
  CommandGetLastMessageIdResponse(CommandGetLastMessageIdResponse&& from) noexcept
    : CommandGetLastMessageIdResponse() {
    *this = ::std::move(from);
  }

  inline CommandGetLastMessageIdResponse& operator=(const CommandGetLastMessageIdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetLastMessageIdResponse& operator=(CommandGetLastMessageIdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandGetLastMessageIdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGetLastMessageIdResponse* internal_default_instance() {
    return reinterpret_cast<const CommandGetLastMessageIdResponse*>(
               &_CommandGetLastMessageIdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(CommandGetLastMessageIdResponse& a, CommandGetLastMessageIdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandGetLastMessageIdResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetLastMessageIdResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetLastMessageIdResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandGetLastMessageIdResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandGetLastMessageIdResponse& from);
  void MergeFrom(const CommandGetLastMessageIdResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandGetLastMessageIdResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandGetLastMessageIdResponse";
  }
  protected:
  explicit CommandGetLastMessageIdResponse(::google::protobuf::Arena* arena);
  CommandGetLastMessageIdResponse(::google::protobuf::Arena* arena, const CommandGetLastMessageIdResponse& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastMessageIdFieldNumber = 1,
    kConsumerMarkDeletePositionFieldNumber = 3,
    kRequestIdFieldNumber = 2,
  };
  // required .pulsar.proto.MessageIdData last_message_id = 1;
  bool has_last_message_id() const;
  void clear_last_message_id() ;
  const ::pulsar::proto::MessageIdData& last_message_id() const;
  PROTOBUF_NODISCARD ::pulsar::proto::MessageIdData* release_last_message_id();
  ::pulsar::proto::MessageIdData* mutable_last_message_id();
  void set_allocated_last_message_id(::pulsar::proto::MessageIdData* value);
  void unsafe_arena_set_allocated_last_message_id(::pulsar::proto::MessageIdData* value);
  ::pulsar::proto::MessageIdData* unsafe_arena_release_last_message_id();

  private:
  const ::pulsar::proto::MessageIdData& _internal_last_message_id() const;
  ::pulsar::proto::MessageIdData* _internal_mutable_last_message_id();

  public:
  // optional .pulsar.proto.MessageIdData consumer_mark_delete_position = 3;
  bool has_consumer_mark_delete_position() const;
  void clear_consumer_mark_delete_position() ;
  const ::pulsar::proto::MessageIdData& consumer_mark_delete_position() const;
  PROTOBUF_NODISCARD ::pulsar::proto::MessageIdData* release_consumer_mark_delete_position();
  ::pulsar::proto::MessageIdData* mutable_consumer_mark_delete_position();
  void set_allocated_consumer_mark_delete_position(::pulsar::proto::MessageIdData* value);
  void unsafe_arena_set_allocated_consumer_mark_delete_position(::pulsar::proto::MessageIdData* value);
  ::pulsar::proto::MessageIdData* unsafe_arena_release_consumer_mark_delete_position();

  private:
  const ::pulsar::proto::MessageIdData& _internal_consumer_mark_delete_position() const;
  ::pulsar::proto::MessageIdData* _internal_mutable_consumer_mark_delete_position();

  public:
  // required uint64 request_id = 2;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetLastMessageIdResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::pulsar::proto::MessageIdData* last_message_id_;
    ::pulsar::proto::MessageIdData* consumer_mark_delete_position_;
    ::uint64_t request_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandEndTxnOnSubscription final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandEndTxnOnSubscription) */ {
 public:
  inline CommandEndTxnOnSubscription() : CommandEndTxnOnSubscription(nullptr) {}
  ~CommandEndTxnOnSubscription() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandEndTxnOnSubscription(::google::protobuf::internal::ConstantInitialized);

  inline CommandEndTxnOnSubscription(const CommandEndTxnOnSubscription& from)
      : CommandEndTxnOnSubscription(nullptr, from) {}
  CommandEndTxnOnSubscription(CommandEndTxnOnSubscription&& from) noexcept
    : CommandEndTxnOnSubscription() {
    *this = ::std::move(from);
  }

  inline CommandEndTxnOnSubscription& operator=(const CommandEndTxnOnSubscription& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandEndTxnOnSubscription& operator=(CommandEndTxnOnSubscription&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandEndTxnOnSubscription& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandEndTxnOnSubscription* internal_default_instance() {
    return reinterpret_cast<const CommandEndTxnOnSubscription*>(
               &_CommandEndTxnOnSubscription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(CommandEndTxnOnSubscription& a, CommandEndTxnOnSubscription& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandEndTxnOnSubscription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandEndTxnOnSubscription* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandEndTxnOnSubscription* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandEndTxnOnSubscription>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandEndTxnOnSubscription& from);
  void MergeFrom(const CommandEndTxnOnSubscription& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandEndTxnOnSubscription* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandEndTxnOnSubscription";
  }
  protected:
  explicit CommandEndTxnOnSubscription(::google::protobuf::Arena* arena);
  CommandEndTxnOnSubscription(::google::protobuf::Arena* arena, const CommandEndTxnOnSubscription& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
    kTxnidLeastBitsOfLowWatermarkFieldNumber = 6,
    kTxnActionFieldNumber = 5,
  };
  // optional .pulsar.proto.Subscription subscription = 4;
  bool has_subscription() const;
  void clear_subscription() ;
  const ::pulsar::proto::Subscription& subscription() const;
  PROTOBUF_NODISCARD ::pulsar::proto::Subscription* release_subscription();
  ::pulsar::proto::Subscription* mutable_subscription();
  void set_allocated_subscription(::pulsar::proto::Subscription* value);
  void unsafe_arena_set_allocated_subscription(::pulsar::proto::Subscription* value);
  ::pulsar::proto::Subscription* unsafe_arena_release_subscription();

  private:
  const ::pulsar::proto::Subscription& _internal_subscription() const;
  ::pulsar::proto::Subscription* _internal_mutable_subscription();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  void clear_txnid_least_bits() ;
  ::uint64_t txnid_least_bits() const;
  void set_txnid_least_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::uint64_t value);

  public:
  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  void clear_txnid_most_bits() ;
  ::uint64_t txnid_most_bits() const;
  void set_txnid_most_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::uint64_t value);

  public:
  // optional uint64 txnid_least_bits_of_low_watermark = 6;
  bool has_txnid_least_bits_of_low_watermark() const;
  void clear_txnid_least_bits_of_low_watermark() ;
  ::uint64_t txnid_least_bits_of_low_watermark() const;
  void set_txnid_least_bits_of_low_watermark(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_least_bits_of_low_watermark() const;
  void _internal_set_txnid_least_bits_of_low_watermark(::uint64_t value);

  public:
  // optional .pulsar.proto.TxnAction txn_action = 5;
  bool has_txn_action() const;
  void clear_txn_action() ;
  ::pulsar::proto::TxnAction txn_action() const;
  void set_txn_action(::pulsar::proto::TxnAction value);

  private:
  ::pulsar::proto::TxnAction _internal_txn_action() const;
  void _internal_set_txn_action(::pulsar::proto::TxnAction value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandEndTxnOnSubscription)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::pulsar::proto::Subscription* subscription_;
    ::uint64_t request_id_;
    ::uint64_t txnid_least_bits_;
    ::uint64_t txnid_most_bits_;
    ::uint64_t txnid_least_bits_of_low_watermark_;
    int txn_action_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandConnected final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandConnected) */ {
 public:
  inline CommandConnected() : CommandConnected(nullptr) {}
  ~CommandConnected() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandConnected(::google::protobuf::internal::ConstantInitialized);

  inline CommandConnected(const CommandConnected& from)
      : CommandConnected(nullptr, from) {}
  CommandConnected(CommandConnected&& from) noexcept
    : CommandConnected() {
    *this = ::std::move(from);
  }

  inline CommandConnected& operator=(const CommandConnected& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandConnected& operator=(CommandConnected&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandConnected& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandConnected* internal_default_instance() {
    return reinterpret_cast<const CommandConnected*>(
               &_CommandConnected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CommandConnected& a, CommandConnected& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandConnected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandConnected* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandConnected* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandConnected>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandConnected& from);
  void MergeFrom(const CommandConnected& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandConnected* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandConnected";
  }
  protected:
  explicit CommandConnected(::google::protobuf::Arena* arena);
  CommandConnected(::google::protobuf::Arena* arena, const CommandConnected& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerVersionFieldNumber = 1,
    kFeatureFlagsFieldNumber = 4,
    kProtocolVersionFieldNumber = 2,
    kMaxMessageSizeFieldNumber = 3,
  };
  // required string server_version = 1;
  bool has_server_version() const;
  void clear_server_version() ;
  const std::string& server_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_server_version(Arg_&& arg, Args_... args);
  std::string* mutable_server_version();
  PROTOBUF_NODISCARD std::string* release_server_version();
  void set_allocated_server_version(std::string* value);

  private:
  const std::string& _internal_server_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_version(
      const std::string& value);
  std::string* _internal_mutable_server_version();

  public:
  // optional .pulsar.proto.FeatureFlags feature_flags = 4;
  bool has_feature_flags() const;
  void clear_feature_flags() ;
  const ::pulsar::proto::FeatureFlags& feature_flags() const;
  PROTOBUF_NODISCARD ::pulsar::proto::FeatureFlags* release_feature_flags();
  ::pulsar::proto::FeatureFlags* mutable_feature_flags();
  void set_allocated_feature_flags(::pulsar::proto::FeatureFlags* value);
  void unsafe_arena_set_allocated_feature_flags(::pulsar::proto::FeatureFlags* value);
  ::pulsar::proto::FeatureFlags* unsafe_arena_release_feature_flags();

  private:
  const ::pulsar::proto::FeatureFlags& _internal_feature_flags() const;
  ::pulsar::proto::FeatureFlags* _internal_mutable_feature_flags();

  public:
  // optional int32 protocol_version = 2 [default = 0];
  bool has_protocol_version() const;
  void clear_protocol_version() ;
  ::int32_t protocol_version() const;
  void set_protocol_version(::int32_t value);

  private:
  ::int32_t _internal_protocol_version() const;
  void _internal_set_protocol_version(::int32_t value);

  public:
  // optional int32 max_message_size = 3;
  bool has_max_message_size() const;
  void clear_max_message_size() ;
  ::int32_t max_message_size() const;
  void set_max_message_size(::int32_t value);

  private:
  ::int32_t _internal_max_message_size() const;
  void _internal_set_max_message_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandConnected)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr server_version_;
    ::pulsar::proto::FeatureFlags* feature_flags_;
    ::int32_t protocol_version_;
    ::int32_t max_message_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandConnect final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandConnect) */ {
 public:
  inline CommandConnect() : CommandConnect(nullptr) {}
  ~CommandConnect() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandConnect(::google::protobuf::internal::ConstantInitialized);

  inline CommandConnect(const CommandConnect& from)
      : CommandConnect(nullptr, from) {}
  CommandConnect(CommandConnect&& from) noexcept
    : CommandConnect() {
    *this = ::std::move(from);
  }

  inline CommandConnect& operator=(const CommandConnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandConnect& operator=(CommandConnect&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandConnect& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandConnect* internal_default_instance() {
    return reinterpret_cast<const CommandConnect*>(
               &_CommandConnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CommandConnect& a, CommandConnect& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandConnect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandConnect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandConnect* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandConnect>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandConnect& from);
  void MergeFrom(const CommandConnect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandConnect* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandConnect";
  }
  protected:
  explicit CommandConnect(::google::protobuf::Arena* arena);
  CommandConnect(::google::protobuf::Arena* arena, const CommandConnect& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientVersionFieldNumber = 1,
    kAuthDataFieldNumber = 3,
    kAuthMethodNameFieldNumber = 5,
    kProxyToBrokerUrlFieldNumber = 6,
    kOriginalPrincipalFieldNumber = 7,
    kOriginalAuthDataFieldNumber = 8,
    kOriginalAuthMethodFieldNumber = 9,
    kFeatureFlagsFieldNumber = 10,
    kAuthMethodFieldNumber = 2,
    kProtocolVersionFieldNumber = 4,
  };
  // required string client_version = 1;
  bool has_client_version() const;
  void clear_client_version() ;
  const std::string& client_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_version(Arg_&& arg, Args_... args);
  std::string* mutable_client_version();
  PROTOBUF_NODISCARD std::string* release_client_version();
  void set_allocated_client_version(std::string* value);

  private:
  const std::string& _internal_client_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_version(
      const std::string& value);
  std::string* _internal_mutable_client_version();

  public:
  // optional bytes auth_data = 3;
  bool has_auth_data() const;
  void clear_auth_data() ;
  const std::string& auth_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_auth_data(Arg_&& arg, Args_... args);
  std::string* mutable_auth_data();
  PROTOBUF_NODISCARD std::string* release_auth_data();
  void set_allocated_auth_data(std::string* value);

  private:
  const std::string& _internal_auth_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_data(
      const std::string& value);
  std::string* _internal_mutable_auth_data();

  public:
  // optional string auth_method_name = 5;
  bool has_auth_method_name() const;
  void clear_auth_method_name() ;
  const std::string& auth_method_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_auth_method_name(Arg_&& arg, Args_... args);
  std::string* mutable_auth_method_name();
  PROTOBUF_NODISCARD std::string* release_auth_method_name();
  void set_allocated_auth_method_name(std::string* value);

  private:
  const std::string& _internal_auth_method_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_method_name(
      const std::string& value);
  std::string* _internal_mutable_auth_method_name();

  public:
  // optional string proxy_to_broker_url = 6;
  bool has_proxy_to_broker_url() const;
  void clear_proxy_to_broker_url() ;
  const std::string& proxy_to_broker_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proxy_to_broker_url(Arg_&& arg, Args_... args);
  std::string* mutable_proxy_to_broker_url();
  PROTOBUF_NODISCARD std::string* release_proxy_to_broker_url();
  void set_allocated_proxy_to_broker_url(std::string* value);

  private:
  const std::string& _internal_proxy_to_broker_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proxy_to_broker_url(
      const std::string& value);
  std::string* _internal_mutable_proxy_to_broker_url();

  public:
  // optional string original_principal = 7;
  bool has_original_principal() const;
  void clear_original_principal() ;
  const std::string& original_principal() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_original_principal(Arg_&& arg, Args_... args);
  std::string* mutable_original_principal();
  PROTOBUF_NODISCARD std::string* release_original_principal();
  void set_allocated_original_principal(std::string* value);

  private:
  const std::string& _internal_original_principal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_principal(
      const std::string& value);
  std::string* _internal_mutable_original_principal();

  public:
  // optional string original_auth_data = 8;
  bool has_original_auth_data() const;
  void clear_original_auth_data() ;
  const std::string& original_auth_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_original_auth_data(Arg_&& arg, Args_... args);
  std::string* mutable_original_auth_data();
  PROTOBUF_NODISCARD std::string* release_original_auth_data();
  void set_allocated_original_auth_data(std::string* value);

  private:
  const std::string& _internal_original_auth_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_auth_data(
      const std::string& value);
  std::string* _internal_mutable_original_auth_data();

  public:
  // optional string original_auth_method = 9;
  bool has_original_auth_method() const;
  void clear_original_auth_method() ;
  const std::string& original_auth_method() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_original_auth_method(Arg_&& arg, Args_... args);
  std::string* mutable_original_auth_method();
  PROTOBUF_NODISCARD std::string* release_original_auth_method();
  void set_allocated_original_auth_method(std::string* value);

  private:
  const std::string& _internal_original_auth_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_auth_method(
      const std::string& value);
  std::string* _internal_mutable_original_auth_method();

  public:
  // optional .pulsar.proto.FeatureFlags feature_flags = 10;
  bool has_feature_flags() const;
  void clear_feature_flags() ;
  const ::pulsar::proto::FeatureFlags& feature_flags() const;
  PROTOBUF_NODISCARD ::pulsar::proto::FeatureFlags* release_feature_flags();
  ::pulsar::proto::FeatureFlags* mutable_feature_flags();
  void set_allocated_feature_flags(::pulsar::proto::FeatureFlags* value);
  void unsafe_arena_set_allocated_feature_flags(::pulsar::proto::FeatureFlags* value);
  ::pulsar::proto::FeatureFlags* unsafe_arena_release_feature_flags();

  private:
  const ::pulsar::proto::FeatureFlags& _internal_feature_flags() const;
  ::pulsar::proto::FeatureFlags* _internal_mutable_feature_flags();

  public:
  // optional .pulsar.proto.AuthMethod auth_method = 2;
  bool has_auth_method() const;
  void clear_auth_method() ;
  ::pulsar::proto::AuthMethod auth_method() const;
  void set_auth_method(::pulsar::proto::AuthMethod value);

  private:
  ::pulsar::proto::AuthMethod _internal_auth_method() const;
  void _internal_set_auth_method(::pulsar::proto::AuthMethod value);

  public:
  // optional int32 protocol_version = 4 [default = 0];
  bool has_protocol_version() const;
  void clear_protocol_version() ;
  ::int32_t protocol_version() const;
  void set_protocol_version(::int32_t value);

  private:
  ::int32_t _internal_protocol_version() const;
  void _internal_set_protocol_version(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandConnect)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr client_version_;
    ::google::protobuf::internal::ArenaStringPtr auth_data_;
    ::google::protobuf::internal::ArenaStringPtr auth_method_name_;
    ::google::protobuf::internal::ArenaStringPtr proxy_to_broker_url_;
    ::google::protobuf::internal::ArenaStringPtr original_principal_;
    ::google::protobuf::internal::ArenaStringPtr original_auth_data_;
    ::google::protobuf::internal::ArenaStringPtr original_auth_method_;
    ::pulsar::proto::FeatureFlags* feature_flags_;
    int auth_method_;
    ::int32_t protocol_version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandAuthResponse final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandAuthResponse) */ {
 public:
  inline CommandAuthResponse() : CommandAuthResponse(nullptr) {}
  ~CommandAuthResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandAuthResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommandAuthResponse(const CommandAuthResponse& from)
      : CommandAuthResponse(nullptr, from) {}
  CommandAuthResponse(CommandAuthResponse&& from) noexcept
    : CommandAuthResponse() {
    *this = ::std::move(from);
  }

  inline CommandAuthResponse& operator=(const CommandAuthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandAuthResponse& operator=(CommandAuthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandAuthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandAuthResponse* internal_default_instance() {
    return reinterpret_cast<const CommandAuthResponse*>(
               &_CommandAuthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CommandAuthResponse& a, CommandAuthResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandAuthResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandAuthResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandAuthResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandAuthResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandAuthResponse& from);
  void MergeFrom(const CommandAuthResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandAuthResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandAuthResponse";
  }
  protected:
  explicit CommandAuthResponse(::google::protobuf::Arena* arena);
  CommandAuthResponse(::google::protobuf::Arena* arena, const CommandAuthResponse& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientVersionFieldNumber = 1,
    kResponseFieldNumber = 2,
    kProtocolVersionFieldNumber = 3,
  };
  // optional string client_version = 1;
  bool has_client_version() const;
  void clear_client_version() ;
  const std::string& client_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_version(Arg_&& arg, Args_... args);
  std::string* mutable_client_version();
  PROTOBUF_NODISCARD std::string* release_client_version();
  void set_allocated_client_version(std::string* value);

  private:
  const std::string& _internal_client_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_version(
      const std::string& value);
  std::string* _internal_mutable_client_version();

  public:
  // optional .pulsar.proto.AuthData response = 2;
  bool has_response() const;
  void clear_response() ;
  const ::pulsar::proto::AuthData& response() const;
  PROTOBUF_NODISCARD ::pulsar::proto::AuthData* release_response();
  ::pulsar::proto::AuthData* mutable_response();
  void set_allocated_response(::pulsar::proto::AuthData* value);
  void unsafe_arena_set_allocated_response(::pulsar::proto::AuthData* value);
  ::pulsar::proto::AuthData* unsafe_arena_release_response();

  private:
  const ::pulsar::proto::AuthData& _internal_response() const;
  ::pulsar::proto::AuthData* _internal_mutable_response();

  public:
  // optional int32 protocol_version = 3 [default = 0];
  bool has_protocol_version() const;
  void clear_protocol_version() ;
  ::int32_t protocol_version() const;
  void set_protocol_version(::int32_t value);

  private:
  ::int32_t _internal_protocol_version() const;
  void _internal_set_protocol_version(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAuthResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr client_version_;
    ::pulsar::proto::AuthData* response_;
    ::int32_t protocol_version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandAuthChallenge final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandAuthChallenge) */ {
 public:
  inline CommandAuthChallenge() : CommandAuthChallenge(nullptr) {}
  ~CommandAuthChallenge() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandAuthChallenge(::google::protobuf::internal::ConstantInitialized);

  inline CommandAuthChallenge(const CommandAuthChallenge& from)
      : CommandAuthChallenge(nullptr, from) {}
  CommandAuthChallenge(CommandAuthChallenge&& from) noexcept
    : CommandAuthChallenge() {
    *this = ::std::move(from);
  }

  inline CommandAuthChallenge& operator=(const CommandAuthChallenge& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandAuthChallenge& operator=(CommandAuthChallenge&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandAuthChallenge& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandAuthChallenge* internal_default_instance() {
    return reinterpret_cast<const CommandAuthChallenge*>(
               &_CommandAuthChallenge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CommandAuthChallenge& a, CommandAuthChallenge& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandAuthChallenge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandAuthChallenge* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandAuthChallenge* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandAuthChallenge>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandAuthChallenge& from);
  void MergeFrom(const CommandAuthChallenge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandAuthChallenge* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandAuthChallenge";
  }
  protected:
  explicit CommandAuthChallenge(::google::protobuf::Arena* arena);
  CommandAuthChallenge(::google::protobuf::Arena* arena, const CommandAuthChallenge& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerVersionFieldNumber = 1,
    kChallengeFieldNumber = 2,
    kProtocolVersionFieldNumber = 3,
  };
  // optional string server_version = 1;
  bool has_server_version() const;
  void clear_server_version() ;
  const std::string& server_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_server_version(Arg_&& arg, Args_... args);
  std::string* mutable_server_version();
  PROTOBUF_NODISCARD std::string* release_server_version();
  void set_allocated_server_version(std::string* value);

  private:
  const std::string& _internal_server_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_version(
      const std::string& value);
  std::string* _internal_mutable_server_version();

  public:
  // optional .pulsar.proto.AuthData challenge = 2;
  bool has_challenge() const;
  void clear_challenge() ;
  const ::pulsar::proto::AuthData& challenge() const;
  PROTOBUF_NODISCARD ::pulsar::proto::AuthData* release_challenge();
  ::pulsar::proto::AuthData* mutable_challenge();
  void set_allocated_challenge(::pulsar::proto::AuthData* value);
  void unsafe_arena_set_allocated_challenge(::pulsar::proto::AuthData* value);
  ::pulsar::proto::AuthData* unsafe_arena_release_challenge();

  private:
  const ::pulsar::proto::AuthData& _internal_challenge() const;
  ::pulsar::proto::AuthData* _internal_mutable_challenge();

  public:
  // optional int32 protocol_version = 3 [default = 0];
  bool has_protocol_version() const;
  void clear_protocol_version() ;
  ::int32_t protocol_version() const;
  void set_protocol_version(::int32_t value);

  private:
  ::int32_t _internal_protocol_version() const;
  void _internal_set_protocol_version(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAuthChallenge)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr server_version_;
    ::pulsar::proto::AuthData* challenge_;
    ::int32_t protocol_version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandAddSubscriptionToTxn final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandAddSubscriptionToTxn) */ {
 public:
  inline CommandAddSubscriptionToTxn() : CommandAddSubscriptionToTxn(nullptr) {}
  ~CommandAddSubscriptionToTxn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandAddSubscriptionToTxn(::google::protobuf::internal::ConstantInitialized);

  inline CommandAddSubscriptionToTxn(const CommandAddSubscriptionToTxn& from)
      : CommandAddSubscriptionToTxn(nullptr, from) {}
  CommandAddSubscriptionToTxn(CommandAddSubscriptionToTxn&& from) noexcept
    : CommandAddSubscriptionToTxn() {
    *this = ::std::move(from);
  }

  inline CommandAddSubscriptionToTxn& operator=(const CommandAddSubscriptionToTxn& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandAddSubscriptionToTxn& operator=(CommandAddSubscriptionToTxn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandAddSubscriptionToTxn& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandAddSubscriptionToTxn* internal_default_instance() {
    return reinterpret_cast<const CommandAddSubscriptionToTxn*>(
               &_CommandAddSubscriptionToTxn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(CommandAddSubscriptionToTxn& a, CommandAddSubscriptionToTxn& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandAddSubscriptionToTxn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandAddSubscriptionToTxn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandAddSubscriptionToTxn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandAddSubscriptionToTxn>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandAddSubscriptionToTxn& from);
  void MergeFrom(const CommandAddSubscriptionToTxn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandAddSubscriptionToTxn* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandAddSubscriptionToTxn";
  }
  protected:
  explicit CommandAddSubscriptionToTxn(::google::protobuf::Arena* arena);
  CommandAddSubscriptionToTxn(::google::protobuf::Arena* arena, const CommandAddSubscriptionToTxn& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kTxnidLeastBitsFieldNumber = 2,
    kTxnidMostBitsFieldNumber = 3,
  };
  // repeated .pulsar.proto.Subscription subscription = 4;
  int subscription_size() const;
  private:
  int _internal_subscription_size() const;

  public:
  void clear_subscription() ;
  ::pulsar::proto::Subscription* mutable_subscription(int index);
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::Subscription >*
      mutable_subscription();
  private:
  const ::google::protobuf::RepeatedPtrField<::pulsar::proto::Subscription>& _internal_subscription() const;
  ::google::protobuf::RepeatedPtrField<::pulsar::proto::Subscription>* _internal_mutable_subscription();
  public:
  const ::pulsar::proto::Subscription& subscription(int index) const;
  ::pulsar::proto::Subscription* add_subscription();
  const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::Subscription >&
      subscription() const;
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional uint64 txnid_least_bits = 2 [default = 0];
  bool has_txnid_least_bits() const;
  void clear_txnid_least_bits() ;
  ::uint64_t txnid_least_bits() const;
  void set_txnid_least_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::uint64_t value);

  public:
  // optional uint64 txnid_most_bits = 3 [default = 0];
  bool has_txnid_most_bits() const;
  void clear_txnid_most_bits() ;
  ::uint64_t txnid_most_bits() const;
  void set_txnid_most_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAddSubscriptionToTxn)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::pulsar::proto::Subscription > subscription_;
    ::uint64_t request_id_;
    ::uint64_t txnid_least_bits_;
    ::uint64_t txnid_most_bits_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandAck final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandAck) */ {
 public:
  inline CommandAck() : CommandAck(nullptr) {}
  ~CommandAck() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandAck(::google::protobuf::internal::ConstantInitialized);

  inline CommandAck(const CommandAck& from)
      : CommandAck(nullptr, from) {}
  CommandAck(CommandAck&& from) noexcept
    : CommandAck() {
    *this = ::std::move(from);
  }

  inline CommandAck& operator=(const CommandAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandAck& operator=(CommandAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandAck* internal_default_instance() {
    return reinterpret_cast<const CommandAck*>(
               &_CommandAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CommandAck& a, CommandAck& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandAck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandAck* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandAck& from);
  void MergeFrom(const CommandAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandAck* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandAck";
  }
  protected:
  explicit CommandAck(::google::protobuf::Arena* arena);
  CommandAck(::google::protobuf::Arena* arena, const CommandAck& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using AckType = CommandAck_AckType;
  static constexpr AckType Individual = CommandAck_AckType_Individual;
  static constexpr AckType Cumulative = CommandAck_AckType_Cumulative;
  static inline bool AckType_IsValid(int value) {
    return CommandAck_AckType_IsValid(value);
  }
  static constexpr AckType AckType_MIN = CommandAck_AckType_AckType_MIN;
  static constexpr AckType AckType_MAX = CommandAck_AckType_AckType_MAX;
  static constexpr int AckType_ARRAYSIZE = CommandAck_AckType_AckType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& AckType_Name(T value) {
    return CommandAck_AckType_Name(value);
  }
  static inline bool AckType_Parse(absl::string_view name, AckType* value) {
    return CommandAck_AckType_Parse(name, value);
  }

  using ValidationError = CommandAck_ValidationError;
  static constexpr ValidationError UncompressedSizeCorruption = CommandAck_ValidationError_UncompressedSizeCorruption;
  static constexpr ValidationError DecompressionError = CommandAck_ValidationError_DecompressionError;
  static constexpr ValidationError ChecksumMismatch = CommandAck_ValidationError_ChecksumMismatch;
  static constexpr ValidationError BatchDeSerializeError = CommandAck_ValidationError_BatchDeSerializeError;
  static constexpr ValidationError DecryptionError = CommandAck_ValidationError_DecryptionError;
  static inline bool ValidationError_IsValid(int value) {
    return CommandAck_ValidationError_IsValid(value);
  }
  static constexpr ValidationError ValidationError_MIN = CommandAck_ValidationError_ValidationError_MIN;
  static constexpr ValidationError ValidationError_MAX = CommandAck_ValidationError_ValidationError_MAX;
  static constexpr int ValidationError_ARRAYSIZE = CommandAck_ValidationError_ValidationError_ARRAYSIZE;
  template <typename T>
  static inline const std::string& ValidationError_Name(T value) {
    return CommandAck_ValidationError_Name(value);
  }
  static inline bool ValidationError_Parse(absl::string_view name, ValidationError* value) {
    return CommandAck_ValidationError_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 3,
    kPropertiesFieldNumber = 5,
    kConsumerIdFieldNumber = 1,
    kAckTypeFieldNumber = 2,
    kValidationErrorFieldNumber = 4,
    kTxnidLeastBitsFieldNumber = 6,
    kTxnidMostBitsFieldNumber = 7,
    kRequestIdFieldNumber = 8,
  };
  // repeated .pulsar.proto.MessageIdData message_id = 3;
  int message_id_size() const;
  private:
  int _internal_message_id_size() const;

  public:
  void clear_message_id() ;
  ::pulsar::proto::MessageIdData* mutable_message_id(int index);
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::MessageIdData >*
      mutable_message_id();
  private:
  const ::google::protobuf::RepeatedPtrField<::pulsar::proto::MessageIdData>& _internal_message_id() const;
  ::google::protobuf::RepeatedPtrField<::pulsar::proto::MessageIdData>* _internal_mutable_message_id();
  public:
  const ::pulsar::proto::MessageIdData& message_id(int index) const;
  ::pulsar::proto::MessageIdData* add_message_id();
  const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::MessageIdData >&
      message_id() const;
  // repeated .pulsar.proto.KeyLongValue properties = 5;
  int properties_size() const;
  private:
  int _internal_properties_size() const;

  public:
  void clear_properties() ;
  ::pulsar::proto::KeyLongValue* mutable_properties(int index);
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyLongValue >*
      mutable_properties();
  private:
  const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyLongValue>& _internal_properties() const;
  ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyLongValue>* _internal_mutable_properties();
  public:
  const ::pulsar::proto::KeyLongValue& properties(int index) const;
  ::pulsar::proto::KeyLongValue* add_properties();
  const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyLongValue >&
      properties() const;
  // required uint64 consumer_id = 1;
  bool has_consumer_id() const;
  void clear_consumer_id() ;
  ::uint64_t consumer_id() const;
  void set_consumer_id(::uint64_t value);

  private:
  ::uint64_t _internal_consumer_id() const;
  void _internal_set_consumer_id(::uint64_t value);

  public:
  // required .pulsar.proto.CommandAck.AckType ack_type = 2;
  bool has_ack_type() const;
  void clear_ack_type() ;
  ::pulsar::proto::CommandAck_AckType ack_type() const;
  void set_ack_type(::pulsar::proto::CommandAck_AckType value);

  private:
  ::pulsar::proto::CommandAck_AckType _internal_ack_type() const;
  void _internal_set_ack_type(::pulsar::proto::CommandAck_AckType value);

  public:
  // optional .pulsar.proto.CommandAck.ValidationError validation_error = 4;
  bool has_validation_error() const;
  void clear_validation_error() ;
  ::pulsar::proto::CommandAck_ValidationError validation_error() const;
  void set_validation_error(::pulsar::proto::CommandAck_ValidationError value);

  private:
  ::pulsar::proto::CommandAck_ValidationError _internal_validation_error() const;
  void _internal_set_validation_error(::pulsar::proto::CommandAck_ValidationError value);

  public:
  // optional uint64 txnid_least_bits = 6 [default = 0];
  bool has_txnid_least_bits() const;
  void clear_txnid_least_bits() ;
  ::uint64_t txnid_least_bits() const;
  void set_txnid_least_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::uint64_t value);

  public:
  // optional uint64 txnid_most_bits = 7 [default = 0];
  bool has_txnid_most_bits() const;
  void clear_txnid_most_bits() ;
  ::uint64_t txnid_most_bits() const;
  void set_txnid_most_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::uint64_t value);

  public:
  // optional uint64 request_id = 8;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandAck)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::pulsar::proto::MessageIdData > message_id_;
    ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyLongValue > properties_;
    ::uint64_t consumer_id_;
    int ack_type_;
    int validation_error_;
    ::uint64_t txnid_least_bits_;
    ::uint64_t txnid_most_bits_;
    ::uint64_t request_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class MessageMetadata final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.MessageMetadata) */ {
 public:
  inline MessageMetadata() : MessageMetadata(nullptr) {}
  ~MessageMetadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MessageMetadata(::google::protobuf::internal::ConstantInitialized);

  inline MessageMetadata(const MessageMetadata& from)
      : MessageMetadata(nullptr, from) {}
  MessageMetadata(MessageMetadata&& from) noexcept
    : MessageMetadata() {
    *this = ::std::move(from);
  }

  inline MessageMetadata& operator=(const MessageMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageMetadata& operator=(MessageMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MessageMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageMetadata* internal_default_instance() {
    return reinterpret_cast<const MessageMetadata*>(
               &_MessageMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MessageMetadata& a, MessageMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageMetadata* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const MessageMetadata& from);
  void MergeFrom(const MessageMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MessageMetadata* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.MessageMetadata";
  }
  protected:
  explicit MessageMetadata(::google::protobuf::Arena* arena);
  MessageMetadata(::google::protobuf::Arena* arena, const MessageMetadata& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 4,
    kReplicateToFieldNumber = 7,
    kEncryptionKeysFieldNumber = 13,
    kProducerNameFieldNumber = 1,
    kReplicatedFromFieldNumber = 5,
    kPartitionKeyFieldNumber = 6,
    kEncryptionAlgoFieldNumber = 14,
    kEncryptionParamFieldNumber = 15,
    kSchemaVersionFieldNumber = 16,
    kOrderingKeyFieldNumber = 18,
    kUuidFieldNumber = 26,
    kSequenceIdFieldNumber = 2,
    kPublishTimeFieldNumber = 3,
    kCompressionFieldNumber = 8,
    kUncompressedSizeFieldNumber = 9,
    kEventTimeFieldNumber = 12,
    kDeliverAtTimeFieldNumber = 19,
    kTxnidLeastBitsFieldNumber = 22,
    kTxnidMostBitsFieldNumber = 23,
    kMarkerTypeFieldNumber = 20,
    kPartitionKeyB64EncodedFieldNumber = 17,
    kNullValueFieldNumber = 25,
    kNullPartitionKeyFieldNumber = 30,
    kHighestSequenceIdFieldNumber = 24,
    kNumChunksFromMsgFieldNumber = 27,
    kTotalChunkMsgSizeFieldNumber = 28,
    kChunkIdFieldNumber = 29,
    kNumMessagesInBatchFieldNumber = 11,
  };
  // repeated .pulsar.proto.KeyValue properties = 4;
  int properties_size() const;
  private:
  int _internal_properties_size() const;

  public:
  void clear_properties() ;
  ::pulsar::proto::KeyValue* mutable_properties(int index);
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_properties();
  private:
  const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>& _internal_properties() const;
  ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>* _internal_mutable_properties();
  public:
  const ::pulsar::proto::KeyValue& properties(int index) const;
  ::pulsar::proto::KeyValue* add_properties();
  const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      properties() const;
  // repeated string replicate_to = 7;
  int replicate_to_size() const;
  private:
  int _internal_replicate_to_size() const;

  public:
  void clear_replicate_to() ;
  const std::string& replicate_to(int index) const;
  std::string* mutable_replicate_to(int index);
  void set_replicate_to(int index, const std::string& value);
  void set_replicate_to(int index, std::string&& value);
  void set_replicate_to(int index, const char* value);
  void set_replicate_to(int index, const char* value, std::size_t size);
  void set_replicate_to(int index, absl::string_view value);
  std::string* add_replicate_to();
  void add_replicate_to(const std::string& value);
  void add_replicate_to(std::string&& value);
  void add_replicate_to(const char* value);
  void add_replicate_to(const char* value, std::size_t size);
  void add_replicate_to(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& replicate_to() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_replicate_to();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_replicate_to() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_replicate_to();

  public:
  // repeated .pulsar.proto.EncryptionKeys encryption_keys = 13;
  int encryption_keys_size() const;
  private:
  int _internal_encryption_keys_size() const;

  public:
  void clear_encryption_keys() ;
  ::pulsar::proto::EncryptionKeys* mutable_encryption_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::EncryptionKeys >*
      mutable_encryption_keys();
  private:
  const ::google::protobuf::RepeatedPtrField<::pulsar::proto::EncryptionKeys>& _internal_encryption_keys() const;
  ::google::protobuf::RepeatedPtrField<::pulsar::proto::EncryptionKeys>* _internal_mutable_encryption_keys();
  public:
  const ::pulsar::proto::EncryptionKeys& encryption_keys(int index) const;
  ::pulsar::proto::EncryptionKeys* add_encryption_keys();
  const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::EncryptionKeys >&
      encryption_keys() const;
  // required string producer_name = 1;
  bool has_producer_name() const;
  void clear_producer_name() ;
  const std::string& producer_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_producer_name(Arg_&& arg, Args_... args);
  std::string* mutable_producer_name();
  PROTOBUF_NODISCARD std::string* release_producer_name();
  void set_allocated_producer_name(std::string* value);

  private:
  const std::string& _internal_producer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_producer_name(
      const std::string& value);
  std::string* _internal_mutable_producer_name();

  public:
  // optional string replicated_from = 5;
  bool has_replicated_from() const;
  void clear_replicated_from() ;
  const std::string& replicated_from() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_replicated_from(Arg_&& arg, Args_... args);
  std::string* mutable_replicated_from();
  PROTOBUF_NODISCARD std::string* release_replicated_from();
  void set_allocated_replicated_from(std::string* value);

  private:
  const std::string& _internal_replicated_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_replicated_from(
      const std::string& value);
  std::string* _internal_mutable_replicated_from();

  public:
  // optional string partition_key = 6;
  bool has_partition_key() const;
  void clear_partition_key() ;
  const std::string& partition_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_partition_key(Arg_&& arg, Args_... args);
  std::string* mutable_partition_key();
  PROTOBUF_NODISCARD std::string* release_partition_key();
  void set_allocated_partition_key(std::string* value);

  private:
  const std::string& _internal_partition_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition_key(
      const std::string& value);
  std::string* _internal_mutable_partition_key();

  public:
  // optional string encryption_algo = 14;
  bool has_encryption_algo() const;
  void clear_encryption_algo() ;
  const std::string& encryption_algo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_encryption_algo(Arg_&& arg, Args_... args);
  std::string* mutable_encryption_algo();
  PROTOBUF_NODISCARD std::string* release_encryption_algo();
  void set_allocated_encryption_algo(std::string* value);

  private:
  const std::string& _internal_encryption_algo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encryption_algo(
      const std::string& value);
  std::string* _internal_mutable_encryption_algo();

  public:
  // optional bytes encryption_param = 15;
  bool has_encryption_param() const;
  void clear_encryption_param() ;
  const std::string& encryption_param() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_encryption_param(Arg_&& arg, Args_... args);
  std::string* mutable_encryption_param();
  PROTOBUF_NODISCARD std::string* release_encryption_param();
  void set_allocated_encryption_param(std::string* value);

  private:
  const std::string& _internal_encryption_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encryption_param(
      const std::string& value);
  std::string* _internal_mutable_encryption_param();

  public:
  // optional bytes schema_version = 16;
  bool has_schema_version() const;
  void clear_schema_version() ;
  const std::string& schema_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema_version(Arg_&& arg, Args_... args);
  std::string* mutable_schema_version();
  PROTOBUF_NODISCARD std::string* release_schema_version();
  void set_allocated_schema_version(std::string* value);

  private:
  const std::string& _internal_schema_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_version(
      const std::string& value);
  std::string* _internal_mutable_schema_version();

  public:
  // optional bytes ordering_key = 18;
  bool has_ordering_key() const;
  void clear_ordering_key() ;
  const std::string& ordering_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ordering_key(Arg_&& arg, Args_... args);
  std::string* mutable_ordering_key();
  PROTOBUF_NODISCARD std::string* release_ordering_key();
  void set_allocated_ordering_key(std::string* value);

  private:
  const std::string& _internal_ordering_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ordering_key(
      const std::string& value);
  std::string* _internal_mutable_ordering_key();

  public:
  // optional string uuid = 26;
  bool has_uuid() const;
  void clear_uuid() ;
  const std::string& uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* value);

  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(
      const std::string& value);
  std::string* _internal_mutable_uuid();

  public:
  // required uint64 sequence_id = 2;
  bool has_sequence_id() const;
  void clear_sequence_id() ;
  ::uint64_t sequence_id() const;
  void set_sequence_id(::uint64_t value);

  private:
  ::uint64_t _internal_sequence_id() const;
  void _internal_set_sequence_id(::uint64_t value);

  public:
  // required uint64 publish_time = 3;
  bool has_publish_time() const;
  void clear_publish_time() ;
  ::uint64_t publish_time() const;
  void set_publish_time(::uint64_t value);

  private:
  ::uint64_t _internal_publish_time() const;
  void _internal_set_publish_time(::uint64_t value);

  public:
  // optional .pulsar.proto.CompressionType compression = 8 [default = NONE];
  bool has_compression() const;
  void clear_compression() ;
  ::pulsar::proto::CompressionType compression() const;
  void set_compression(::pulsar::proto::CompressionType value);

  private:
  ::pulsar::proto::CompressionType _internal_compression() const;
  void _internal_set_compression(::pulsar::proto::CompressionType value);

  public:
  // optional uint32 uncompressed_size = 9 [default = 0];
  bool has_uncompressed_size() const;
  void clear_uncompressed_size() ;
  ::uint32_t uncompressed_size() const;
  void set_uncompressed_size(::uint32_t value);

  private:
  ::uint32_t _internal_uncompressed_size() const;
  void _internal_set_uncompressed_size(::uint32_t value);

  public:
  // optional uint64 event_time = 12 [default = 0];
  bool has_event_time() const;
  void clear_event_time() ;
  ::uint64_t event_time() const;
  void set_event_time(::uint64_t value);

  private:
  ::uint64_t _internal_event_time() const;
  void _internal_set_event_time(::uint64_t value);

  public:
  // optional int64 deliver_at_time = 19;
  bool has_deliver_at_time() const;
  void clear_deliver_at_time() ;
  ::int64_t deliver_at_time() const;
  void set_deliver_at_time(::int64_t value);

  private:
  ::int64_t _internal_deliver_at_time() const;
  void _internal_set_deliver_at_time(::int64_t value);

  public:
  // optional uint64 txnid_least_bits = 22;
  bool has_txnid_least_bits() const;
  void clear_txnid_least_bits() ;
  ::uint64_t txnid_least_bits() const;
  void set_txnid_least_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_least_bits() const;
  void _internal_set_txnid_least_bits(::uint64_t value);

  public:
  // optional uint64 txnid_most_bits = 23;
  bool has_txnid_most_bits() const;
  void clear_txnid_most_bits() ;
  ::uint64_t txnid_most_bits() const;
  void set_txnid_most_bits(::uint64_t value);

  private:
  ::uint64_t _internal_txnid_most_bits() const;
  void _internal_set_txnid_most_bits(::uint64_t value);

  public:
  // optional int32 marker_type = 20;
  bool has_marker_type() const;
  void clear_marker_type() ;
  ::int32_t marker_type() const;
  void set_marker_type(::int32_t value);

  private:
  ::int32_t _internal_marker_type() const;
  void _internal_set_marker_type(::int32_t value);

  public:
  // optional bool partition_key_b64_encoded = 17 [default = false];
  bool has_partition_key_b64_encoded() const;
  void clear_partition_key_b64_encoded() ;
  bool partition_key_b64_encoded() const;
  void set_partition_key_b64_encoded(bool value);

  private:
  bool _internal_partition_key_b64_encoded() const;
  void _internal_set_partition_key_b64_encoded(bool value);

  public:
  // optional bool null_value = 25 [default = false];
  bool has_null_value() const;
  void clear_null_value() ;
  bool null_value() const;
  void set_null_value(bool value);

  private:
  bool _internal_null_value() const;
  void _internal_set_null_value(bool value);

  public:
  // optional bool null_partition_key = 30 [default = false];
  bool has_null_partition_key() const;
  void clear_null_partition_key() ;
  bool null_partition_key() const;
  void set_null_partition_key(bool value);

  private:
  bool _internal_null_partition_key() const;
  void _internal_set_null_partition_key(bool value);

  public:
  // optional uint64 highest_sequence_id = 24 [default = 0];
  bool has_highest_sequence_id() const;
  void clear_highest_sequence_id() ;
  ::uint64_t highest_sequence_id() const;
  void set_highest_sequence_id(::uint64_t value);

  private:
  ::uint64_t _internal_highest_sequence_id() const;
  void _internal_set_highest_sequence_id(::uint64_t value);

  public:
  // optional int32 num_chunks_from_msg = 27;
  bool has_num_chunks_from_msg() const;
  void clear_num_chunks_from_msg() ;
  ::int32_t num_chunks_from_msg() const;
  void set_num_chunks_from_msg(::int32_t value);

  private:
  ::int32_t _internal_num_chunks_from_msg() const;
  void _internal_set_num_chunks_from_msg(::int32_t value);

  public:
  // optional int32 total_chunk_msg_size = 28;
  bool has_total_chunk_msg_size() const;
  void clear_total_chunk_msg_size() ;
  ::int32_t total_chunk_msg_size() const;
  void set_total_chunk_msg_size(::int32_t value);

  private:
  ::int32_t _internal_total_chunk_msg_size() const;
  void _internal_set_total_chunk_msg_size(::int32_t value);

  public:
  // optional int32 chunk_id = 29;
  bool has_chunk_id() const;
  void clear_chunk_id() ;
  ::int32_t chunk_id() const;
  void set_chunk_id(::int32_t value);

  private:
  ::int32_t _internal_chunk_id() const;
  void _internal_set_chunk_id(::int32_t value);

  public:
  // optional int32 num_messages_in_batch = 11 [default = 1];
  bool has_num_messages_in_batch() const;
  void clear_num_messages_in_batch() ;
  ::int32_t num_messages_in_batch() const;
  void set_num_messages_in_batch(::int32_t value);

  private:
  ::int32_t _internal_num_messages_in_batch() const;
  void _internal_set_num_messages_in_batch(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.MessageMetadata)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 28, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue > properties_;
    ::google::protobuf::RepeatedPtrField<std::string> replicate_to_;
    ::google::protobuf::RepeatedPtrField< ::pulsar::proto::EncryptionKeys > encryption_keys_;
    ::google::protobuf::internal::ArenaStringPtr producer_name_;
    ::google::protobuf::internal::ArenaStringPtr replicated_from_;
    ::google::protobuf::internal::ArenaStringPtr partition_key_;
    ::google::protobuf::internal::ArenaStringPtr encryption_algo_;
    ::google::protobuf::internal::ArenaStringPtr encryption_param_;
    ::google::protobuf::internal::ArenaStringPtr schema_version_;
    ::google::protobuf::internal::ArenaStringPtr ordering_key_;
    ::google::protobuf::internal::ArenaStringPtr uuid_;
    ::uint64_t sequence_id_;
    ::uint64_t publish_time_;
    int compression_;
    ::uint32_t uncompressed_size_;
    ::uint64_t event_time_;
    ::int64_t deliver_at_time_;
    ::uint64_t txnid_least_bits_;
    ::uint64_t txnid_most_bits_;
    ::int32_t marker_type_;
    bool partition_key_b64_encoded_;
    bool null_value_;
    bool null_partition_key_;
    ::uint64_t highest_sequence_id_;
    ::int32_t num_chunks_from_msg_;
    ::int32_t total_chunk_msg_size_;
    ::int32_t chunk_id_;
    ::int32_t num_messages_in_batch_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandSuccess final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandSuccess) */ {
 public:
  inline CommandSuccess() : CommandSuccess(nullptr) {}
  ~CommandSuccess() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandSuccess(::google::protobuf::internal::ConstantInitialized);

  inline CommandSuccess(const CommandSuccess& from)
      : CommandSuccess(nullptr, from) {}
  CommandSuccess(CommandSuccess&& from) noexcept
    : CommandSuccess() {
    *this = ::std::move(from);
  }

  inline CommandSuccess& operator=(const CommandSuccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandSuccess& operator=(CommandSuccess&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandSuccess& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandSuccess* internal_default_instance() {
    return reinterpret_cast<const CommandSuccess*>(
               &_CommandSuccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(CommandSuccess& a, CommandSuccess& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandSuccess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandSuccess* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandSuccess* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandSuccess>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandSuccess& from);
  void MergeFrom(const CommandSuccess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandSuccess* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandSuccess";
  }
  protected:
  explicit CommandSuccess(::google::protobuf::Arena* arena);
  CommandSuccess(::google::protobuf::Arena* arena, const CommandSuccess& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaFieldNumber = 2,
    kRequestIdFieldNumber = 1,
  };
  // optional .pulsar.proto.Schema schema = 2;
  bool has_schema() const;
  void clear_schema() ;
  const ::pulsar::proto::Schema& schema() const;
  PROTOBUF_NODISCARD ::pulsar::proto::Schema* release_schema();
  ::pulsar::proto::Schema* mutable_schema();
  void set_allocated_schema(::pulsar::proto::Schema* value);
  void unsafe_arena_set_allocated_schema(::pulsar::proto::Schema* value);
  ::pulsar::proto::Schema* unsafe_arena_release_schema();

  private:
  const ::pulsar::proto::Schema& _internal_schema() const;
  ::pulsar::proto::Schema* _internal_mutable_schema();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSuccess)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::pulsar::proto::Schema* schema_;
    ::uint64_t request_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandSubscribe final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandSubscribe) */ {
 public:
  inline CommandSubscribe() : CommandSubscribe(nullptr) {}
  ~CommandSubscribe() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandSubscribe(::google::protobuf::internal::ConstantInitialized);

  inline CommandSubscribe(const CommandSubscribe& from)
      : CommandSubscribe(nullptr, from) {}
  CommandSubscribe(CommandSubscribe&& from) noexcept
    : CommandSubscribe() {
    *this = ::std::move(from);
  }

  inline CommandSubscribe& operator=(const CommandSubscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandSubscribe& operator=(CommandSubscribe&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandSubscribe& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandSubscribe* internal_default_instance() {
    return reinterpret_cast<const CommandSubscribe*>(
               &_CommandSubscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CommandSubscribe& a, CommandSubscribe& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandSubscribe* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandSubscribe* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandSubscribe* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandSubscribe>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandSubscribe& from);
  void MergeFrom(const CommandSubscribe& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandSubscribe* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandSubscribe";
  }
  protected:
  explicit CommandSubscribe(::google::protobuf::Arena* arena);
  CommandSubscribe(::google::protobuf::Arena* arena, const CommandSubscribe& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using SubType = CommandSubscribe_SubType;
  static constexpr SubType Exclusive = CommandSubscribe_SubType_Exclusive;
  static constexpr SubType Shared = CommandSubscribe_SubType_Shared;
  static constexpr SubType Failover = CommandSubscribe_SubType_Failover;
  static constexpr SubType Key_Shared = CommandSubscribe_SubType_Key_Shared;
  static inline bool SubType_IsValid(int value) {
    return CommandSubscribe_SubType_IsValid(value);
  }
  static constexpr SubType SubType_MIN = CommandSubscribe_SubType_SubType_MIN;
  static constexpr SubType SubType_MAX = CommandSubscribe_SubType_SubType_MAX;
  static constexpr int SubType_ARRAYSIZE = CommandSubscribe_SubType_SubType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& SubType_Name(T value) {
    return CommandSubscribe_SubType_Name(value);
  }
  static inline bool SubType_Parse(absl::string_view name, SubType* value) {
    return CommandSubscribe_SubType_Parse(name, value);
  }

  using InitialPosition = CommandSubscribe_InitialPosition;
  static constexpr InitialPosition Latest = CommandSubscribe_InitialPosition_Latest;
  static constexpr InitialPosition Earliest = CommandSubscribe_InitialPosition_Earliest;
  static inline bool InitialPosition_IsValid(int value) {
    return CommandSubscribe_InitialPosition_IsValid(value);
  }
  static constexpr InitialPosition InitialPosition_MIN = CommandSubscribe_InitialPosition_InitialPosition_MIN;
  static constexpr InitialPosition InitialPosition_MAX = CommandSubscribe_InitialPosition_InitialPosition_MAX;
  static constexpr int InitialPosition_ARRAYSIZE = CommandSubscribe_InitialPosition_InitialPosition_ARRAYSIZE;
  template <typename T>
  static inline const std::string& InitialPosition_Name(T value) {
    return CommandSubscribe_InitialPosition_Name(value);
  }
  static inline bool InitialPosition_Parse(absl::string_view name, InitialPosition* value) {
    return CommandSubscribe_InitialPosition_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 10,
    kSubscriptionPropertiesFieldNumber = 18,
    kTopicFieldNumber = 1,
    kSubscriptionFieldNumber = 2,
    kConsumerNameFieldNumber = 6,
    kStartMessageIdFieldNumber = 9,
    kSchemaFieldNumber = 12,
    kKeySharedMetaFieldNumber = 17,
    kConsumerIdFieldNumber = 4,
    kRequestIdFieldNumber = 5,
    kSubTypeFieldNumber = 3,
    kPriorityLevelFieldNumber = 7,
    kReadCompactedFieldNumber = 11,
    kReplicateSubscriptionStateFieldNumber = 14,
    kInitialPositionFieldNumber = 13,
    kStartMessageRollbackDurationSecFieldNumber = 16,
    kConsumerEpochFieldNumber = 19,
    kDurableFieldNumber = 8,
    kForceTopicCreationFieldNumber = 15,
  };
  // repeated .pulsar.proto.KeyValue metadata = 10;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  ::pulsar::proto::KeyValue* mutable_metadata(int index);
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_metadata();
  private:
  const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>& _internal_metadata() const;
  ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>* _internal_mutable_metadata();
  public:
  const ::pulsar::proto::KeyValue& metadata(int index) const;
  ::pulsar::proto::KeyValue* add_metadata();
  const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      metadata() const;
  // repeated .pulsar.proto.KeyValue subscription_properties = 18;
  int subscription_properties_size() const;
  private:
  int _internal_subscription_properties_size() const;

  public:
  void clear_subscription_properties() ;
  ::pulsar::proto::KeyValue* mutable_subscription_properties(int index);
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_subscription_properties();
  private:
  const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>& _internal_subscription_properties() const;
  ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>* _internal_mutable_subscription_properties();
  public:
  const ::pulsar::proto::KeyValue& subscription_properties(int index) const;
  ::pulsar::proto::KeyValue* add_subscription_properties();
  const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      subscription_properties() const;
  // required string topic = 1;
  bool has_topic() const;
  void clear_topic() ;
  const std::string& topic() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topic(Arg_&& arg, Args_... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* value);

  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(
      const std::string& value);
  std::string* _internal_mutable_topic();

  public:
  // required string subscription = 2;
  bool has_subscription() const;
  void clear_subscription() ;
  const std::string& subscription() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subscription(Arg_&& arg, Args_... args);
  std::string* mutable_subscription();
  PROTOBUF_NODISCARD std::string* release_subscription();
  void set_allocated_subscription(std::string* value);

  private:
  const std::string& _internal_subscription() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscription(
      const std::string& value);
  std::string* _internal_mutable_subscription();

  public:
  // optional string consumer_name = 6;
  bool has_consumer_name() const;
  void clear_consumer_name() ;
  const std::string& consumer_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_consumer_name(Arg_&& arg, Args_... args);
  std::string* mutable_consumer_name();
  PROTOBUF_NODISCARD std::string* release_consumer_name();
  void set_allocated_consumer_name(std::string* value);

  private:
  const std::string& _internal_consumer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_consumer_name(
      const std::string& value);
  std::string* _internal_mutable_consumer_name();

  public:
  // optional .pulsar.proto.MessageIdData start_message_id = 9;
  bool has_start_message_id() const;
  void clear_start_message_id() ;
  const ::pulsar::proto::MessageIdData& start_message_id() const;
  PROTOBUF_NODISCARD ::pulsar::proto::MessageIdData* release_start_message_id();
  ::pulsar::proto::MessageIdData* mutable_start_message_id();
  void set_allocated_start_message_id(::pulsar::proto::MessageIdData* value);
  void unsafe_arena_set_allocated_start_message_id(::pulsar::proto::MessageIdData* value);
  ::pulsar::proto::MessageIdData* unsafe_arena_release_start_message_id();

  private:
  const ::pulsar::proto::MessageIdData& _internal_start_message_id() const;
  ::pulsar::proto::MessageIdData* _internal_mutable_start_message_id();

  public:
  // optional .pulsar.proto.Schema schema = 12;
  bool has_schema() const;
  void clear_schema() ;
  const ::pulsar::proto::Schema& schema() const;
  PROTOBUF_NODISCARD ::pulsar::proto::Schema* release_schema();
  ::pulsar::proto::Schema* mutable_schema();
  void set_allocated_schema(::pulsar::proto::Schema* value);
  void unsafe_arena_set_allocated_schema(::pulsar::proto::Schema* value);
  ::pulsar::proto::Schema* unsafe_arena_release_schema();

  private:
  const ::pulsar::proto::Schema& _internal_schema() const;
  ::pulsar::proto::Schema* _internal_mutable_schema();

  public:
  // optional .pulsar.proto.KeySharedMeta keySharedMeta = 17;
  bool has_keysharedmeta() const;
  void clear_keysharedmeta() ;
  const ::pulsar::proto::KeySharedMeta& keysharedmeta() const;
  PROTOBUF_NODISCARD ::pulsar::proto::KeySharedMeta* release_keysharedmeta();
  ::pulsar::proto::KeySharedMeta* mutable_keysharedmeta();
  void set_allocated_keysharedmeta(::pulsar::proto::KeySharedMeta* value);
  void unsafe_arena_set_allocated_keysharedmeta(::pulsar::proto::KeySharedMeta* value);
  ::pulsar::proto::KeySharedMeta* unsafe_arena_release_keysharedmeta();

  private:
  const ::pulsar::proto::KeySharedMeta& _internal_keysharedmeta() const;
  ::pulsar::proto::KeySharedMeta* _internal_mutable_keysharedmeta();

  public:
  // required uint64 consumer_id = 4;
  bool has_consumer_id() const;
  void clear_consumer_id() ;
  ::uint64_t consumer_id() const;
  void set_consumer_id(::uint64_t value);

  private:
  ::uint64_t _internal_consumer_id() const;
  void _internal_set_consumer_id(::uint64_t value);

  public:
  // required uint64 request_id = 5;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // required .pulsar.proto.CommandSubscribe.SubType subType = 3;
  bool has_subtype() const;
  void clear_subtype() ;
  ::pulsar::proto::CommandSubscribe_SubType subtype() const;
  void set_subtype(::pulsar::proto::CommandSubscribe_SubType value);

  private:
  ::pulsar::proto::CommandSubscribe_SubType _internal_subtype() const;
  void _internal_set_subtype(::pulsar::proto::CommandSubscribe_SubType value);

  public:
  // optional int32 priority_level = 7;
  bool has_priority_level() const;
  void clear_priority_level() ;
  ::int32_t priority_level() const;
  void set_priority_level(::int32_t value);

  private:
  ::int32_t _internal_priority_level() const;
  void _internal_set_priority_level(::int32_t value);

  public:
  // optional bool read_compacted = 11;
  bool has_read_compacted() const;
  void clear_read_compacted() ;
  bool read_compacted() const;
  void set_read_compacted(bool value);

  private:
  bool _internal_read_compacted() const;
  void _internal_set_read_compacted(bool value);

  public:
  // optional bool replicate_subscription_state = 14;
  bool has_replicate_subscription_state() const;
  void clear_replicate_subscription_state() ;
  bool replicate_subscription_state() const;
  void set_replicate_subscription_state(bool value);

  private:
  bool _internal_replicate_subscription_state() const;
  void _internal_set_replicate_subscription_state(bool value);

  public:
  // optional .pulsar.proto.CommandSubscribe.InitialPosition initialPosition = 13 [default = Latest];
  bool has_initialposition() const;
  void clear_initialposition() ;
  ::pulsar::proto::CommandSubscribe_InitialPosition initialposition() const;
  void set_initialposition(::pulsar::proto::CommandSubscribe_InitialPosition value);

  private:
  ::pulsar::proto::CommandSubscribe_InitialPosition _internal_initialposition() const;
  void _internal_set_initialposition(::pulsar::proto::CommandSubscribe_InitialPosition value);

  public:
  // optional uint64 start_message_rollback_duration_sec = 16 [default = 0];
  bool has_start_message_rollback_duration_sec() const;
  void clear_start_message_rollback_duration_sec() ;
  ::uint64_t start_message_rollback_duration_sec() const;
  void set_start_message_rollback_duration_sec(::uint64_t value);

  private:
  ::uint64_t _internal_start_message_rollback_duration_sec() const;
  void _internal_set_start_message_rollback_duration_sec(::uint64_t value);

  public:
  // optional uint64 consumer_epoch = 19;
  bool has_consumer_epoch() const;
  void clear_consumer_epoch() ;
  ::uint64_t consumer_epoch() const;
  void set_consumer_epoch(::uint64_t value);

  private:
  ::uint64_t _internal_consumer_epoch() const;
  void _internal_set_consumer_epoch(::uint64_t value);

  public:
  // optional bool durable = 8 [default = true];
  bool has_durable() const;
  void clear_durable() ;
  bool durable() const;
  void set_durable(bool value);

  private:
  bool _internal_durable() const;
  void _internal_set_durable(bool value);

  public:
  // optional bool force_topic_creation = 15 [default = true];
  bool has_force_topic_creation() const;
  void clear_force_topic_creation() ;
  bool force_topic_creation() const;
  void set_force_topic_creation(bool value);

  private:
  bool _internal_force_topic_creation() const;
  void _internal_set_force_topic_creation(bool value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandSubscribe)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 19, 7,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue > metadata_;
    ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue > subscription_properties_;
    ::google::protobuf::internal::ArenaStringPtr topic_;
    ::google::protobuf::internal::ArenaStringPtr subscription_;
    ::google::protobuf::internal::ArenaStringPtr consumer_name_;
    ::pulsar::proto::MessageIdData* start_message_id_;
    ::pulsar::proto::Schema* schema_;
    ::pulsar::proto::KeySharedMeta* keysharedmeta_;
    ::uint64_t consumer_id_;
    ::uint64_t request_id_;
    int subtype_;
    ::int32_t priority_level_;
    bool read_compacted_;
    bool replicate_subscription_state_;
    int initialposition_;
    ::uint64_t start_message_rollback_duration_sec_;
    ::uint64_t consumer_epoch_;
    bool durable_;
    bool force_topic_creation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandProducer final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandProducer) */ {
 public:
  inline CommandProducer() : CommandProducer(nullptr) {}
  ~CommandProducer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandProducer(::google::protobuf::internal::ConstantInitialized);

  inline CommandProducer(const CommandProducer& from)
      : CommandProducer(nullptr, from) {}
  CommandProducer(CommandProducer&& from) noexcept
    : CommandProducer() {
    *this = ::std::move(from);
  }

  inline CommandProducer& operator=(const CommandProducer& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandProducer& operator=(CommandProducer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandProducer& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandProducer* internal_default_instance() {
    return reinterpret_cast<const CommandProducer*>(
               &_CommandProducer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CommandProducer& a, CommandProducer& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandProducer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandProducer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandProducer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandProducer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandProducer& from);
  void MergeFrom(const CommandProducer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandProducer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandProducer";
  }
  protected:
  explicit CommandProducer(::google::protobuf::Arena* arena);
  CommandProducer(::google::protobuf::Arena* arena, const CommandProducer& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 6,
    kTopicFieldNumber = 1,
    kProducerNameFieldNumber = 4,
    kInitialSubscriptionNameFieldNumber = 13,
    kSchemaFieldNumber = 7,
    kProducerIdFieldNumber = 2,
    kRequestIdFieldNumber = 3,
    kEpochFieldNumber = 8,
    kEncryptedFieldNumber = 5,
    kTxnEnabledFieldNumber = 12,
    kProducerAccessModeFieldNumber = 10,
    kTopicEpochFieldNumber = 11,
    kUserProvidedProducerNameFieldNumber = 9,
  };
  // repeated .pulsar.proto.KeyValue metadata = 6;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  ::pulsar::proto::KeyValue* mutable_metadata(int index);
  ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >*
      mutable_metadata();
  private:
  const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>& _internal_metadata() const;
  ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>* _internal_mutable_metadata();
  public:
  const ::pulsar::proto::KeyValue& metadata(int index) const;
  ::pulsar::proto::KeyValue* add_metadata();
  const ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue >&
      metadata() const;
  // required string topic = 1;
  bool has_topic() const;
  void clear_topic() ;
  const std::string& topic() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topic(Arg_&& arg, Args_... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* value);

  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(
      const std::string& value);
  std::string* _internal_mutable_topic();

  public:
  // optional string producer_name = 4;
  bool has_producer_name() const;
  void clear_producer_name() ;
  const std::string& producer_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_producer_name(Arg_&& arg, Args_... args);
  std::string* mutable_producer_name();
  PROTOBUF_NODISCARD std::string* release_producer_name();
  void set_allocated_producer_name(std::string* value);

  private:
  const std::string& _internal_producer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_producer_name(
      const std::string& value);
  std::string* _internal_mutable_producer_name();

  public:
  // optional string initial_subscription_name = 13;
  bool has_initial_subscription_name() const;
  void clear_initial_subscription_name() ;
  const std::string& initial_subscription_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initial_subscription_name(Arg_&& arg, Args_... args);
  std::string* mutable_initial_subscription_name();
  PROTOBUF_NODISCARD std::string* release_initial_subscription_name();
  void set_allocated_initial_subscription_name(std::string* value);

  private:
  const std::string& _internal_initial_subscription_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_subscription_name(
      const std::string& value);
  std::string* _internal_mutable_initial_subscription_name();

  public:
  // optional .pulsar.proto.Schema schema = 7;
  bool has_schema() const;
  void clear_schema() ;
  const ::pulsar::proto::Schema& schema() const;
  PROTOBUF_NODISCARD ::pulsar::proto::Schema* release_schema();
  ::pulsar::proto::Schema* mutable_schema();
  void set_allocated_schema(::pulsar::proto::Schema* value);
  void unsafe_arena_set_allocated_schema(::pulsar::proto::Schema* value);
  ::pulsar::proto::Schema* unsafe_arena_release_schema();

  private:
  const ::pulsar::proto::Schema& _internal_schema() const;
  ::pulsar::proto::Schema* _internal_mutable_schema();

  public:
  // required uint64 producer_id = 2;
  bool has_producer_id() const;
  void clear_producer_id() ;
  ::uint64_t producer_id() const;
  void set_producer_id(::uint64_t value);

  private:
  ::uint64_t _internal_producer_id() const;
  void _internal_set_producer_id(::uint64_t value);

  public:
  // required uint64 request_id = 3;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional uint64 epoch = 8 [default = 0];
  bool has_epoch() const;
  void clear_epoch() ;
  ::uint64_t epoch() const;
  void set_epoch(::uint64_t value);

  private:
  ::uint64_t _internal_epoch() const;
  void _internal_set_epoch(::uint64_t value);

  public:
  // optional bool encrypted = 5 [default = false];
  bool has_encrypted() const;
  void clear_encrypted() ;
  bool encrypted() const;
  void set_encrypted(bool value);

  private:
  bool _internal_encrypted() const;
  void _internal_set_encrypted(bool value);

  public:
  // optional bool txn_enabled = 12 [default = false];
  bool has_txn_enabled() const;
  void clear_txn_enabled() ;
  bool txn_enabled() const;
  void set_txn_enabled(bool value);

  private:
  bool _internal_txn_enabled() const;
  void _internal_set_txn_enabled(bool value);

  public:
  // optional .pulsar.proto.ProducerAccessMode producer_access_mode = 10 [default = Shared];
  bool has_producer_access_mode() const;
  void clear_producer_access_mode() ;
  ::pulsar::proto::ProducerAccessMode producer_access_mode() const;
  void set_producer_access_mode(::pulsar::proto::ProducerAccessMode value);

  private:
  ::pulsar::proto::ProducerAccessMode _internal_producer_access_mode() const;
  void _internal_set_producer_access_mode(::pulsar::proto::ProducerAccessMode value);

  public:
  // optional uint64 topic_epoch = 11;
  bool has_topic_epoch() const;
  void clear_topic_epoch() ;
  ::uint64_t topic_epoch() const;
  void set_topic_epoch(::uint64_t value);

  private:
  ::uint64_t _internal_topic_epoch() const;
  void _internal_set_topic_epoch(::uint64_t value);

  public:
  // optional bool user_provided_producer_name = 9 [default = true];
  bool has_user_provided_producer_name() const;
  void clear_user_provided_producer_name() ;
  bool user_provided_producer_name() const;
  void set_user_provided_producer_name(bool value);

  private:
  bool _internal_user_provided_producer_name() const;
  void _internal_set_user_provided_producer_name(bool value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandProducer)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::pulsar::proto::KeyValue > metadata_;
    ::google::protobuf::internal::ArenaStringPtr topic_;
    ::google::protobuf::internal::ArenaStringPtr producer_name_;
    ::google::protobuf::internal::ArenaStringPtr initial_subscription_name_;
    ::pulsar::proto::Schema* schema_;
    ::uint64_t producer_id_;
    ::uint64_t request_id_;
    ::uint64_t epoch_;
    bool encrypted_;
    bool txn_enabled_;
    int producer_access_mode_;
    ::uint64_t topic_epoch_;
    bool user_provided_producer_name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandGetSchemaResponse final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandGetSchemaResponse) */ {
 public:
  inline CommandGetSchemaResponse() : CommandGetSchemaResponse(nullptr) {}
  ~CommandGetSchemaResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetSchemaResponse(::google::protobuf::internal::ConstantInitialized);

  inline CommandGetSchemaResponse(const CommandGetSchemaResponse& from)
      : CommandGetSchemaResponse(nullptr, from) {}
  CommandGetSchemaResponse(CommandGetSchemaResponse&& from) noexcept
    : CommandGetSchemaResponse() {
    *this = ::std::move(from);
  }

  inline CommandGetSchemaResponse& operator=(const CommandGetSchemaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetSchemaResponse& operator=(CommandGetSchemaResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandGetSchemaResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGetSchemaResponse* internal_default_instance() {
    return reinterpret_cast<const CommandGetSchemaResponse*>(
               &_CommandGetSchemaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(CommandGetSchemaResponse& a, CommandGetSchemaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandGetSchemaResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetSchemaResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetSchemaResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandGetSchemaResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandGetSchemaResponse& from);
  void MergeFrom(const CommandGetSchemaResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandGetSchemaResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandGetSchemaResponse";
  }
  protected:
  explicit CommandGetSchemaResponse(::google::protobuf::Arena* arena);
  CommandGetSchemaResponse(::google::protobuf::Arena* arena, const CommandGetSchemaResponse& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kSchemaVersionFieldNumber = 5,
    kSchemaFieldNumber = 4,
    kRequestIdFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // optional string error_message = 3;
  bool has_error_message() const;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // optional bytes schema_version = 5;
  bool has_schema_version() const;
  void clear_schema_version() ;
  const std::string& schema_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema_version(Arg_&& arg, Args_... args);
  std::string* mutable_schema_version();
  PROTOBUF_NODISCARD std::string* release_schema_version();
  void set_allocated_schema_version(std::string* value);

  private:
  const std::string& _internal_schema_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_version(
      const std::string& value);
  std::string* _internal_mutable_schema_version();

  public:
  // optional .pulsar.proto.Schema schema = 4;
  bool has_schema() const;
  void clear_schema() ;
  const ::pulsar::proto::Schema& schema() const;
  PROTOBUF_NODISCARD ::pulsar::proto::Schema* release_schema();
  ::pulsar::proto::Schema* mutable_schema();
  void set_allocated_schema(::pulsar::proto::Schema* value);
  void unsafe_arena_set_allocated_schema(::pulsar::proto::Schema* value);
  ::pulsar::proto::Schema* unsafe_arena_release_schema();

  private:
  const ::pulsar::proto::Schema& _internal_schema() const;
  ::pulsar::proto::Schema* _internal_mutable_schema();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // optional .pulsar.proto.ServerError error_code = 2;
  bool has_error_code() const;
  void clear_error_code() ;
  ::pulsar::proto::ServerError error_code() const;
  void set_error_code(::pulsar::proto::ServerError value);

  private:
  ::pulsar::proto::ServerError _internal_error_code() const;
  void _internal_set_error_code(::pulsar::proto::ServerError value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetSchemaResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::google::protobuf::internal::ArenaStringPtr schema_version_;
    ::pulsar::proto::Schema* schema_;
    ::uint64_t request_id_;
    int error_code_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class CommandGetOrCreateSchema final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.CommandGetOrCreateSchema) */ {
 public:
  inline CommandGetOrCreateSchema() : CommandGetOrCreateSchema(nullptr) {}
  ~CommandGetOrCreateSchema() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetOrCreateSchema(::google::protobuf::internal::ConstantInitialized);

  inline CommandGetOrCreateSchema(const CommandGetOrCreateSchema& from)
      : CommandGetOrCreateSchema(nullptr, from) {}
  CommandGetOrCreateSchema(CommandGetOrCreateSchema&& from) noexcept
    : CommandGetOrCreateSchema() {
    *this = ::std::move(from);
  }

  inline CommandGetOrCreateSchema& operator=(const CommandGetOrCreateSchema& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetOrCreateSchema& operator=(CommandGetOrCreateSchema&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommandGetOrCreateSchema& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGetOrCreateSchema* internal_default_instance() {
    return reinterpret_cast<const CommandGetOrCreateSchema*>(
               &_CommandGetOrCreateSchema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(CommandGetOrCreateSchema& a, CommandGetOrCreateSchema& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandGetOrCreateSchema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetOrCreateSchema* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetOrCreateSchema* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandGetOrCreateSchema>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const CommandGetOrCreateSchema& from);
  void MergeFrom(const CommandGetOrCreateSchema& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CommandGetOrCreateSchema* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.CommandGetOrCreateSchema";
  }
  protected:
  explicit CommandGetOrCreateSchema(::google::protobuf::Arena* arena);
  CommandGetOrCreateSchema(::google::protobuf::Arena* arena, const CommandGetOrCreateSchema& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 2,
    kSchemaFieldNumber = 3,
    kRequestIdFieldNumber = 1,
  };
  // required string topic = 2;
  bool has_topic() const;
  void clear_topic() ;
  const std::string& topic() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_topic(Arg_&& arg, Args_... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* value);

  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(
      const std::string& value);
  std::string* _internal_mutable_topic();

  public:
  // required .pulsar.proto.Schema schema = 3;
  bool has_schema() const;
  void clear_schema() ;
  const ::pulsar::proto::Schema& schema() const;
  PROTOBUF_NODISCARD ::pulsar::proto::Schema* release_schema();
  ::pulsar::proto::Schema* mutable_schema();
  void set_allocated_schema(::pulsar::proto::Schema* value);
  void unsafe_arena_set_allocated_schema(::pulsar::proto::Schema* value);
  ::pulsar::proto::Schema* unsafe_arena_release_schema();

  private:
  const ::pulsar::proto::Schema& _internal_schema() const;
  ::pulsar::proto::Schema* _internal_mutable_schema();

  public:
  // required uint64 request_id = 1;
  bool has_request_id() const;
  void clear_request_id() ;
  ::uint64_t request_id() const;
  void set_request_id(::uint64_t value);

  private:
  ::uint64_t _internal_request_id() const;
  void _internal_set_request_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.CommandGetOrCreateSchema)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr topic_;
    ::pulsar::proto::Schema* schema_;
    ::uint64_t request_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};// -------------------------------------------------------------------

class BaseCommand final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:pulsar.proto.BaseCommand) */ {
 public:
  inline BaseCommand() : BaseCommand(nullptr) {}
  ~BaseCommand() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BaseCommand(::google::protobuf::internal::ConstantInitialized);

  inline BaseCommand(const BaseCommand& from)
      : BaseCommand(nullptr, from) {}
  BaseCommand(BaseCommand&& from) noexcept
    : BaseCommand() {
    *this = ::std::move(from);
  }

  inline BaseCommand& operator=(const BaseCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseCommand& operator=(BaseCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BaseCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseCommand* internal_default_instance() {
    return reinterpret_cast<const BaseCommand*>(
               &_BaseCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(BaseCommand& a, BaseCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseCommand* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseCommand* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BaseCommand>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const BaseCommand& from);
  void MergeFrom(const BaseCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BaseCommand* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pulsar.proto.BaseCommand";
  }
  protected:
  explicit BaseCommand(::google::protobuf::Arena* arena);
  BaseCommand(::google::protobuf::Arena* arena, const BaseCommand& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Type = BaseCommand_Type;
  static constexpr Type CONNECT = BaseCommand_Type_CONNECT;
  static constexpr Type CONNECTED = BaseCommand_Type_CONNECTED;
  static constexpr Type SUBSCRIBE = BaseCommand_Type_SUBSCRIBE;
  static constexpr Type PRODUCER = BaseCommand_Type_PRODUCER;
  static constexpr Type SEND = BaseCommand_Type_SEND;
  static constexpr Type SEND_RECEIPT = BaseCommand_Type_SEND_RECEIPT;
  static constexpr Type SEND_ERROR = BaseCommand_Type_SEND_ERROR;
  static constexpr Type MESSAGE = BaseCommand_Type_MESSAGE;
  static constexpr Type ACK = BaseCommand_Type_ACK;
  static constexpr Type FLOW = BaseCommand_Type_FLOW;
  static constexpr Type UNSUBSCRIBE = BaseCommand_Type_UNSUBSCRIBE;
  static constexpr Type SUCCESS = BaseCommand_Type_SUCCESS;
  static constexpr Type ERROR = BaseCommand_Type_ERROR;
  static constexpr Type CLOSE_PRODUCER = BaseCommand_Type_CLOSE_PRODUCER;
  static constexpr Type CLOSE_CONSUMER = BaseCommand_Type_CLOSE_CONSUMER;
  static constexpr Type PRODUCER_SUCCESS = BaseCommand_Type_PRODUCER_SUCCESS;
  static constexpr Type PING = BaseCommand_Type_PING;
  static constexpr Type PONG = BaseCommand_Type_PONG;
  static constexpr Type REDELIVER_UNACKNOWLEDGED_MESSAGES = BaseCommand_Type_REDELIVER_UNACKNOWLEDGED_MESSAGES;
  static constexpr Type PARTITIONED_METADATA = BaseCommand_Type_PARTITIONED_METADATA;
  static constexpr Type PARTITIONED_METADATA_RESPONSE = BaseCommand_Type_PARTITIONED_METADATA_RESPONSE;
  static constexpr Type LOOKUP = BaseCommand_Type_LOOKUP;
  static constexpr Type LOOKUP_RESPONSE = BaseCommand_Type_LOOKUP_RESPONSE;
  static constexpr Type CONSUMER_STATS = BaseCommand_Type_CONSUMER_STATS;
  static constexpr Type CONSUMER_STATS_RESPONSE = BaseCommand_Type_CONSUMER_STATS_RESPONSE;
  static constexpr Type REACHED_END_OF_TOPIC = BaseCommand_Type_REACHED_END_OF_TOPIC;
  static constexpr Type SEEK = BaseCommand_Type_SEEK;
  static constexpr Type GET_LAST_MESSAGE_ID = BaseCommand_Type_GET_LAST_MESSAGE_ID;
  static constexpr Type GET_LAST_MESSAGE_ID_RESPONSE = BaseCommand_Type_GET_LAST_MESSAGE_ID_RESPONSE;
  static constexpr Type ACTIVE_CONSUMER_CHANGE = BaseCommand_Type_ACTIVE_CONSUMER_CHANGE;
  static constexpr Type GET_TOPICS_OF_NAMESPACE = BaseCommand_Type_GET_TOPICS_OF_NAMESPACE;
  static constexpr Type GET_TOPICS_OF_NAMESPACE_RESPONSE = BaseCommand_Type_GET_TOPICS_OF_NAMESPACE_RESPONSE;
  static constexpr Type GET_SCHEMA = BaseCommand_Type_GET_SCHEMA;
  static constexpr Type GET_SCHEMA_RESPONSE = BaseCommand_Type_GET_SCHEMA_RESPONSE;
  static constexpr Type AUTH_CHALLENGE = BaseCommand_Type_AUTH_CHALLENGE;
  static constexpr Type AUTH_RESPONSE = BaseCommand_Type_AUTH_RESPONSE;
  static constexpr Type ACK_RESPONSE = BaseCommand_Type_ACK_RESPONSE;
  static constexpr Type GET_OR_CREATE_SCHEMA = BaseCommand_Type_GET_OR_CREATE_SCHEMA;
  static constexpr Type GET_OR_CREATE_SCHEMA_RESPONSE = BaseCommand_Type_GET_OR_CREATE_SCHEMA_RESPONSE;
  static constexpr Type NEW_TXN = BaseCommand_Type_NEW_TXN;
  static constexpr Type NEW_TXN_RESPONSE = BaseCommand_Type_NEW_TXN_RESPONSE;
  static constexpr Type ADD_PARTITION_TO_TXN = BaseCommand_Type_ADD_PARTITION_TO_TXN;
  static constexpr Type ADD_PARTITION_TO_TXN_RESPONSE = BaseCommand_Type_ADD_PARTITION_TO_TXN_RESPONSE;
  static constexpr Type ADD_SUBSCRIPTION_TO_TXN = BaseCommand_Type_ADD_SUBSCRIPTION_TO_TXN;
  static constexpr Type ADD_SUBSCRIPTION_TO_TXN_RESPONSE = BaseCommand_Type_ADD_SUBSCRIPTION_TO_TXN_RESPONSE;
  static constexpr Type END_TXN = BaseCommand_Type_END_TXN;
  static constexpr Type END_TXN_RESPONSE = BaseCommand_Type_END_TXN_RESPONSE;
  static constexpr Type END_TXN_ON_PARTITION = BaseCommand_Type_END_TXN_ON_PARTITION;
  static constexpr Type END_TXN_ON_PARTITION_RESPONSE = BaseCommand_Type_END_TXN_ON_PARTITION_RESPONSE;
  static constexpr Type END_TXN_ON_SUBSCRIPTION = BaseCommand_Type_END_TXN_ON_SUBSCRIPTION;
  static constexpr Type END_TXN_ON_SUBSCRIPTION_RESPONSE = BaseCommand_Type_END_TXN_ON_SUBSCRIPTION_RESPONSE;
  static constexpr Type TC_CLIENT_CONNECT_REQUEST = BaseCommand_Type_TC_CLIENT_CONNECT_REQUEST;
  static constexpr Type TC_CLIENT_CONNECT_RESPONSE = BaseCommand_Type_TC_CLIENT_CONNECT_RESPONSE;
  static constexpr Type WATCH_TOPIC_LIST = BaseCommand_Type_WATCH_TOPIC_LIST;
  static constexpr Type WATCH_TOPIC_LIST_SUCCESS = BaseCommand_Type_WATCH_TOPIC_LIST_SUCCESS;
  static constexpr Type WATCH_TOPIC_UPDATE = BaseCommand_Type_WATCH_TOPIC_UPDATE;
  static constexpr Type WATCH_TOPIC_LIST_CLOSE = BaseCommand_Type_WATCH_TOPIC_LIST_CLOSE;
  static constexpr Type TOPIC_MIGRATED = BaseCommand_Type_TOPIC_MIGRATED;
  static inline bool Type_IsValid(int value) {
    return BaseCommand_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = BaseCommand_Type_Type_MIN;
  static constexpr Type Type_MAX = BaseCommand_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = BaseCommand_Type_Type_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return BaseCommand_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return BaseCommand_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConnectFieldNumber = 2,
    kConnectedFieldNumber = 3,
    kSubscribeFieldNumber = 4,
    kProducerFieldNumber = 5,
    kSendFieldNumber = 6,
    kSendReceiptFieldNumber = 7,
    kSendErrorFieldNumber = 8,
    kMessageFieldNumber = 9,
    kAckFieldNumber = 10,
    kFlowFieldNumber = 11,
    kUnsubscribeFieldNumber = 12,
    kSuccessFieldNumber = 13,
    kErrorFieldNumber = 14,
    kCloseProducerFieldNumber = 15,
    kCloseConsumerFieldNumber = 16,
    kProducerSuccessFieldNumber = 17,
    kPingFieldNumber = 18,
    kPongFieldNumber = 19,
    kRedeliverUnacknowledgedMessagesFieldNumber = 20,
    kPartitionMetadataFieldNumber = 21,
    kPartitionMetadataResponseFieldNumber = 22,
    kLookupTopicFieldNumber = 23,
    kLookupTopicResponseFieldNumber = 24,
    kConsumerStatsFieldNumber = 25,
    kConsumerStatsResponseFieldNumber = 26,
    kReachedEndOfTopicFieldNumber = 27,
    kSeekFieldNumber = 28,
    kGetLastMessageIdFieldNumber = 29,
    kGetLastMessageIdResponseFieldNumber = 30,
    kActiveConsumerChangeFieldNumber = 31,
    kGetTopicsOfNamespaceFieldNumber = 32,
    kGetTopicsOfNamespaceResponseFieldNumber = 33,
    kGetSchemaFieldNumber = 34,
    kGetSchemaResponseFieldNumber = 35,
    kAuthChallengeFieldNumber = 36,
    kAuthResponseFieldNumber = 37,
    kAckResponseFieldNumber = 38,
    kGetOrCreateSchemaFieldNumber = 39,
    kGetOrCreateSchemaResponseFieldNumber = 40,
    kNewTxnFieldNumber = 50,
    kNewTxnResponseFieldNumber = 51,
    kAddPartitionToTxnFieldNumber = 52,
    kAddPartitionToTxnResponseFieldNumber = 53,
    kAddSubscriptionToTxnFieldNumber = 54,
    kAddSubscriptionToTxnResponseFieldNumber = 55,
    kEndTxnFieldNumber = 56,
    kEndTxnResponseFieldNumber = 57,
    kEndTxnOnPartitionFieldNumber = 58,
    kEndTxnOnPartitionResponseFieldNumber = 59,
    kEndTxnOnSubscriptionFieldNumber = 60,
    kEndTxnOnSubscriptionResponseFieldNumber = 61,
    kTcClientConnectRequestFieldNumber = 62,
    kTcClientConnectResponseFieldNumber = 63,
    kWatchTopicListFieldNumber = 64,
    kWatchTopicListSuccessFieldNumber = 65,
    kWatchTopicUpdateFieldNumber = 66,
    kWatchTopicListCloseFieldNumber = 67,
    kTopicMigratedFieldNumber = 68,
    kTypeFieldNumber = 1,
  };
  // optional .pulsar.proto.CommandConnect connect = 2;
  bool has_connect() const;
  void clear_connect() ;
  const ::pulsar::proto::CommandConnect& connect() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandConnect* release_connect();
  ::pulsar::proto::CommandConnect* mutable_connect();
  void set_allocated_connect(::pulsar::proto::CommandConnect* value);
  void unsafe_arena_set_allocated_connect(::pulsar::proto::CommandConnect* value);
  ::pulsar::proto::CommandConnect* unsafe_arena_release_connect();

  private:
  const ::pulsar::proto::CommandConnect& _internal_connect() const;
  ::pulsar::proto::CommandConnect* _internal_mutable_connect();

  public:
  // optional .pulsar.proto.CommandConnected connected = 3;
  bool has_connected() const;
  void clear_connected() ;
  const ::pulsar::proto::CommandConnected& connected() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandConnected* release_connected();
  ::pulsar::proto::CommandConnected* mutable_connected();
  void set_allocated_connected(::pulsar::proto::CommandConnected* value);
  void unsafe_arena_set_allocated_connected(::pulsar::proto::CommandConnected* value);
  ::pulsar::proto::CommandConnected* unsafe_arena_release_connected();

  private:
  const ::pulsar::proto::CommandConnected& _internal_connected() const;
  ::pulsar::proto::CommandConnected* _internal_mutable_connected();

  public:
  // optional .pulsar.proto.CommandSubscribe subscribe = 4;
  bool has_subscribe() const;
  void clear_subscribe() ;
  const ::pulsar::proto::CommandSubscribe& subscribe() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandSubscribe* release_subscribe();
  ::pulsar::proto::CommandSubscribe* mutable_subscribe();
  void set_allocated_subscribe(::pulsar::proto::CommandSubscribe* value);
  void unsafe_arena_set_allocated_subscribe(::pulsar::proto::CommandSubscribe* value);
  ::pulsar::proto::CommandSubscribe* unsafe_arena_release_subscribe();

  private:
  const ::pulsar::proto::CommandSubscribe& _internal_subscribe() const;
  ::pulsar::proto::CommandSubscribe* _internal_mutable_subscribe();

  public:
  // optional .pulsar.proto.CommandProducer producer = 5;
  bool has_producer() const;
  void clear_producer() ;
  const ::pulsar::proto::CommandProducer& producer() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandProducer* release_producer();
  ::pulsar::proto::CommandProducer* mutable_producer();
  void set_allocated_producer(::pulsar::proto::CommandProducer* value);
  void unsafe_arena_set_allocated_producer(::pulsar::proto::CommandProducer* value);
  ::pulsar::proto::CommandProducer* unsafe_arena_release_producer();

  private:
  const ::pulsar::proto::CommandProducer& _internal_producer() const;
  ::pulsar::proto::CommandProducer* _internal_mutable_producer();

  public:
  // optional .pulsar.proto.CommandSend send = 6;
  bool has_send() const;
  void clear_send() ;
  const ::pulsar::proto::CommandSend& send() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandSend* release_send();
  ::pulsar::proto::CommandSend* mutable_send();
  void set_allocated_send(::pulsar::proto::CommandSend* value);
  void unsafe_arena_set_allocated_send(::pulsar::proto::CommandSend* value);
  ::pulsar::proto::CommandSend* unsafe_arena_release_send();

  private:
  const ::pulsar::proto::CommandSend& _internal_send() const;
  ::pulsar::proto::CommandSend* _internal_mutable_send();

  public:
  // optional .pulsar.proto.CommandSendReceipt send_receipt = 7;
  bool has_send_receipt() const;
  void clear_send_receipt() ;
  const ::pulsar::proto::CommandSendReceipt& send_receipt() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandSendReceipt* release_send_receipt();
  ::pulsar::proto::CommandSendReceipt* mutable_send_receipt();
  void set_allocated_send_receipt(::pulsar::proto::CommandSendReceipt* value);
  void unsafe_arena_set_allocated_send_receipt(::pulsar::proto::CommandSendReceipt* value);
  ::pulsar::proto::CommandSendReceipt* unsafe_arena_release_send_receipt();

  private:
  const ::pulsar::proto::CommandSendReceipt& _internal_send_receipt() const;
  ::pulsar::proto::CommandSendReceipt* _internal_mutable_send_receipt();

  public:
  // optional .pulsar.proto.CommandSendError send_error = 8;
  bool has_send_error() const;
  void clear_send_error() ;
  const ::pulsar::proto::CommandSendError& send_error() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandSendError* release_send_error();
  ::pulsar::proto::CommandSendError* mutable_send_error();
  void set_allocated_send_error(::pulsar::proto::CommandSendError* value);
  void unsafe_arena_set_allocated_send_error(::pulsar::proto::CommandSendError* value);
  ::pulsar::proto::CommandSendError* unsafe_arena_release_send_error();

  private:
  const ::pulsar::proto::CommandSendError& _internal_send_error() const;
  ::pulsar::proto::CommandSendError* _internal_mutable_send_error();

  public:
  // optional .pulsar.proto.CommandMessage message = 9;
  bool has_message() const;
  void clear_message() ;
  const ::pulsar::proto::CommandMessage& message() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandMessage* release_message();
  ::pulsar::proto::CommandMessage* mutable_message();
  void set_allocated_message(::pulsar::proto::CommandMessage* value);
  void unsafe_arena_set_allocated_message(::pulsar::proto::CommandMessage* value);
  ::pulsar::proto::CommandMessage* unsafe_arena_release_message();

  private:
  const ::pulsar::proto::CommandMessage& _internal_message() const;
  ::pulsar::proto::CommandMessage* _internal_mutable_message();

  public:
  // optional .pulsar.proto.CommandAck ack = 10;
  bool has_ack() const;
  void clear_ack() ;
  const ::pulsar::proto::CommandAck& ack() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandAck* release_ack();
  ::pulsar::proto::CommandAck* mutable_ack();
  void set_allocated_ack(::pulsar::proto::CommandAck* value);
  void unsafe_arena_set_allocated_ack(::pulsar::proto::CommandAck* value);
  ::pulsar::proto::CommandAck* unsafe_arena_release_ack();

  private:
  const ::pulsar::proto::CommandAck& _internal_ack() const;
  ::pulsar::proto::CommandAck* _internal_mutable_ack();

  public:
  // optional .pulsar.proto.CommandFlow flow = 11;
  bool has_flow() const;
  void clear_flow() ;
  const ::pulsar::proto::CommandFlow& flow() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandFlow* release_flow();
  ::pulsar::proto::CommandFlow* mutable_flow();
  void set_allocated_flow(::pulsar::proto::CommandFlow* value);
  void unsafe_arena_set_allocated_flow(::pulsar::proto::CommandFlow* value);
  ::pulsar::proto::CommandFlow* unsafe_arena_release_flow();

  private:
  const ::pulsar::proto::CommandFlow& _internal_flow() const;
  ::pulsar::proto::CommandFlow* _internal_mutable_flow();

  public:
  // optional .pulsar.proto.CommandUnsubscribe unsubscribe = 12;
  bool has_unsubscribe() const;
  void clear_unsubscribe() ;
  const ::pulsar::proto::CommandUnsubscribe& unsubscribe() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandUnsubscribe* release_unsubscribe();
  ::pulsar::proto::CommandUnsubscribe* mutable_unsubscribe();
  void set_allocated_unsubscribe(::pulsar::proto::CommandUnsubscribe* value);
  void unsafe_arena_set_allocated_unsubscribe(::pulsar::proto::CommandUnsubscribe* value);
  ::pulsar::proto::CommandUnsubscribe* unsafe_arena_release_unsubscribe();

  private:
  const ::pulsar::proto::CommandUnsubscribe& _internal_unsubscribe() const;
  ::pulsar::proto::CommandUnsubscribe* _internal_mutable_unsubscribe();

  public:
  // optional .pulsar.proto.CommandSuccess success = 13;
  bool has_success() const;
  void clear_success() ;
  const ::pulsar::proto::CommandSuccess& success() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandSuccess* release_success();
  ::pulsar::proto::CommandSuccess* mutable_success();
  void set_allocated_success(::pulsar::proto::CommandSuccess* value);
  void unsafe_arena_set_allocated_success(::pulsar::proto::CommandSuccess* value);
  ::pulsar::proto::CommandSuccess* unsafe_arena_release_success();

  private:
  const ::pulsar::proto::CommandSuccess& _internal_success() const;
  ::pulsar::proto::CommandSuccess* _internal_mutable_success();

  public:
  // optional .pulsar.proto.CommandError error = 14;
  bool has_error() const;
  void clear_error() ;
  const ::pulsar::proto::CommandError& error() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandError* release_error();
  ::pulsar::proto::CommandError* mutable_error();
  void set_allocated_error(::pulsar::proto::CommandError* value);
  void unsafe_arena_set_allocated_error(::pulsar::proto::CommandError* value);
  ::pulsar::proto::CommandError* unsafe_arena_release_error();

  private:
  const ::pulsar::proto::CommandError& _internal_error() const;
  ::pulsar::proto::CommandError* _internal_mutable_error();

  public:
  // optional .pulsar.proto.CommandCloseProducer close_producer = 15;
  bool has_close_producer() const;
  void clear_close_producer() ;
  const ::pulsar::proto::CommandCloseProducer& close_producer() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandCloseProducer* release_close_producer();
  ::pulsar::proto::CommandCloseProducer* mutable_close_producer();
  void set_allocated_close_producer(::pulsar::proto::CommandCloseProducer* value);
  void unsafe_arena_set_allocated_close_producer(::pulsar::proto::CommandCloseProducer* value);
  ::pulsar::proto::CommandCloseProducer* unsafe_arena_release_close_producer();

  private:
  const ::pulsar::proto::CommandCloseProducer& _internal_close_producer() const;
  ::pulsar::proto::CommandCloseProducer* _internal_mutable_close_producer();

  public:
  // optional .pulsar.proto.CommandCloseConsumer close_consumer = 16;
  bool has_close_consumer() const;
  void clear_close_consumer() ;
  const ::pulsar::proto::CommandCloseConsumer& close_consumer() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandCloseConsumer* release_close_consumer();
  ::pulsar::proto::CommandCloseConsumer* mutable_close_consumer();
  void set_allocated_close_consumer(::pulsar::proto::CommandCloseConsumer* value);
  void unsafe_arena_set_allocated_close_consumer(::pulsar::proto::CommandCloseConsumer* value);
  ::pulsar::proto::CommandCloseConsumer* unsafe_arena_release_close_consumer();

  private:
  const ::pulsar::proto::CommandCloseConsumer& _internal_close_consumer() const;
  ::pulsar::proto::CommandCloseConsumer* _internal_mutable_close_consumer();

  public:
  // optional .pulsar.proto.CommandProducerSuccess producer_success = 17;
  bool has_producer_success() const;
  void clear_producer_success() ;
  const ::pulsar::proto::CommandProducerSuccess& producer_success() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandProducerSuccess* release_producer_success();
  ::pulsar::proto::CommandProducerSuccess* mutable_producer_success();
  void set_allocated_producer_success(::pulsar::proto::CommandProducerSuccess* value);
  void unsafe_arena_set_allocated_producer_success(::pulsar::proto::CommandProducerSuccess* value);
  ::pulsar::proto::CommandProducerSuccess* unsafe_arena_release_producer_success();

  private:
  const ::pulsar::proto::CommandProducerSuccess& _internal_producer_success() const;
  ::pulsar::proto::CommandProducerSuccess* _internal_mutable_producer_success();

  public:
  // optional .pulsar.proto.CommandPing ping = 18;
  bool has_ping() const;
  void clear_ping() ;
  const ::pulsar::proto::CommandPing& ping() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandPing* release_ping();
  ::pulsar::proto::CommandPing* mutable_ping();
  void set_allocated_ping(::pulsar::proto::CommandPing* value);
  void unsafe_arena_set_allocated_ping(::pulsar::proto::CommandPing* value);
  ::pulsar::proto::CommandPing* unsafe_arena_release_ping();

  private:
  const ::pulsar::proto::CommandPing& _internal_ping() const;
  ::pulsar::proto::CommandPing* _internal_mutable_ping();

  public:
  // optional .pulsar.proto.CommandPong pong = 19;
  bool has_pong() const;
  void clear_pong() ;
  const ::pulsar::proto::CommandPong& pong() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandPong* release_pong();
  ::pulsar::proto::CommandPong* mutable_pong();
  void set_allocated_pong(::pulsar::proto::CommandPong* value);
  void unsafe_arena_set_allocated_pong(::pulsar::proto::CommandPong* value);
  ::pulsar::proto::CommandPong* unsafe_arena_release_pong();

  private:
  const ::pulsar::proto::CommandPong& _internal_pong() const;
  ::pulsar::proto::CommandPong* _internal_mutable_pong();

  public:
  // optional .pulsar.proto.CommandRedeliverUnacknowledgedMessages redeliverUnacknowledgedMessages = 20;
  bool has_redeliverunacknowledgedmessages() const;
  void clear_redeliverunacknowledgedmessages() ;
  const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages& redeliverunacknowledgedmessages() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* release_redeliverunacknowledgedmessages();
  ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* mutable_redeliverunacknowledgedmessages();
  void set_allocated_redeliverunacknowledgedmessages(::pulsar::proto::CommandRedeliverUnacknowledgedMessages* value);
  void unsafe_arena_set_allocated_redeliverunacknowledgedmessages(::pulsar::proto::CommandRedeliverUnacknowledgedMessages* value);
  ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* unsafe_arena_release_redeliverunacknowledgedmessages();

  private:
  const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages& _internal_redeliverunacknowledgedmessages() const;
  ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* _internal_mutable_redeliverunacknowledgedmessages();

  public:
  // optional .pulsar.proto.CommandPartitionedTopicMetadata partitionMetadata = 21;
  bool has_partitionmetadata() const;
  void clear_partitionmetadata() ;
  const ::pulsar::proto::CommandPartitionedTopicMetadata& partitionmetadata() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandPartitionedTopicMetadata* release_partitionmetadata();
  ::pulsar::proto::CommandPartitionedTopicMetadata* mutable_partitionmetadata();
  void set_allocated_partitionmetadata(::pulsar::proto::CommandPartitionedTopicMetadata* value);
  void unsafe_arena_set_allocated_partitionmetadata(::pulsar::proto::CommandPartitionedTopicMetadata* value);
  ::pulsar::proto::CommandPartitionedTopicMetadata* unsafe_arena_release_partitionmetadata();

  private:
  const ::pulsar::proto::CommandPartitionedTopicMetadata& _internal_partitionmetadata() const;
  ::pulsar::proto::CommandPartitionedTopicMetadata* _internal_mutable_partitionmetadata();

  public:
  // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse partitionMetadataResponse = 22;
  bool has_partitionmetadataresponse() const;
  void clear_partitionmetadataresponse() ;
  const ::pulsar::proto::CommandPartitionedTopicMetadataResponse& partitionmetadataresponse() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandPartitionedTopicMetadataResponse* release_partitionmetadataresponse();
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse* mutable_partitionmetadataresponse();
  void set_allocated_partitionmetadataresponse(::pulsar::proto::CommandPartitionedTopicMetadataResponse* value);
  void unsafe_arena_set_allocated_partitionmetadataresponse(::pulsar::proto::CommandPartitionedTopicMetadataResponse* value);
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse* unsafe_arena_release_partitionmetadataresponse();

  private:
  const ::pulsar::proto::CommandPartitionedTopicMetadataResponse& _internal_partitionmetadataresponse() const;
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse* _internal_mutable_partitionmetadataresponse();

  public:
  // optional .pulsar.proto.CommandLookupTopic lookupTopic = 23;
  bool has_lookuptopic() const;
  void clear_lookuptopic() ;
  const ::pulsar::proto::CommandLookupTopic& lookuptopic() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandLookupTopic* release_lookuptopic();
  ::pulsar::proto::CommandLookupTopic* mutable_lookuptopic();
  void set_allocated_lookuptopic(::pulsar::proto::CommandLookupTopic* value);
  void unsafe_arena_set_allocated_lookuptopic(::pulsar::proto::CommandLookupTopic* value);
  ::pulsar::proto::CommandLookupTopic* unsafe_arena_release_lookuptopic();

  private:
  const ::pulsar::proto::CommandLookupTopic& _internal_lookuptopic() const;
  ::pulsar::proto::CommandLookupTopic* _internal_mutable_lookuptopic();

  public:
  // optional .pulsar.proto.CommandLookupTopicResponse lookupTopicResponse = 24;
  bool has_lookuptopicresponse() const;
  void clear_lookuptopicresponse() ;
  const ::pulsar::proto::CommandLookupTopicResponse& lookuptopicresponse() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandLookupTopicResponse* release_lookuptopicresponse();
  ::pulsar::proto::CommandLookupTopicResponse* mutable_lookuptopicresponse();
  void set_allocated_lookuptopicresponse(::pulsar::proto::CommandLookupTopicResponse* value);
  void unsafe_arena_set_allocated_lookuptopicresponse(::pulsar::proto::CommandLookupTopicResponse* value);
  ::pulsar::proto::CommandLookupTopicResponse* unsafe_arena_release_lookuptopicresponse();

  private:
  const ::pulsar::proto::CommandLookupTopicResponse& _internal_lookuptopicresponse() const;
  ::pulsar::proto::CommandLookupTopicResponse* _internal_mutable_lookuptopicresponse();

  public:
  // optional .pulsar.proto.CommandConsumerStats consumerStats = 25;
  bool has_consumerstats() const;
  void clear_consumerstats() ;
  const ::pulsar::proto::CommandConsumerStats& consumerstats() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandConsumerStats* release_consumerstats();
  ::pulsar::proto::CommandConsumerStats* mutable_consumerstats();
  void set_allocated_consumerstats(::pulsar::proto::CommandConsumerStats* value);
  void unsafe_arena_set_allocated_consumerstats(::pulsar::proto::CommandConsumerStats* value);
  ::pulsar::proto::CommandConsumerStats* unsafe_arena_release_consumerstats();

  private:
  const ::pulsar::proto::CommandConsumerStats& _internal_consumerstats() const;
  ::pulsar::proto::CommandConsumerStats* _internal_mutable_consumerstats();

  public:
  // optional .pulsar.proto.CommandConsumerStatsResponse consumerStatsResponse = 26;
  bool has_consumerstatsresponse() const;
  void clear_consumerstatsresponse() ;
  const ::pulsar::proto::CommandConsumerStatsResponse& consumerstatsresponse() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandConsumerStatsResponse* release_consumerstatsresponse();
  ::pulsar::proto::CommandConsumerStatsResponse* mutable_consumerstatsresponse();
  void set_allocated_consumerstatsresponse(::pulsar::proto::CommandConsumerStatsResponse* value);
  void unsafe_arena_set_allocated_consumerstatsresponse(::pulsar::proto::CommandConsumerStatsResponse* value);
  ::pulsar::proto::CommandConsumerStatsResponse* unsafe_arena_release_consumerstatsresponse();

  private:
  const ::pulsar::proto::CommandConsumerStatsResponse& _internal_consumerstatsresponse() const;
  ::pulsar::proto::CommandConsumerStatsResponse* _internal_mutable_consumerstatsresponse();

  public:
  // optional .pulsar.proto.CommandReachedEndOfTopic reachedEndOfTopic = 27;
  bool has_reachedendoftopic() const;
  void clear_reachedendoftopic() ;
  const ::pulsar::proto::CommandReachedEndOfTopic& reachedendoftopic() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandReachedEndOfTopic* release_reachedendoftopic();
  ::pulsar::proto::CommandReachedEndOfTopic* mutable_reachedendoftopic();
  void set_allocated_reachedendoftopic(::pulsar::proto::CommandReachedEndOfTopic* value);
  void unsafe_arena_set_allocated_reachedendoftopic(::pulsar::proto::CommandReachedEndOfTopic* value);
  ::pulsar::proto::CommandReachedEndOfTopic* unsafe_arena_release_reachedendoftopic();

  private:
  const ::pulsar::proto::CommandReachedEndOfTopic& _internal_reachedendoftopic() const;
  ::pulsar::proto::CommandReachedEndOfTopic* _internal_mutable_reachedendoftopic();

  public:
  // optional .pulsar.proto.CommandSeek seek = 28;
  bool has_seek() const;
  void clear_seek() ;
  const ::pulsar::proto::CommandSeek& seek() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandSeek* release_seek();
  ::pulsar::proto::CommandSeek* mutable_seek();
  void set_allocated_seek(::pulsar::proto::CommandSeek* value);
  void unsafe_arena_set_allocated_seek(::pulsar::proto::CommandSeek* value);
  ::pulsar::proto::CommandSeek* unsafe_arena_release_seek();

  private:
  const ::pulsar::proto::CommandSeek& _internal_seek() const;
  ::pulsar::proto::CommandSeek* _internal_mutable_seek();

  public:
  // optional .pulsar.proto.CommandGetLastMessageId getLastMessageId = 29;
  bool has_getlastmessageid() const;
  void clear_getlastmessageid() ;
  const ::pulsar::proto::CommandGetLastMessageId& getlastmessageid() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandGetLastMessageId* release_getlastmessageid();
  ::pulsar::proto::CommandGetLastMessageId* mutable_getlastmessageid();
  void set_allocated_getlastmessageid(::pulsar::proto::CommandGetLastMessageId* value);
  void unsafe_arena_set_allocated_getlastmessageid(::pulsar::proto::CommandGetLastMessageId* value);
  ::pulsar::proto::CommandGetLastMessageId* unsafe_arena_release_getlastmessageid();

  private:
  const ::pulsar::proto::CommandGetLastMessageId& _internal_getlastmessageid() const;
  ::pulsar::proto::CommandGetLastMessageId* _internal_mutable_getlastmessageid();

  public:
  // optional .pulsar.proto.CommandGetLastMessageIdResponse getLastMessageIdResponse = 30;
  bool has_getlastmessageidresponse() const;
  void clear_getlastmessageidresponse() ;
  const ::pulsar::proto::CommandGetLastMessageIdResponse& getlastmessageidresponse() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandGetLastMessageIdResponse* release_getlastmessageidresponse();
  ::pulsar::proto::CommandGetLastMessageIdResponse* mutable_getlastmessageidresponse();
  void set_allocated_getlastmessageidresponse(::pulsar::proto::CommandGetLastMessageIdResponse* value);
  void unsafe_arena_set_allocated_getlastmessageidresponse(::pulsar::proto::CommandGetLastMessageIdResponse* value);
  ::pulsar::proto::CommandGetLastMessageIdResponse* unsafe_arena_release_getlastmessageidresponse();

  private:
  const ::pulsar::proto::CommandGetLastMessageIdResponse& _internal_getlastmessageidresponse() const;
  ::pulsar::proto::CommandGetLastMessageIdResponse* _internal_mutable_getlastmessageidresponse();

  public:
  // optional .pulsar.proto.CommandActiveConsumerChange active_consumer_change = 31;
  bool has_active_consumer_change() const;
  void clear_active_consumer_change() ;
  const ::pulsar::proto::CommandActiveConsumerChange& active_consumer_change() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandActiveConsumerChange* release_active_consumer_change();
  ::pulsar::proto::CommandActiveConsumerChange* mutable_active_consumer_change();
  void set_allocated_active_consumer_change(::pulsar::proto::CommandActiveConsumerChange* value);
  void unsafe_arena_set_allocated_active_consumer_change(::pulsar::proto::CommandActiveConsumerChange* value);
  ::pulsar::proto::CommandActiveConsumerChange* unsafe_arena_release_active_consumer_change();

  private:
  const ::pulsar::proto::CommandActiveConsumerChange& _internal_active_consumer_change() const;
  ::pulsar::proto::CommandActiveConsumerChange* _internal_mutable_active_consumer_change();

  public:
  // optional .pulsar.proto.CommandGetTopicsOfNamespace getTopicsOfNamespace = 32;
  bool has_gettopicsofnamespace() const;
  void clear_gettopicsofnamespace() ;
  const ::pulsar::proto::CommandGetTopicsOfNamespace& gettopicsofnamespace() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandGetTopicsOfNamespace* release_gettopicsofnamespace();
  ::pulsar::proto::CommandGetTopicsOfNamespace* mutable_gettopicsofnamespace();
  void set_allocated_gettopicsofnamespace(::pulsar::proto::CommandGetTopicsOfNamespace* value);
  void unsafe_arena_set_allocated_gettopicsofnamespace(::pulsar::proto::CommandGetTopicsOfNamespace* value);
  ::pulsar::proto::CommandGetTopicsOfNamespace* unsafe_arena_release_gettopicsofnamespace();

  private:
  const ::pulsar::proto::CommandGetTopicsOfNamespace& _internal_gettopicsofnamespace() const;
  ::pulsar::proto::CommandGetTopicsOfNamespace* _internal_mutable_gettopicsofnamespace();

  public:
  // optional .pulsar.proto.CommandGetTopicsOfNamespaceResponse getTopicsOfNamespaceResponse = 33;
  bool has_gettopicsofnamespaceresponse() const;
  void clear_gettopicsofnamespaceresponse() ;
  const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse& gettopicsofnamespaceresponse() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* release_gettopicsofnamespaceresponse();
  ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* mutable_gettopicsofnamespaceresponse();
  void set_allocated_gettopicsofnamespaceresponse(::pulsar::proto::CommandGetTopicsOfNamespaceResponse* value);
  void unsafe_arena_set_allocated_gettopicsofnamespaceresponse(::pulsar::proto::CommandGetTopicsOfNamespaceResponse* value);
  ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* unsafe_arena_release_gettopicsofnamespaceresponse();

  private:
  const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse& _internal_gettopicsofnamespaceresponse() const;
  ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* _internal_mutable_gettopicsofnamespaceresponse();

  public:
  // optional .pulsar.proto.CommandGetSchema getSchema = 34;
  bool has_getschema() const;
  void clear_getschema() ;
  const ::pulsar::proto::CommandGetSchema& getschema() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandGetSchema* release_getschema();
  ::pulsar::proto::CommandGetSchema* mutable_getschema();
  void set_allocated_getschema(::pulsar::proto::CommandGetSchema* value);
  void unsafe_arena_set_allocated_getschema(::pulsar::proto::CommandGetSchema* value);
  ::pulsar::proto::CommandGetSchema* unsafe_arena_release_getschema();

  private:
  const ::pulsar::proto::CommandGetSchema& _internal_getschema() const;
  ::pulsar::proto::CommandGetSchema* _internal_mutable_getschema();

  public:
  // optional .pulsar.proto.CommandGetSchemaResponse getSchemaResponse = 35;
  bool has_getschemaresponse() const;
  void clear_getschemaresponse() ;
  const ::pulsar::proto::CommandGetSchemaResponse& getschemaresponse() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandGetSchemaResponse* release_getschemaresponse();
  ::pulsar::proto::CommandGetSchemaResponse* mutable_getschemaresponse();
  void set_allocated_getschemaresponse(::pulsar::proto::CommandGetSchemaResponse* value);
  void unsafe_arena_set_allocated_getschemaresponse(::pulsar::proto::CommandGetSchemaResponse* value);
  ::pulsar::proto::CommandGetSchemaResponse* unsafe_arena_release_getschemaresponse();

  private:
  const ::pulsar::proto::CommandGetSchemaResponse& _internal_getschemaresponse() const;
  ::pulsar::proto::CommandGetSchemaResponse* _internal_mutable_getschemaresponse();

  public:
  // optional .pulsar.proto.CommandAuthChallenge authChallenge = 36;
  bool has_authchallenge() const;
  void clear_authchallenge() ;
  const ::pulsar::proto::CommandAuthChallenge& authchallenge() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandAuthChallenge* release_authchallenge();
  ::pulsar::proto::CommandAuthChallenge* mutable_authchallenge();
  void set_allocated_authchallenge(::pulsar::proto::CommandAuthChallenge* value);
  void unsafe_arena_set_allocated_authchallenge(::pulsar::proto::CommandAuthChallenge* value);
  ::pulsar::proto::CommandAuthChallenge* unsafe_arena_release_authchallenge();

  private:
  const ::pulsar::proto::CommandAuthChallenge& _internal_authchallenge() const;
  ::pulsar::proto::CommandAuthChallenge* _internal_mutable_authchallenge();

  public:
  // optional .pulsar.proto.CommandAuthResponse authResponse = 37;
  bool has_authresponse() const;
  void clear_authresponse() ;
  const ::pulsar::proto::CommandAuthResponse& authresponse() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandAuthResponse* release_authresponse();
  ::pulsar::proto::CommandAuthResponse* mutable_authresponse();
  void set_allocated_authresponse(::pulsar::proto::CommandAuthResponse* value);
  void unsafe_arena_set_allocated_authresponse(::pulsar::proto::CommandAuthResponse* value);
  ::pulsar::proto::CommandAuthResponse* unsafe_arena_release_authresponse();

  private:
  const ::pulsar::proto::CommandAuthResponse& _internal_authresponse() const;
  ::pulsar::proto::CommandAuthResponse* _internal_mutable_authresponse();

  public:
  // optional .pulsar.proto.CommandAckResponse ackResponse = 38;
  bool has_ackresponse() const;
  void clear_ackresponse() ;
  const ::pulsar::proto::CommandAckResponse& ackresponse() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandAckResponse* release_ackresponse();
  ::pulsar::proto::CommandAckResponse* mutable_ackresponse();
  void set_allocated_ackresponse(::pulsar::proto::CommandAckResponse* value);
  void unsafe_arena_set_allocated_ackresponse(::pulsar::proto::CommandAckResponse* value);
  ::pulsar::proto::CommandAckResponse* unsafe_arena_release_ackresponse();

  private:
  const ::pulsar::proto::CommandAckResponse& _internal_ackresponse() const;
  ::pulsar::proto::CommandAckResponse* _internal_mutable_ackresponse();

  public:
  // optional .pulsar.proto.CommandGetOrCreateSchema getOrCreateSchema = 39;
  bool has_getorcreateschema() const;
  void clear_getorcreateschema() ;
  const ::pulsar::proto::CommandGetOrCreateSchema& getorcreateschema() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandGetOrCreateSchema* release_getorcreateschema();
  ::pulsar::proto::CommandGetOrCreateSchema* mutable_getorcreateschema();
  void set_allocated_getorcreateschema(::pulsar::proto::CommandGetOrCreateSchema* value);
  void unsafe_arena_set_allocated_getorcreateschema(::pulsar::proto::CommandGetOrCreateSchema* value);
  ::pulsar::proto::CommandGetOrCreateSchema* unsafe_arena_release_getorcreateschema();

  private:
  const ::pulsar::proto::CommandGetOrCreateSchema& _internal_getorcreateschema() const;
  ::pulsar::proto::CommandGetOrCreateSchema* _internal_mutable_getorcreateschema();

  public:
  // optional .pulsar.proto.CommandGetOrCreateSchemaResponse getOrCreateSchemaResponse = 40;
  bool has_getorcreateschemaresponse() const;
  void clear_getorcreateschemaresponse() ;
  const ::pulsar::proto::CommandGetOrCreateSchemaResponse& getorcreateschemaresponse() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandGetOrCreateSchemaResponse* release_getorcreateschemaresponse();
  ::pulsar::proto::CommandGetOrCreateSchemaResponse* mutable_getorcreateschemaresponse();
  void set_allocated_getorcreateschemaresponse(::pulsar::proto::CommandGetOrCreateSchemaResponse* value);
  void unsafe_arena_set_allocated_getorcreateschemaresponse(::pulsar::proto::CommandGetOrCreateSchemaResponse* value);
  ::pulsar::proto::CommandGetOrCreateSchemaResponse* unsafe_arena_release_getorcreateschemaresponse();

  private:
  const ::pulsar::proto::CommandGetOrCreateSchemaResponse& _internal_getorcreateschemaresponse() const;
  ::pulsar::proto::CommandGetOrCreateSchemaResponse* _internal_mutable_getorcreateschemaresponse();

  public:
  // optional .pulsar.proto.CommandNewTxn newTxn = 50;
  bool has_newtxn() const;
  void clear_newtxn() ;
  const ::pulsar::proto::CommandNewTxn& newtxn() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandNewTxn* release_newtxn();
  ::pulsar::proto::CommandNewTxn* mutable_newtxn();
  void set_allocated_newtxn(::pulsar::proto::CommandNewTxn* value);
  void unsafe_arena_set_allocated_newtxn(::pulsar::proto::CommandNewTxn* value);
  ::pulsar::proto::CommandNewTxn* unsafe_arena_release_newtxn();

  private:
  const ::pulsar::proto::CommandNewTxn& _internal_newtxn() const;
  ::pulsar::proto::CommandNewTxn* _internal_mutable_newtxn();

  public:
  // optional .pulsar.proto.CommandNewTxnResponse newTxnResponse = 51;
  bool has_newtxnresponse() const;
  void clear_newtxnresponse() ;
  const ::pulsar::proto::CommandNewTxnResponse& newtxnresponse() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandNewTxnResponse* release_newtxnresponse();
  ::pulsar::proto::CommandNewTxnResponse* mutable_newtxnresponse();
  void set_allocated_newtxnresponse(::pulsar::proto::CommandNewTxnResponse* value);
  void unsafe_arena_set_allocated_newtxnresponse(::pulsar::proto::CommandNewTxnResponse* value);
  ::pulsar::proto::CommandNewTxnResponse* unsafe_arena_release_newtxnresponse();

  private:
  const ::pulsar::proto::CommandNewTxnResponse& _internal_newtxnresponse() const;
  ::pulsar::proto::CommandNewTxnResponse* _internal_mutable_newtxnresponse();

  public:
  // optional .pulsar.proto.CommandAddPartitionToTxn addPartitionToTxn = 52;
  bool has_addpartitiontotxn() const;
  void clear_addpartitiontotxn() ;
  const ::pulsar::proto::CommandAddPartitionToTxn& addpartitiontotxn() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandAddPartitionToTxn* release_addpartitiontotxn();
  ::pulsar::proto::CommandAddPartitionToTxn* mutable_addpartitiontotxn();
  void set_allocated_addpartitiontotxn(::pulsar::proto::CommandAddPartitionToTxn* value);
  void unsafe_arena_set_allocated_addpartitiontotxn(::pulsar::proto::CommandAddPartitionToTxn* value);
  ::pulsar::proto::CommandAddPartitionToTxn* unsafe_arena_release_addpartitiontotxn();

  private:
  const ::pulsar::proto::CommandAddPartitionToTxn& _internal_addpartitiontotxn() const;
  ::pulsar::proto::CommandAddPartitionToTxn* _internal_mutable_addpartitiontotxn();

  public:
  // optional .pulsar.proto.CommandAddPartitionToTxnResponse addPartitionToTxnResponse = 53;
  bool has_addpartitiontotxnresponse() const;
  void clear_addpartitiontotxnresponse() ;
  const ::pulsar::proto::CommandAddPartitionToTxnResponse& addpartitiontotxnresponse() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandAddPartitionToTxnResponse* release_addpartitiontotxnresponse();
  ::pulsar::proto::CommandAddPartitionToTxnResponse* mutable_addpartitiontotxnresponse();
  void set_allocated_addpartitiontotxnresponse(::pulsar::proto::CommandAddPartitionToTxnResponse* value);
  void unsafe_arena_set_allocated_addpartitiontotxnresponse(::pulsar::proto::CommandAddPartitionToTxnResponse* value);
  ::pulsar::proto::CommandAddPartitionToTxnResponse* unsafe_arena_release_addpartitiontotxnresponse();

  private:
  const ::pulsar::proto::CommandAddPartitionToTxnResponse& _internal_addpartitiontotxnresponse() const;
  ::pulsar::proto::CommandAddPartitionToTxnResponse* _internal_mutable_addpartitiontotxnresponse();

  public:
  // optional .pulsar.proto.CommandAddSubscriptionToTxn addSubscriptionToTxn = 54;
  bool has_addsubscriptiontotxn() const;
  void clear_addsubscriptiontotxn() ;
  const ::pulsar::proto::CommandAddSubscriptionToTxn& addsubscriptiontotxn() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandAddSubscriptionToTxn* release_addsubscriptiontotxn();
  ::pulsar::proto::CommandAddSubscriptionToTxn* mutable_addsubscriptiontotxn();
  void set_allocated_addsubscriptiontotxn(::pulsar::proto::CommandAddSubscriptionToTxn* value);
  void unsafe_arena_set_allocated_addsubscriptiontotxn(::pulsar::proto::CommandAddSubscriptionToTxn* value);
  ::pulsar::proto::CommandAddSubscriptionToTxn* unsafe_arena_release_addsubscriptiontotxn();

  private:
  const ::pulsar::proto::CommandAddSubscriptionToTxn& _internal_addsubscriptiontotxn() const;
  ::pulsar::proto::CommandAddSubscriptionToTxn* _internal_mutable_addsubscriptiontotxn();

  public:
  // optional .pulsar.proto.CommandAddSubscriptionToTxnResponse addSubscriptionToTxnResponse = 55;
  bool has_addsubscriptiontotxnresponse() const;
  void clear_addsubscriptiontotxnresponse() ;
  const ::pulsar::proto::CommandAddSubscriptionToTxnResponse& addsubscriptiontotxnresponse() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandAddSubscriptionToTxnResponse* release_addsubscriptiontotxnresponse();
  ::pulsar::proto::CommandAddSubscriptionToTxnResponse* mutable_addsubscriptiontotxnresponse();
  void set_allocated_addsubscriptiontotxnresponse(::pulsar::proto::CommandAddSubscriptionToTxnResponse* value);
  void unsafe_arena_set_allocated_addsubscriptiontotxnresponse(::pulsar::proto::CommandAddSubscriptionToTxnResponse* value);
  ::pulsar::proto::CommandAddSubscriptionToTxnResponse* unsafe_arena_release_addsubscriptiontotxnresponse();

  private:
  const ::pulsar::proto::CommandAddSubscriptionToTxnResponse& _internal_addsubscriptiontotxnresponse() const;
  ::pulsar::proto::CommandAddSubscriptionToTxnResponse* _internal_mutable_addsubscriptiontotxnresponse();

  public:
  // optional .pulsar.proto.CommandEndTxn endTxn = 56;
  bool has_endtxn() const;
  void clear_endtxn() ;
  const ::pulsar::proto::CommandEndTxn& endtxn() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandEndTxn* release_endtxn();
  ::pulsar::proto::CommandEndTxn* mutable_endtxn();
  void set_allocated_endtxn(::pulsar::proto::CommandEndTxn* value);
  void unsafe_arena_set_allocated_endtxn(::pulsar::proto::CommandEndTxn* value);
  ::pulsar::proto::CommandEndTxn* unsafe_arena_release_endtxn();

  private:
  const ::pulsar::proto::CommandEndTxn& _internal_endtxn() const;
  ::pulsar::proto::CommandEndTxn* _internal_mutable_endtxn();

  public:
  // optional .pulsar.proto.CommandEndTxnResponse endTxnResponse = 57;
  bool has_endtxnresponse() const;
  void clear_endtxnresponse() ;
  const ::pulsar::proto::CommandEndTxnResponse& endtxnresponse() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandEndTxnResponse* release_endtxnresponse();
  ::pulsar::proto::CommandEndTxnResponse* mutable_endtxnresponse();
  void set_allocated_endtxnresponse(::pulsar::proto::CommandEndTxnResponse* value);
  void unsafe_arena_set_allocated_endtxnresponse(::pulsar::proto::CommandEndTxnResponse* value);
  ::pulsar::proto::CommandEndTxnResponse* unsafe_arena_release_endtxnresponse();

  private:
  const ::pulsar::proto::CommandEndTxnResponse& _internal_endtxnresponse() const;
  ::pulsar::proto::CommandEndTxnResponse* _internal_mutable_endtxnresponse();

  public:
  // optional .pulsar.proto.CommandEndTxnOnPartition endTxnOnPartition = 58;
  bool has_endtxnonpartition() const;
  void clear_endtxnonpartition() ;
  const ::pulsar::proto::CommandEndTxnOnPartition& endtxnonpartition() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandEndTxnOnPartition* release_endtxnonpartition();
  ::pulsar::proto::CommandEndTxnOnPartition* mutable_endtxnonpartition();
  void set_allocated_endtxnonpartition(::pulsar::proto::CommandEndTxnOnPartition* value);
  void unsafe_arena_set_allocated_endtxnonpartition(::pulsar::proto::CommandEndTxnOnPartition* value);
  ::pulsar::proto::CommandEndTxnOnPartition* unsafe_arena_release_endtxnonpartition();

  private:
  const ::pulsar::proto::CommandEndTxnOnPartition& _internal_endtxnonpartition() const;
  ::pulsar::proto::CommandEndTxnOnPartition* _internal_mutable_endtxnonpartition();

  public:
  // optional .pulsar.proto.CommandEndTxnOnPartitionResponse endTxnOnPartitionResponse = 59;
  bool has_endtxnonpartitionresponse() const;
  void clear_endtxnonpartitionresponse() ;
  const ::pulsar::proto::CommandEndTxnOnPartitionResponse& endtxnonpartitionresponse() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandEndTxnOnPartitionResponse* release_endtxnonpartitionresponse();
  ::pulsar::proto::CommandEndTxnOnPartitionResponse* mutable_endtxnonpartitionresponse();
  void set_allocated_endtxnonpartitionresponse(::pulsar::proto::CommandEndTxnOnPartitionResponse* value);
  void unsafe_arena_set_allocated_endtxnonpartitionresponse(::pulsar::proto::CommandEndTxnOnPartitionResponse* value);
  ::pulsar::proto::CommandEndTxnOnPartitionResponse* unsafe_arena_release_endtxnonpartitionresponse();

  private:
  const ::pulsar::proto::CommandEndTxnOnPartitionResponse& _internal_endtxnonpartitionresponse() const;
  ::pulsar::proto::CommandEndTxnOnPartitionResponse* _internal_mutable_endtxnonpartitionresponse();

  public:
  // optional .pulsar.proto.CommandEndTxnOnSubscription endTxnOnSubscription = 60;
  bool has_endtxnonsubscription() const;
  void clear_endtxnonsubscription() ;
  const ::pulsar::proto::CommandEndTxnOnSubscription& endtxnonsubscription() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandEndTxnOnSubscription* release_endtxnonsubscription();
  ::pulsar::proto::CommandEndTxnOnSubscription* mutable_endtxnonsubscription();
  void set_allocated_endtxnonsubscription(::pulsar::proto::CommandEndTxnOnSubscription* value);
  void unsafe_arena_set_allocated_endtxnonsubscription(::pulsar::proto::CommandEndTxnOnSubscription* value);
  ::pulsar::proto::CommandEndTxnOnSubscription* unsafe_arena_release_endtxnonsubscription();

  private:
  const ::pulsar::proto::CommandEndTxnOnSubscription& _internal_endtxnonsubscription() const;
  ::pulsar::proto::CommandEndTxnOnSubscription* _internal_mutable_endtxnonsubscription();

  public:
  // optional .pulsar.proto.CommandEndTxnOnSubscriptionResponse endTxnOnSubscriptionResponse = 61;
  bool has_endtxnonsubscriptionresponse() const;
  void clear_endtxnonsubscriptionresponse() ;
  const ::pulsar::proto::CommandEndTxnOnSubscriptionResponse& endtxnonsubscriptionresponse() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* release_endtxnonsubscriptionresponse();
  ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* mutable_endtxnonsubscriptionresponse();
  void set_allocated_endtxnonsubscriptionresponse(::pulsar::proto::CommandEndTxnOnSubscriptionResponse* value);
  void unsafe_arena_set_allocated_endtxnonsubscriptionresponse(::pulsar::proto::CommandEndTxnOnSubscriptionResponse* value);
  ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* unsafe_arena_release_endtxnonsubscriptionresponse();

  private:
  const ::pulsar::proto::CommandEndTxnOnSubscriptionResponse& _internal_endtxnonsubscriptionresponse() const;
  ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* _internal_mutable_endtxnonsubscriptionresponse();

  public:
  // optional .pulsar.proto.CommandTcClientConnectRequest tcClientConnectRequest = 62;
  bool has_tcclientconnectrequest() const;
  void clear_tcclientconnectrequest() ;
  const ::pulsar::proto::CommandTcClientConnectRequest& tcclientconnectrequest() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandTcClientConnectRequest* release_tcclientconnectrequest();
  ::pulsar::proto::CommandTcClientConnectRequest* mutable_tcclientconnectrequest();
  void set_allocated_tcclientconnectrequest(::pulsar::proto::CommandTcClientConnectRequest* value);
  void unsafe_arena_set_allocated_tcclientconnectrequest(::pulsar::proto::CommandTcClientConnectRequest* value);
  ::pulsar::proto::CommandTcClientConnectRequest* unsafe_arena_release_tcclientconnectrequest();

  private:
  const ::pulsar::proto::CommandTcClientConnectRequest& _internal_tcclientconnectrequest() const;
  ::pulsar::proto::CommandTcClientConnectRequest* _internal_mutable_tcclientconnectrequest();

  public:
  // optional .pulsar.proto.CommandTcClientConnectResponse tcClientConnectResponse = 63;
  bool has_tcclientconnectresponse() const;
  void clear_tcclientconnectresponse() ;
  const ::pulsar::proto::CommandTcClientConnectResponse& tcclientconnectresponse() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandTcClientConnectResponse* release_tcclientconnectresponse();
  ::pulsar::proto::CommandTcClientConnectResponse* mutable_tcclientconnectresponse();
  void set_allocated_tcclientconnectresponse(::pulsar::proto::CommandTcClientConnectResponse* value);
  void unsafe_arena_set_allocated_tcclientconnectresponse(::pulsar::proto::CommandTcClientConnectResponse* value);
  ::pulsar::proto::CommandTcClientConnectResponse* unsafe_arena_release_tcclientconnectresponse();

  private:
  const ::pulsar::proto::CommandTcClientConnectResponse& _internal_tcclientconnectresponse() const;
  ::pulsar::proto::CommandTcClientConnectResponse* _internal_mutable_tcclientconnectresponse();

  public:
  // optional .pulsar.proto.CommandWatchTopicList watchTopicList = 64;
  bool has_watchtopiclist() const;
  void clear_watchtopiclist() ;
  const ::pulsar::proto::CommandWatchTopicList& watchtopiclist() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandWatchTopicList* release_watchtopiclist();
  ::pulsar::proto::CommandWatchTopicList* mutable_watchtopiclist();
  void set_allocated_watchtopiclist(::pulsar::proto::CommandWatchTopicList* value);
  void unsafe_arena_set_allocated_watchtopiclist(::pulsar::proto::CommandWatchTopicList* value);
  ::pulsar::proto::CommandWatchTopicList* unsafe_arena_release_watchtopiclist();

  private:
  const ::pulsar::proto::CommandWatchTopicList& _internal_watchtopiclist() const;
  ::pulsar::proto::CommandWatchTopicList* _internal_mutable_watchtopiclist();

  public:
  // optional .pulsar.proto.CommandWatchTopicListSuccess watchTopicListSuccess = 65;
  bool has_watchtopiclistsuccess() const;
  void clear_watchtopiclistsuccess() ;
  const ::pulsar::proto::CommandWatchTopicListSuccess& watchtopiclistsuccess() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandWatchTopicListSuccess* release_watchtopiclistsuccess();
  ::pulsar::proto::CommandWatchTopicListSuccess* mutable_watchtopiclistsuccess();
  void set_allocated_watchtopiclistsuccess(::pulsar::proto::CommandWatchTopicListSuccess* value);
  void unsafe_arena_set_allocated_watchtopiclistsuccess(::pulsar::proto::CommandWatchTopicListSuccess* value);
  ::pulsar::proto::CommandWatchTopicListSuccess* unsafe_arena_release_watchtopiclistsuccess();

  private:
  const ::pulsar::proto::CommandWatchTopicListSuccess& _internal_watchtopiclistsuccess() const;
  ::pulsar::proto::CommandWatchTopicListSuccess* _internal_mutable_watchtopiclistsuccess();

  public:
  // optional .pulsar.proto.CommandWatchTopicUpdate watchTopicUpdate = 66;
  bool has_watchtopicupdate() const;
  void clear_watchtopicupdate() ;
  const ::pulsar::proto::CommandWatchTopicUpdate& watchtopicupdate() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandWatchTopicUpdate* release_watchtopicupdate();
  ::pulsar::proto::CommandWatchTopicUpdate* mutable_watchtopicupdate();
  void set_allocated_watchtopicupdate(::pulsar::proto::CommandWatchTopicUpdate* value);
  void unsafe_arena_set_allocated_watchtopicupdate(::pulsar::proto::CommandWatchTopicUpdate* value);
  ::pulsar::proto::CommandWatchTopicUpdate* unsafe_arena_release_watchtopicupdate();

  private:
  const ::pulsar::proto::CommandWatchTopicUpdate& _internal_watchtopicupdate() const;
  ::pulsar::proto::CommandWatchTopicUpdate* _internal_mutable_watchtopicupdate();

  public:
  // optional .pulsar.proto.CommandWatchTopicListClose watchTopicListClose = 67;
  bool has_watchtopiclistclose() const;
  void clear_watchtopiclistclose() ;
  const ::pulsar::proto::CommandWatchTopicListClose& watchtopiclistclose() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandWatchTopicListClose* release_watchtopiclistclose();
  ::pulsar::proto::CommandWatchTopicListClose* mutable_watchtopiclistclose();
  void set_allocated_watchtopiclistclose(::pulsar::proto::CommandWatchTopicListClose* value);
  void unsafe_arena_set_allocated_watchtopiclistclose(::pulsar::proto::CommandWatchTopicListClose* value);
  ::pulsar::proto::CommandWatchTopicListClose* unsafe_arena_release_watchtopiclistclose();

  private:
  const ::pulsar::proto::CommandWatchTopicListClose& _internal_watchtopiclistclose() const;
  ::pulsar::proto::CommandWatchTopicListClose* _internal_mutable_watchtopiclistclose();

  public:
  // optional .pulsar.proto.CommandTopicMigrated topicMigrated = 68;
  bool has_topicmigrated() const;
  void clear_topicmigrated() ;
  const ::pulsar::proto::CommandTopicMigrated& topicmigrated() const;
  PROTOBUF_NODISCARD ::pulsar::proto::CommandTopicMigrated* release_topicmigrated();
  ::pulsar::proto::CommandTopicMigrated* mutable_topicmigrated();
  void set_allocated_topicmigrated(::pulsar::proto::CommandTopicMigrated* value);
  void unsafe_arena_set_allocated_topicmigrated(::pulsar::proto::CommandTopicMigrated* value);
  ::pulsar::proto::CommandTopicMigrated* unsafe_arena_release_topicmigrated();

  private:
  const ::pulsar::proto::CommandTopicMigrated& _internal_topicmigrated() const;
  ::pulsar::proto::CommandTopicMigrated* _internal_mutable_topicmigrated();

  public:
  // required .pulsar.proto.BaseCommand.Type type = 1;
  bool has_type() const;
  void clear_type() ;
  ::pulsar::proto::BaseCommand_Type type() const;
  void set_type(::pulsar::proto::BaseCommand_Type value);

  private:
  ::pulsar::proto::BaseCommand_Type _internal_type() const;
  void _internal_set_type(::pulsar::proto::BaseCommand_Type value);

  public:
  // @@protoc_insertion_point(class_scope:pulsar.proto.BaseCommand)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 59, 59,
      0, 11>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<2> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::pulsar::proto::CommandConnect* connect_;
    ::pulsar::proto::CommandConnected* connected_;
    ::pulsar::proto::CommandSubscribe* subscribe_;
    ::pulsar::proto::CommandProducer* producer_;
    ::pulsar::proto::CommandSend* send_;
    ::pulsar::proto::CommandSendReceipt* send_receipt_;
    ::pulsar::proto::CommandSendError* send_error_;
    ::pulsar::proto::CommandMessage* message_;
    ::pulsar::proto::CommandAck* ack_;
    ::pulsar::proto::CommandFlow* flow_;
    ::pulsar::proto::CommandUnsubscribe* unsubscribe_;
    ::pulsar::proto::CommandSuccess* success_;
    ::pulsar::proto::CommandError* error_;
    ::pulsar::proto::CommandCloseProducer* close_producer_;
    ::pulsar::proto::CommandCloseConsumer* close_consumer_;
    ::pulsar::proto::CommandProducerSuccess* producer_success_;
    ::pulsar::proto::CommandPing* ping_;
    ::pulsar::proto::CommandPong* pong_;
    ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* redeliverunacknowledgedmessages_;
    ::pulsar::proto::CommandPartitionedTopicMetadata* partitionmetadata_;
    ::pulsar::proto::CommandPartitionedTopicMetadataResponse* partitionmetadataresponse_;
    ::pulsar::proto::CommandLookupTopic* lookuptopic_;
    ::pulsar::proto::CommandLookupTopicResponse* lookuptopicresponse_;
    ::pulsar::proto::CommandConsumerStats* consumerstats_;
    ::pulsar::proto::CommandConsumerStatsResponse* consumerstatsresponse_;
    ::pulsar::proto::CommandReachedEndOfTopic* reachedendoftopic_;
    ::pulsar::proto::CommandSeek* seek_;
    ::pulsar::proto::CommandGetLastMessageId* getlastmessageid_;
    ::pulsar::proto::CommandGetLastMessageIdResponse* getlastmessageidresponse_;
    ::pulsar::proto::CommandActiveConsumerChange* active_consumer_change_;
    ::pulsar::proto::CommandGetTopicsOfNamespace* gettopicsofnamespace_;
    ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* gettopicsofnamespaceresponse_;
    ::pulsar::proto::CommandGetSchema* getschema_;
    ::pulsar::proto::CommandGetSchemaResponse* getschemaresponse_;
    ::pulsar::proto::CommandAuthChallenge* authchallenge_;
    ::pulsar::proto::CommandAuthResponse* authresponse_;
    ::pulsar::proto::CommandAckResponse* ackresponse_;
    ::pulsar::proto::CommandGetOrCreateSchema* getorcreateschema_;
    ::pulsar::proto::CommandGetOrCreateSchemaResponse* getorcreateschemaresponse_;
    ::pulsar::proto::CommandNewTxn* newtxn_;
    ::pulsar::proto::CommandNewTxnResponse* newtxnresponse_;
    ::pulsar::proto::CommandAddPartitionToTxn* addpartitiontotxn_;
    ::pulsar::proto::CommandAddPartitionToTxnResponse* addpartitiontotxnresponse_;
    ::pulsar::proto::CommandAddSubscriptionToTxn* addsubscriptiontotxn_;
    ::pulsar::proto::CommandAddSubscriptionToTxnResponse* addsubscriptiontotxnresponse_;
    ::pulsar::proto::CommandEndTxn* endtxn_;
    ::pulsar::proto::CommandEndTxnResponse* endtxnresponse_;
    ::pulsar::proto::CommandEndTxnOnPartition* endtxnonpartition_;
    ::pulsar::proto::CommandEndTxnOnPartitionResponse* endtxnonpartitionresponse_;
    ::pulsar::proto::CommandEndTxnOnSubscription* endtxnonsubscription_;
    ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* endtxnonsubscriptionresponse_;
    ::pulsar::proto::CommandTcClientConnectRequest* tcclientconnectrequest_;
    ::pulsar::proto::CommandTcClientConnectResponse* tcclientconnectresponse_;
    ::pulsar::proto::CommandWatchTopicList* watchtopiclist_;
    ::pulsar::proto::CommandWatchTopicListSuccess* watchtopiclistsuccess_;
    ::pulsar::proto::CommandWatchTopicUpdate* watchtopicupdate_;
    ::pulsar::proto::CommandWatchTopicListClose* watchtopiclistclose_;
    ::pulsar::proto::CommandTopicMigrated* topicmigrated_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PulsarApi_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Schema

// required string name = 1;
inline bool Schema::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Schema::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Schema::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.Schema.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Schema::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.Schema.name)
}
inline std::string* Schema::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.Schema.name)
  return _s;
}
inline const std::string& Schema::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Schema::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Schema::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Schema::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.Schema.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Schema::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.Schema.name)
}

// required bytes schema_data = 3;
inline bool Schema::has_schema_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Schema::clear_schema_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.schema_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Schema::schema_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.Schema.schema_data)
  return _internal_schema_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Schema::set_schema_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.schema_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.Schema.schema_data)
}
inline std::string* Schema::mutable_schema_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_schema_data();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.Schema.schema_data)
  return _s;
}
inline const std::string& Schema::_internal_schema_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.schema_data_.Get();
}
inline void Schema::_internal_set_schema_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.schema_data_.Set(value, GetArena());
}
inline std::string* Schema::_internal_mutable_schema_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.schema_data_.Mutable( GetArena());
}
inline std::string* Schema::release_schema_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.Schema.schema_data)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.schema_data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.schema_data_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Schema::set_allocated_schema_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.schema_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_data_.IsDefault()) {
          _impl_.schema_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.Schema.schema_data)
}

// required .pulsar.proto.Schema.Type type = 4;
inline bool Schema::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Schema::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::pulsar::proto::Schema_Type Schema::type() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.Schema.type)
  return _internal_type();
}
inline void Schema::set_type(::pulsar::proto::Schema_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.Schema.type)
}
inline ::pulsar::proto::Schema_Type Schema::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::Schema_Type>(_impl_.type_);
}
inline void Schema::_internal_set_type(::pulsar::proto::Schema_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::Schema_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}

// repeated .pulsar.proto.KeyValue properties = 5;
inline int Schema::_internal_properties_size() const {
  return _internal_properties().size();
}
inline int Schema::properties_size() const {
  return _internal_properties_size();
}
inline void Schema::clear_properties() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.properties_.Clear();
}
inline ::pulsar::proto::KeyValue* Schema::mutable_properties(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.Schema.properties)
  return _internal_mutable_properties()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>* Schema::mutable_properties()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.Schema.properties)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_properties();
}
inline const ::pulsar::proto::KeyValue& Schema::properties(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.Schema.properties)
  return _internal_properties().Get(index);
}
inline ::pulsar::proto::KeyValue* Schema::add_properties() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pulsar::proto::KeyValue* _add = _internal_mutable_properties()->Add();
  // @@protoc_insertion_point(field_add:pulsar.proto.Schema.properties)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>& Schema::properties() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.Schema.properties)
  return _internal_properties();
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>&
Schema::_internal_properties() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.properties_;
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>*
Schema::_internal_mutable_properties() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.properties_;
}

// -------------------------------------------------------------------

// MessageIdData

// required uint64 ledgerId = 1;
inline bool MessageIdData::has_ledgerid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MessageIdData::clear_ledgerid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ledgerid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t MessageIdData::ledgerid() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.ledgerId)
  return _internal_ledgerid();
}
inline void MessageIdData::set_ledgerid(::uint64_t value) {
  _internal_set_ledgerid(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageIdData.ledgerId)
}
inline ::uint64_t MessageIdData::_internal_ledgerid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ledgerid_;
}
inline void MessageIdData::_internal_set_ledgerid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ledgerid_ = value;
}

// required uint64 entryId = 2;
inline bool MessageIdData::has_entryid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MessageIdData::clear_entryid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entryid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t MessageIdData::entryid() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.entryId)
  return _internal_entryid();
}
inline void MessageIdData::set_entryid(::uint64_t value) {
  _internal_set_entryid(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageIdData.entryId)
}
inline ::uint64_t MessageIdData::_internal_entryid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entryid_;
}
inline void MessageIdData::_internal_set_entryid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.entryid_ = value;
}

// optional int32 partition = 3 [default = -1];
inline bool MessageIdData::has_partition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MessageIdData::clear_partition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.partition_ = -1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t MessageIdData::partition() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.partition)
  return _internal_partition();
}
inline void MessageIdData::set_partition(::int32_t value) {
  _internal_set_partition(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageIdData.partition)
}
inline ::int32_t MessageIdData::_internal_partition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.partition_;
}
inline void MessageIdData::_internal_set_partition(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.partition_ = value;
}

// optional int32 batch_index = 4 [default = -1];
inline bool MessageIdData::has_batch_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void MessageIdData::clear_batch_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.batch_index_ = -1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t MessageIdData::batch_index() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.batch_index)
  return _internal_batch_index();
}
inline void MessageIdData::set_batch_index(::int32_t value) {
  _internal_set_batch_index(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageIdData.batch_index)
}
inline ::int32_t MessageIdData::_internal_batch_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.batch_index_;
}
inline void MessageIdData::_internal_set_batch_index(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.batch_index_ = value;
}

// repeated int64 ack_set = 5;
inline int MessageIdData::_internal_ack_set_size() const {
  return _internal_ack_set().size();
}
inline int MessageIdData::ack_set_size() const {
  return _internal_ack_set_size();
}
inline void MessageIdData::clear_ack_set() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ack_set_.Clear();
}
inline ::int64_t MessageIdData::ack_set(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.ack_set)
  return _internal_ack_set().Get(index);
}
inline void MessageIdData::set_ack_set(int index, ::int64_t value) {
  _internal_mutable_ack_set()->Set(index, value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageIdData.ack_set)
}
inline void MessageIdData::add_ack_set(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ack_set()->Add(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.MessageIdData.ack_set)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& MessageIdData::ack_set() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.MessageIdData.ack_set)
  return _internal_ack_set();
}
inline ::google::protobuf::RepeatedField<::int64_t>* MessageIdData::mutable_ack_set()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.MessageIdData.ack_set)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ack_set();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& MessageIdData::_internal_ack_set()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ack_set_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* MessageIdData::_internal_mutable_ack_set() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ack_set_;
}

// optional int32 batch_size = 6;
inline bool MessageIdData::has_batch_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MessageIdData::clear_batch_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.batch_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t MessageIdData::batch_size() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.batch_size)
  return _internal_batch_size();
}
inline void MessageIdData::set_batch_size(::int32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageIdData.batch_size)
}
inline ::int32_t MessageIdData::_internal_batch_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.batch_size_;
}
inline void MessageIdData::_internal_set_batch_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.batch_size_ = value;
}

// optional .pulsar.proto.MessageIdData first_chunk_message_id = 7;
inline bool MessageIdData::has_first_chunk_message_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.first_chunk_message_id_ != nullptr);
  return value;
}
inline void MessageIdData::clear_first_chunk_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.first_chunk_message_id_ != nullptr) _impl_.first_chunk_message_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::MessageIdData& MessageIdData::_internal_first_chunk_message_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::MessageIdData* p = _impl_.first_chunk_message_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::MessageIdData&>(::pulsar::proto::_MessageIdData_default_instance_);
}
inline const ::pulsar::proto::MessageIdData& MessageIdData::first_chunk_message_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageIdData.first_chunk_message_id)
  return _internal_first_chunk_message_id();
}
inline void MessageIdData::unsafe_arena_set_allocated_first_chunk_message_id(::pulsar::proto::MessageIdData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.first_chunk_message_id_);
  }
  _impl_.first_chunk_message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.MessageIdData.first_chunk_message_id)
}
inline ::pulsar::proto::MessageIdData* MessageIdData::release_first_chunk_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* released = _impl_.first_chunk_message_id_;
  _impl_.first_chunk_message_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::MessageIdData* MessageIdData::unsafe_arena_release_first_chunk_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageIdData.first_chunk_message_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = _impl_.first_chunk_message_id_;
  _impl_.first_chunk_message_id_ = nullptr;
  return temp;
}
inline ::pulsar::proto::MessageIdData* MessageIdData::_internal_mutable_first_chunk_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.first_chunk_message_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::MessageIdData>(GetArena());
    _impl_.first_chunk_message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(p);
  }
  return _impl_.first_chunk_message_id_;
}
inline ::pulsar::proto::MessageIdData* MessageIdData::mutable_first_chunk_message_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::MessageIdData* _msg = _internal_mutable_first_chunk_message_id();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageIdData.first_chunk_message_id)
  return _msg;
}
inline void MessageIdData::set_allocated_first_chunk_message_id(::pulsar::proto::MessageIdData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::MessageIdData*>(_impl_.first_chunk_message_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::MessageIdData*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.first_chunk_message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageIdData.first_chunk_message_id)
}

// -------------------------------------------------------------------

// KeyValue

// required string key = 1;
inline bool KeyValue::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void KeyValue::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KeyValue::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeyValue.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyValue::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.KeyValue.key)
}
inline std::string* KeyValue::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.KeyValue.key)
  return _s;
}
inline const std::string& KeyValue::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void KeyValue::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* KeyValue::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* KeyValue::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.KeyValue.key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void KeyValue::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.KeyValue.key)
}

// required string value = 2;
inline bool KeyValue::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void KeyValue::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KeyValue::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeyValue.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyValue::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.KeyValue.value)
}
inline std::string* KeyValue::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.KeyValue.value)
  return _s;
}
inline const std::string& KeyValue::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void KeyValue::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(value, GetArena());
}
inline std::string* KeyValue::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* KeyValue::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.KeyValue.value)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.value_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void KeyValue::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.KeyValue.value)
}

// -------------------------------------------------------------------

// KeyLongValue

// required string key = 1;
inline bool KeyLongValue::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void KeyLongValue::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KeyLongValue::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeyLongValue.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyLongValue::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.KeyLongValue.key)
}
inline std::string* KeyLongValue::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.KeyLongValue.key)
  return _s;
}
inline const std::string& KeyLongValue::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void KeyLongValue::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* KeyLongValue::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* KeyLongValue::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.KeyLongValue.key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void KeyLongValue::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.KeyLongValue.key)
}

// required uint64 value = 2;
inline bool KeyLongValue::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void KeyLongValue::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t KeyLongValue::value() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeyLongValue.value)
  return _internal_value();
}
inline void KeyLongValue::set_value(::uint64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.KeyLongValue.value)
}
inline ::uint64_t KeyLongValue::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void KeyLongValue::_internal_set_value(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// IntRange

// required int32 start = 1;
inline bool IntRange::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IntRange::clear_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t IntRange::start() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.IntRange.start)
  return _internal_start();
}
inline void IntRange::set_start(::int32_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.IntRange.start)
}
inline ::int32_t IntRange::_internal_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_;
}
inline void IntRange::_internal_set_start(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.start_ = value;
}

// required int32 end = 2;
inline bool IntRange::has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IntRange::clear_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t IntRange::end() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.IntRange.end)
  return _internal_end();
}
inline void IntRange::set_end(::int32_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.IntRange.end)
}
inline ::int32_t IntRange::_internal_end() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_;
}
inline void IntRange::_internal_set_end(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.end_ = value;
}

// -------------------------------------------------------------------

// EncryptionKeys

// required string key = 1;
inline bool EncryptionKeys::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EncryptionKeys::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EncryptionKeys::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.EncryptionKeys.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EncryptionKeys::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.EncryptionKeys.key)
}
inline std::string* EncryptionKeys::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.EncryptionKeys.key)
  return _s;
}
inline const std::string& EncryptionKeys::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void EncryptionKeys::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* EncryptionKeys::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* EncryptionKeys::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.EncryptionKeys.key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void EncryptionKeys::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.EncryptionKeys.key)
}

// required bytes value = 2;
inline bool EncryptionKeys::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void EncryptionKeys::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& EncryptionKeys::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.EncryptionKeys.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EncryptionKeys::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.EncryptionKeys.value)
}
inline std::string* EncryptionKeys::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.EncryptionKeys.value)
  return _s;
}
inline const std::string& EncryptionKeys::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void EncryptionKeys::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(value, GetArena());
}
inline std::string* EncryptionKeys::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* EncryptionKeys::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.EncryptionKeys.value)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.value_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void EncryptionKeys::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.EncryptionKeys.value)
}

// repeated .pulsar.proto.KeyValue metadata = 3;
inline int EncryptionKeys::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int EncryptionKeys::metadata_size() const {
  return _internal_metadata_size();
}
inline void EncryptionKeys::clear_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metadata_.Clear();
}
inline ::pulsar::proto::KeyValue* EncryptionKeys::mutable_metadata(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.EncryptionKeys.metadata)
  return _internal_mutable_metadata()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>* EncryptionKeys::mutable_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.EncryptionKeys.metadata)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_metadata();
}
inline const ::pulsar::proto::KeyValue& EncryptionKeys::metadata(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.EncryptionKeys.metadata)
  return _internal_metadata().Get(index);
}
inline ::pulsar::proto::KeyValue* EncryptionKeys::add_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pulsar::proto::KeyValue* _add = _internal_mutable_metadata()->Add();
  // @@protoc_insertion_point(field_add:pulsar.proto.EncryptionKeys.metadata)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>& EncryptionKeys::metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.EncryptionKeys.metadata)
  return _internal_metadata();
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>&
EncryptionKeys::_internal_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metadata_;
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>*
EncryptionKeys::_internal_mutable_metadata() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.metadata_;
}

// -------------------------------------------------------------------

// MessageMetadata

// required string producer_name = 1;
inline bool MessageMetadata::has_producer_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MessageMetadata::clear_producer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.producer_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MessageMetadata::producer_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.producer_name)
  return _internal_producer_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageMetadata::set_producer_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.producer_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.producer_name)
}
inline std::string* MessageMetadata::mutable_producer_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_producer_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.producer_name)
  return _s;
}
inline const std::string& MessageMetadata::_internal_producer_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.producer_name_.Get();
}
inline void MessageMetadata::_internal_set_producer_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.producer_name_.Set(value, GetArena());
}
inline std::string* MessageMetadata::_internal_mutable_producer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.producer_name_.Mutable( GetArena());
}
inline std::string* MessageMetadata::release_producer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageMetadata.producer_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.producer_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.producer_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MessageMetadata::set_allocated_producer_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.producer_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.producer_name_.IsDefault()) {
          _impl_.producer_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.producer_name)
}

// required uint64 sequence_id = 2;
inline bool MessageMetadata::has_sequence_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void MessageMetadata::clear_sequence_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sequence_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint64_t MessageMetadata::sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.sequence_id)
  return _internal_sequence_id();
}
inline void MessageMetadata::set_sequence_id(::uint64_t value) {
  _internal_set_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.sequence_id)
}
inline ::uint64_t MessageMetadata::_internal_sequence_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequence_id_;
}
inline void MessageMetadata::_internal_set_sequence_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.sequence_id_ = value;
}

// required uint64 publish_time = 3;
inline bool MessageMetadata::has_publish_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void MessageMetadata::clear_publish_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.publish_time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint64_t MessageMetadata::publish_time() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.publish_time)
  return _internal_publish_time();
}
inline void MessageMetadata::set_publish_time(::uint64_t value) {
  _internal_set_publish_time(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.publish_time)
}
inline ::uint64_t MessageMetadata::_internal_publish_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.publish_time_;
}
inline void MessageMetadata::_internal_set_publish_time(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.publish_time_ = value;
}

// repeated .pulsar.proto.KeyValue properties = 4;
inline int MessageMetadata::_internal_properties_size() const {
  return _internal_properties().size();
}
inline int MessageMetadata::properties_size() const {
  return _internal_properties_size();
}
inline void MessageMetadata::clear_properties() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.properties_.Clear();
}
inline ::pulsar::proto::KeyValue* MessageMetadata::mutable_properties(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.properties)
  return _internal_mutable_properties()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>* MessageMetadata::mutable_properties()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.MessageMetadata.properties)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_properties();
}
inline const ::pulsar::proto::KeyValue& MessageMetadata::properties(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.properties)
  return _internal_properties().Get(index);
}
inline ::pulsar::proto::KeyValue* MessageMetadata::add_properties() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pulsar::proto::KeyValue* _add = _internal_mutable_properties()->Add();
  // @@protoc_insertion_point(field_add:pulsar.proto.MessageMetadata.properties)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>& MessageMetadata::properties() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.MessageMetadata.properties)
  return _internal_properties();
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>&
MessageMetadata::_internal_properties() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.properties_;
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>*
MessageMetadata::_internal_mutable_properties() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.properties_;
}

// optional string replicated_from = 5;
inline bool MessageMetadata::has_replicated_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MessageMetadata::clear_replicated_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.replicated_from_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MessageMetadata::replicated_from() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.replicated_from)
  return _internal_replicated_from();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageMetadata::set_replicated_from(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.replicated_from_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.replicated_from)
}
inline std::string* MessageMetadata::mutable_replicated_from() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_replicated_from();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.replicated_from)
  return _s;
}
inline const std::string& MessageMetadata::_internal_replicated_from() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.replicated_from_.Get();
}
inline void MessageMetadata::_internal_set_replicated_from(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.replicated_from_.Set(value, GetArena());
}
inline std::string* MessageMetadata::_internal_mutable_replicated_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.replicated_from_.Mutable( GetArena());
}
inline std::string* MessageMetadata::release_replicated_from() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageMetadata.replicated_from)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.replicated_from_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.replicated_from_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MessageMetadata::set_allocated_replicated_from(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.replicated_from_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.replicated_from_.IsDefault()) {
          _impl_.replicated_from_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.replicated_from)
}

// optional string partition_key = 6;
inline bool MessageMetadata::has_partition_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MessageMetadata::clear_partition_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.partition_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MessageMetadata::partition_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.partition_key)
  return _internal_partition_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageMetadata::set_partition_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.partition_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.partition_key)
}
inline std::string* MessageMetadata::mutable_partition_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_partition_key();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.partition_key)
  return _s;
}
inline const std::string& MessageMetadata::_internal_partition_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.partition_key_.Get();
}
inline void MessageMetadata::_internal_set_partition_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.partition_key_.Set(value, GetArena());
}
inline std::string* MessageMetadata::_internal_mutable_partition_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.partition_key_.Mutable( GetArena());
}
inline std::string* MessageMetadata::release_partition_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageMetadata.partition_key)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.partition_key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.partition_key_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MessageMetadata::set_allocated_partition_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.partition_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.partition_key_.IsDefault()) {
          _impl_.partition_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.partition_key)
}

// repeated string replicate_to = 7;
inline int MessageMetadata::_internal_replicate_to_size() const {
  return _internal_replicate_to().size();
}
inline int MessageMetadata::replicate_to_size() const {
  return _internal_replicate_to_size();
}
inline void MessageMetadata::clear_replicate_to() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.replicate_to_.Clear();
}
inline std::string* MessageMetadata::add_replicate_to()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_replicate_to()->Add();
  // @@protoc_insertion_point(field_add_mutable:pulsar.proto.MessageMetadata.replicate_to)
  return _s;
}
inline const std::string& MessageMetadata::replicate_to(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.replicate_to)
  return _internal_replicate_to().Get(index);
}
inline std::string* MessageMetadata::mutable_replicate_to(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.replicate_to)
  return _internal_mutable_replicate_to()->Mutable(index);
}
inline void MessageMetadata::set_replicate_to(int index, const std::string& value) {
  _internal_mutable_replicate_to()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::set_replicate_to(int index, std::string&& value) {
  _internal_mutable_replicate_to()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::set_replicate_to(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_replicate_to()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::set_replicate_to(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_replicate_to()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::set_replicate_to(int index, absl::string_view value) {
  _internal_mutable_replicate_to()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::add_replicate_to(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_replicate_to()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::add_replicate_to(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_replicate_to()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::add_replicate_to(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_replicate_to()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::add_replicate_to(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_replicate_to()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pulsar.proto.MessageMetadata.replicate_to)
}
inline void MessageMetadata::add_replicate_to(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_replicate_to()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:pulsar.proto.MessageMetadata.replicate_to)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MessageMetadata::replicate_to() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.MessageMetadata.replicate_to)
  return _internal_replicate_to();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MessageMetadata::mutable_replicate_to() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.MessageMetadata.replicate_to)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_replicate_to();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MessageMetadata::_internal_replicate_to() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.replicate_to_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MessageMetadata::_internal_mutable_replicate_to() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.replicate_to_;
}

// optional .pulsar.proto.CompressionType compression = 8 [default = NONE];
inline bool MessageMetadata::has_compression() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void MessageMetadata::clear_compression() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.compression_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::pulsar::proto::CompressionType MessageMetadata::compression() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.compression)
  return _internal_compression();
}
inline void MessageMetadata::set_compression(::pulsar::proto::CompressionType value) {
  _internal_set_compression(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.compression)
}
inline ::pulsar::proto::CompressionType MessageMetadata::_internal_compression() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::CompressionType>(_impl_.compression_);
}
inline void MessageMetadata::_internal_set_compression(::pulsar::proto::CompressionType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::CompressionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.compression_ = value;
}

// optional uint32 uncompressed_size = 9 [default = 0];
inline bool MessageMetadata::has_uncompressed_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void MessageMetadata::clear_uncompressed_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uncompressed_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::uint32_t MessageMetadata::uncompressed_size() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.uncompressed_size)
  return _internal_uncompressed_size();
}
inline void MessageMetadata::set_uncompressed_size(::uint32_t value) {
  _internal_set_uncompressed_size(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.uncompressed_size)
}
inline ::uint32_t MessageMetadata::_internal_uncompressed_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uncompressed_size_;
}
inline void MessageMetadata::_internal_set_uncompressed_size(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.uncompressed_size_ = value;
}

// optional int32 num_messages_in_batch = 11 [default = 1];
inline bool MessageMetadata::has_num_messages_in_batch() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline void MessageMetadata::clear_num_messages_in_batch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_messages_in_batch_ = 1;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline ::int32_t MessageMetadata::num_messages_in_batch() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.num_messages_in_batch)
  return _internal_num_messages_in_batch();
}
inline void MessageMetadata::set_num_messages_in_batch(::int32_t value) {
  _internal_set_num_messages_in_batch(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.num_messages_in_batch)
}
inline ::int32_t MessageMetadata::_internal_num_messages_in_batch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_messages_in_batch_;
}
inline void MessageMetadata::_internal_set_num_messages_in_batch(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.num_messages_in_batch_ = value;
}

// optional uint64 event_time = 12 [default = 0];
inline bool MessageMetadata::has_event_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void MessageMetadata::clear_event_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.event_time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::uint64_t MessageMetadata::event_time() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.event_time)
  return _internal_event_time();
}
inline void MessageMetadata::set_event_time(::uint64_t value) {
  _internal_set_event_time(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.event_time)
}
inline ::uint64_t MessageMetadata::_internal_event_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.event_time_;
}
inline void MessageMetadata::_internal_set_event_time(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.event_time_ = value;
}

// repeated .pulsar.proto.EncryptionKeys encryption_keys = 13;
inline int MessageMetadata::_internal_encryption_keys_size() const {
  return _internal_encryption_keys().size();
}
inline int MessageMetadata::encryption_keys_size() const {
  return _internal_encryption_keys_size();
}
inline void MessageMetadata::clear_encryption_keys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.encryption_keys_.Clear();
}
inline ::pulsar::proto::EncryptionKeys* MessageMetadata::mutable_encryption_keys(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.encryption_keys)
  return _internal_mutable_encryption_keys()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::EncryptionKeys>* MessageMetadata::mutable_encryption_keys()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.MessageMetadata.encryption_keys)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_encryption_keys();
}
inline const ::pulsar::proto::EncryptionKeys& MessageMetadata::encryption_keys(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.encryption_keys)
  return _internal_encryption_keys().Get(index);
}
inline ::pulsar::proto::EncryptionKeys* MessageMetadata::add_encryption_keys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pulsar::proto::EncryptionKeys* _add = _internal_mutable_encryption_keys()->Add();
  // @@protoc_insertion_point(field_add:pulsar.proto.MessageMetadata.encryption_keys)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::EncryptionKeys>& MessageMetadata::encryption_keys() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.MessageMetadata.encryption_keys)
  return _internal_encryption_keys();
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::EncryptionKeys>&
MessageMetadata::_internal_encryption_keys() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.encryption_keys_;
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::EncryptionKeys>*
MessageMetadata::_internal_mutable_encryption_keys() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.encryption_keys_;
}

// optional string encryption_algo = 14;
inline bool MessageMetadata::has_encryption_algo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MessageMetadata::clear_encryption_algo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.encryption_algo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MessageMetadata::encryption_algo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.encryption_algo)
  return _internal_encryption_algo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageMetadata::set_encryption_algo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.encryption_algo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.encryption_algo)
}
inline std::string* MessageMetadata::mutable_encryption_algo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_encryption_algo();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.encryption_algo)
  return _s;
}
inline const std::string& MessageMetadata::_internal_encryption_algo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.encryption_algo_.Get();
}
inline void MessageMetadata::_internal_set_encryption_algo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.encryption_algo_.Set(value, GetArena());
}
inline std::string* MessageMetadata::_internal_mutable_encryption_algo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.encryption_algo_.Mutable( GetArena());
}
inline std::string* MessageMetadata::release_encryption_algo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageMetadata.encryption_algo)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.encryption_algo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.encryption_algo_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MessageMetadata::set_allocated_encryption_algo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.encryption_algo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.encryption_algo_.IsDefault()) {
          _impl_.encryption_algo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.encryption_algo)
}

// optional bytes encryption_param = 15;
inline bool MessageMetadata::has_encryption_param() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MessageMetadata::clear_encryption_param() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.encryption_param_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MessageMetadata::encryption_param() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.encryption_param)
  return _internal_encryption_param();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageMetadata::set_encryption_param(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.encryption_param_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.encryption_param)
}
inline std::string* MessageMetadata::mutable_encryption_param() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_encryption_param();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.encryption_param)
  return _s;
}
inline const std::string& MessageMetadata::_internal_encryption_param() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.encryption_param_.Get();
}
inline void MessageMetadata::_internal_set_encryption_param(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.encryption_param_.Set(value, GetArena());
}
inline std::string* MessageMetadata::_internal_mutable_encryption_param() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.encryption_param_.Mutable( GetArena());
}
inline std::string* MessageMetadata::release_encryption_param() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageMetadata.encryption_param)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.encryption_param_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.encryption_param_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MessageMetadata::set_allocated_encryption_param(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.encryption_param_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.encryption_param_.IsDefault()) {
          _impl_.encryption_param_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.encryption_param)
}

// optional bytes schema_version = 16;
inline bool MessageMetadata::has_schema_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void MessageMetadata::clear_schema_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.schema_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& MessageMetadata::schema_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.schema_version)
  return _internal_schema_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageMetadata::set_schema_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.schema_version_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.schema_version)
}
inline std::string* MessageMetadata::mutable_schema_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_schema_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.schema_version)
  return _s;
}
inline const std::string& MessageMetadata::_internal_schema_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.schema_version_.Get();
}
inline void MessageMetadata::_internal_set_schema_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.schema_version_.Set(value, GetArena());
}
inline std::string* MessageMetadata::_internal_mutable_schema_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.schema_version_.Mutable( GetArena());
}
inline std::string* MessageMetadata::release_schema_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageMetadata.schema_version)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.schema_version_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.schema_version_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MessageMetadata::set_allocated_schema_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.schema_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_version_.IsDefault()) {
          _impl_.schema_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.schema_version)
}

// optional bool partition_key_b64_encoded = 17 [default = false];
inline bool MessageMetadata::has_partition_key_b64_encoded() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void MessageMetadata::clear_partition_key_b64_encoded() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.partition_key_b64_encoded_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool MessageMetadata::partition_key_b64_encoded() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.partition_key_b64_encoded)
  return _internal_partition_key_b64_encoded();
}
inline void MessageMetadata::set_partition_key_b64_encoded(bool value) {
  _internal_set_partition_key_b64_encoded(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.partition_key_b64_encoded)
}
inline bool MessageMetadata::_internal_partition_key_b64_encoded() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.partition_key_b64_encoded_;
}
inline void MessageMetadata::_internal_set_partition_key_b64_encoded(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.partition_key_b64_encoded_ = value;
}

// optional bytes ordering_key = 18;
inline bool MessageMetadata::has_ordering_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void MessageMetadata::clear_ordering_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ordering_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& MessageMetadata::ordering_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.ordering_key)
  return _internal_ordering_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageMetadata::set_ordering_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.ordering_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.ordering_key)
}
inline std::string* MessageMetadata::mutable_ordering_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ordering_key();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.ordering_key)
  return _s;
}
inline const std::string& MessageMetadata::_internal_ordering_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ordering_key_.Get();
}
inline void MessageMetadata::_internal_set_ordering_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.ordering_key_.Set(value, GetArena());
}
inline std::string* MessageMetadata::_internal_mutable_ordering_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.ordering_key_.Mutable( GetArena());
}
inline std::string* MessageMetadata::release_ordering_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageMetadata.ordering_key)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.ordering_key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ordering_key_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MessageMetadata::set_allocated_ordering_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.ordering_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ordering_key_.IsDefault()) {
          _impl_.ordering_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.ordering_key)
}

// optional int64 deliver_at_time = 19;
inline bool MessageMetadata::has_deliver_at_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void MessageMetadata::clear_deliver_at_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deliver_at_time_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::int64_t MessageMetadata::deliver_at_time() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.deliver_at_time)
  return _internal_deliver_at_time();
}
inline void MessageMetadata::set_deliver_at_time(::int64_t value) {
  _internal_set_deliver_at_time(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.deliver_at_time)
}
inline ::int64_t MessageMetadata::_internal_deliver_at_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.deliver_at_time_;
}
inline void MessageMetadata::_internal_set_deliver_at_time(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.deliver_at_time_ = value;
}

// optional int32 marker_type = 20;
inline bool MessageMetadata::has_marker_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void MessageMetadata::clear_marker_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.marker_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::int32_t MessageMetadata::marker_type() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.marker_type)
  return _internal_marker_type();
}
inline void MessageMetadata::set_marker_type(::int32_t value) {
  _internal_set_marker_type(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.marker_type)
}
inline ::int32_t MessageMetadata::_internal_marker_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.marker_type_;
}
inline void MessageMetadata::_internal_set_marker_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.marker_type_ = value;
}

// optional uint64 txnid_least_bits = 22;
inline bool MessageMetadata::has_txnid_least_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void MessageMetadata::clear_txnid_least_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_least_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::uint64_t MessageMetadata::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void MessageMetadata::set_txnid_least_bits(::uint64_t value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.txnid_least_bits)
}
inline ::uint64_t MessageMetadata::_internal_txnid_least_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_least_bits_;
}
inline void MessageMetadata::_internal_set_txnid_least_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.txnid_least_bits_ = value;
}

// optional uint64 txnid_most_bits = 23;
inline bool MessageMetadata::has_txnid_most_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void MessageMetadata::clear_txnid_most_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_most_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::uint64_t MessageMetadata::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void MessageMetadata::set_txnid_most_bits(::uint64_t value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.txnid_most_bits)
}
inline ::uint64_t MessageMetadata::_internal_txnid_most_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_most_bits_;
}
inline void MessageMetadata::_internal_set_txnid_most_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.txnid_most_bits_ = value;
}

// optional uint64 highest_sequence_id = 24 [default = 0];
inline bool MessageMetadata::has_highest_sequence_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline void MessageMetadata::clear_highest_sequence_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.highest_sequence_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline ::uint64_t MessageMetadata::highest_sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.highest_sequence_id)
  return _internal_highest_sequence_id();
}
inline void MessageMetadata::set_highest_sequence_id(::uint64_t value) {
  _internal_set_highest_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.highest_sequence_id)
}
inline ::uint64_t MessageMetadata::_internal_highest_sequence_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.highest_sequence_id_;
}
inline void MessageMetadata::_internal_set_highest_sequence_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.highest_sequence_id_ = value;
}

// optional bool null_value = 25 [default = false];
inline bool MessageMetadata::has_null_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void MessageMetadata::clear_null_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.null_value_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool MessageMetadata::null_value() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.null_value)
  return _internal_null_value();
}
inline void MessageMetadata::set_null_value(bool value) {
  _internal_set_null_value(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.null_value)
}
inline bool MessageMetadata::_internal_null_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.null_value_;
}
inline void MessageMetadata::_internal_set_null_value(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.null_value_ = value;
}

// optional string uuid = 26;
inline bool MessageMetadata::has_uuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void MessageMetadata::clear_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uuid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& MessageMetadata::uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.uuid)
  return _internal_uuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MessageMetadata::set_uuid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.uuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.uuid)
}
inline std::string* MessageMetadata::mutable_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.MessageMetadata.uuid)
  return _s;
}
inline const std::string& MessageMetadata::_internal_uuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uuid_.Get();
}
inline void MessageMetadata::_internal_set_uuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.uuid_.Set(value, GetArena());
}
inline std::string* MessageMetadata::_internal_mutable_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.uuid_.Mutable( GetArena());
}
inline std::string* MessageMetadata::release_uuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.MessageMetadata.uuid)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.uuid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uuid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MessageMetadata::set_allocated_uuid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.uuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uuid_.IsDefault()) {
          _impl_.uuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.MessageMetadata.uuid)
}

// optional int32 num_chunks_from_msg = 27;
inline bool MessageMetadata::has_num_chunks_from_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline void MessageMetadata::clear_num_chunks_from_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_chunks_from_msg_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline ::int32_t MessageMetadata::num_chunks_from_msg() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.num_chunks_from_msg)
  return _internal_num_chunks_from_msg();
}
inline void MessageMetadata::set_num_chunks_from_msg(::int32_t value) {
  _internal_set_num_chunks_from_msg(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.num_chunks_from_msg)
}
inline ::int32_t MessageMetadata::_internal_num_chunks_from_msg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_chunks_from_msg_;
}
inline void MessageMetadata::_internal_set_num_chunks_from_msg(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.num_chunks_from_msg_ = value;
}

// optional int32 total_chunk_msg_size = 28;
inline bool MessageMetadata::has_total_chunk_msg_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline void MessageMetadata::clear_total_chunk_msg_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_chunk_msg_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline ::int32_t MessageMetadata::total_chunk_msg_size() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.total_chunk_msg_size)
  return _internal_total_chunk_msg_size();
}
inline void MessageMetadata::set_total_chunk_msg_size(::int32_t value) {
  _internal_set_total_chunk_msg_size(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.total_chunk_msg_size)
}
inline ::int32_t MessageMetadata::_internal_total_chunk_msg_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_chunk_msg_size_;
}
inline void MessageMetadata::_internal_set_total_chunk_msg_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.total_chunk_msg_size_ = value;
}

// optional int32 chunk_id = 29;
inline bool MessageMetadata::has_chunk_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline void MessageMetadata::clear_chunk_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.chunk_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline ::int32_t MessageMetadata::chunk_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.chunk_id)
  return _internal_chunk_id();
}
inline void MessageMetadata::set_chunk_id(::int32_t value) {
  _internal_set_chunk_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.chunk_id)
}
inline ::int32_t MessageMetadata::_internal_chunk_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.chunk_id_;
}
inline void MessageMetadata::_internal_set_chunk_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.chunk_id_ = value;
}

// optional bool null_partition_key = 30 [default = false];
inline bool MessageMetadata::has_null_partition_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void MessageMetadata::clear_null_partition_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.null_partition_key_ = false;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline bool MessageMetadata::null_partition_key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.MessageMetadata.null_partition_key)
  return _internal_null_partition_key();
}
inline void MessageMetadata::set_null_partition_key(bool value) {
  _internal_set_null_partition_key(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.MessageMetadata.null_partition_key)
}
inline bool MessageMetadata::_internal_null_partition_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.null_partition_key_;
}
inline void MessageMetadata::_internal_set_null_partition_key(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.null_partition_key_ = value;
}

// -------------------------------------------------------------------

// SingleMessageMetadata

// repeated .pulsar.proto.KeyValue properties = 1;
inline int SingleMessageMetadata::_internal_properties_size() const {
  return _internal_properties().size();
}
inline int SingleMessageMetadata::properties_size() const {
  return _internal_properties_size();
}
inline void SingleMessageMetadata::clear_properties() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.properties_.Clear();
}
inline ::pulsar::proto::KeyValue* SingleMessageMetadata::mutable_properties(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.SingleMessageMetadata.properties)
  return _internal_mutable_properties()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>* SingleMessageMetadata::mutable_properties()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.SingleMessageMetadata.properties)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_properties();
}
inline const ::pulsar::proto::KeyValue& SingleMessageMetadata::properties(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.properties)
  return _internal_properties().Get(index);
}
inline ::pulsar::proto::KeyValue* SingleMessageMetadata::add_properties() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pulsar::proto::KeyValue* _add = _internal_mutable_properties()->Add();
  // @@protoc_insertion_point(field_add:pulsar.proto.SingleMessageMetadata.properties)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>& SingleMessageMetadata::properties() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.SingleMessageMetadata.properties)
  return _internal_properties();
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>&
SingleMessageMetadata::_internal_properties() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.properties_;
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>*
SingleMessageMetadata::_internal_mutable_properties() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.properties_;
}

// optional string partition_key = 2;
inline bool SingleMessageMetadata::has_partition_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SingleMessageMetadata::clear_partition_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.partition_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SingleMessageMetadata::partition_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.partition_key)
  return _internal_partition_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SingleMessageMetadata::set_partition_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.partition_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.partition_key)
}
inline std::string* SingleMessageMetadata::mutable_partition_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_partition_key();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.SingleMessageMetadata.partition_key)
  return _s;
}
inline const std::string& SingleMessageMetadata::_internal_partition_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.partition_key_.Get();
}
inline void SingleMessageMetadata::_internal_set_partition_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.partition_key_.Set(value, GetArena());
}
inline std::string* SingleMessageMetadata::_internal_mutable_partition_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.partition_key_.Mutable( GetArena());
}
inline std::string* SingleMessageMetadata::release_partition_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.SingleMessageMetadata.partition_key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.partition_key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.partition_key_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SingleMessageMetadata::set_allocated_partition_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.partition_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.partition_key_.IsDefault()) {
          _impl_.partition_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.SingleMessageMetadata.partition_key)
}

// required int32 payload_size = 3;
inline bool SingleMessageMetadata::has_payload_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SingleMessageMetadata::clear_payload_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.payload_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SingleMessageMetadata::payload_size() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.payload_size)
  return _internal_payload_size();
}
inline void SingleMessageMetadata::set_payload_size(::int32_t value) {
  _internal_set_payload_size(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.payload_size)
}
inline ::int32_t SingleMessageMetadata::_internal_payload_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.payload_size_;
}
inline void SingleMessageMetadata::_internal_set_payload_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.payload_size_ = value;
}

// optional bool compacted_out = 4 [default = false];
inline bool SingleMessageMetadata::has_compacted_out() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SingleMessageMetadata::clear_compacted_out() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.compacted_out_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool SingleMessageMetadata::compacted_out() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.compacted_out)
  return _internal_compacted_out();
}
inline void SingleMessageMetadata::set_compacted_out(bool value) {
  _internal_set_compacted_out(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.compacted_out)
}
inline bool SingleMessageMetadata::_internal_compacted_out() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compacted_out_;
}
inline void SingleMessageMetadata::_internal_set_compacted_out(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.compacted_out_ = value;
}

// optional uint64 event_time = 5 [default = 0];
inline bool SingleMessageMetadata::has_event_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SingleMessageMetadata::clear_event_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.event_time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t SingleMessageMetadata::event_time() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.event_time)
  return _internal_event_time();
}
inline void SingleMessageMetadata::set_event_time(::uint64_t value) {
  _internal_set_event_time(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.event_time)
}
inline ::uint64_t SingleMessageMetadata::_internal_event_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.event_time_;
}
inline void SingleMessageMetadata::_internal_set_event_time(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.event_time_ = value;
}

// optional bool partition_key_b64_encoded = 6 [default = false];
inline bool SingleMessageMetadata::has_partition_key_b64_encoded() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SingleMessageMetadata::clear_partition_key_b64_encoded() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.partition_key_b64_encoded_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool SingleMessageMetadata::partition_key_b64_encoded() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.partition_key_b64_encoded)
  return _internal_partition_key_b64_encoded();
}
inline void SingleMessageMetadata::set_partition_key_b64_encoded(bool value) {
  _internal_set_partition_key_b64_encoded(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.partition_key_b64_encoded)
}
inline bool SingleMessageMetadata::_internal_partition_key_b64_encoded() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.partition_key_b64_encoded_;
}
inline void SingleMessageMetadata::_internal_set_partition_key_b64_encoded(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.partition_key_b64_encoded_ = value;
}

// optional bytes ordering_key = 7;
inline bool SingleMessageMetadata::has_ordering_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SingleMessageMetadata::clear_ordering_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ordering_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SingleMessageMetadata::ordering_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.ordering_key)
  return _internal_ordering_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SingleMessageMetadata::set_ordering_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ordering_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.ordering_key)
}
inline std::string* SingleMessageMetadata::mutable_ordering_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ordering_key();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.SingleMessageMetadata.ordering_key)
  return _s;
}
inline const std::string& SingleMessageMetadata::_internal_ordering_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ordering_key_.Get();
}
inline void SingleMessageMetadata::_internal_set_ordering_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ordering_key_.Set(value, GetArena());
}
inline std::string* SingleMessageMetadata::_internal_mutable_ordering_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ordering_key_.Mutable( GetArena());
}
inline std::string* SingleMessageMetadata::release_ordering_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.SingleMessageMetadata.ordering_key)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.ordering_key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ordering_key_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SingleMessageMetadata::set_allocated_ordering_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ordering_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ordering_key_.IsDefault()) {
          _impl_.ordering_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.SingleMessageMetadata.ordering_key)
}

// optional uint64 sequence_id = 8;
inline bool SingleMessageMetadata::has_sequence_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void SingleMessageMetadata::clear_sequence_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sequence_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint64_t SingleMessageMetadata::sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.sequence_id)
  return _internal_sequence_id();
}
inline void SingleMessageMetadata::set_sequence_id(::uint64_t value) {
  _internal_set_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.sequence_id)
}
inline ::uint64_t SingleMessageMetadata::_internal_sequence_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequence_id_;
}
inline void SingleMessageMetadata::_internal_set_sequence_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.sequence_id_ = value;
}

// optional bool null_value = 9 [default = false];
inline bool SingleMessageMetadata::has_null_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SingleMessageMetadata::clear_null_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.null_value_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool SingleMessageMetadata::null_value() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.null_value)
  return _internal_null_value();
}
inline void SingleMessageMetadata::set_null_value(bool value) {
  _internal_set_null_value(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.null_value)
}
inline bool SingleMessageMetadata::_internal_null_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.null_value_;
}
inline void SingleMessageMetadata::_internal_set_null_value(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.null_value_ = value;
}

// optional bool null_partition_key = 10 [default = false];
inline bool SingleMessageMetadata::has_null_partition_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void SingleMessageMetadata::clear_null_partition_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.null_partition_key_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool SingleMessageMetadata::null_partition_key() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.SingleMessageMetadata.null_partition_key)
  return _internal_null_partition_key();
}
inline void SingleMessageMetadata::set_null_partition_key(bool value) {
  _internal_set_null_partition_key(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.SingleMessageMetadata.null_partition_key)
}
inline bool SingleMessageMetadata::_internal_null_partition_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.null_partition_key_;
}
inline void SingleMessageMetadata::_internal_set_null_partition_key(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.null_partition_key_ = value;
}

// -------------------------------------------------------------------

// BrokerEntryMetadata

// optional uint64 broker_timestamp = 1;
inline bool BrokerEntryMetadata::has_broker_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BrokerEntryMetadata::clear_broker_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.broker_timestamp_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t BrokerEntryMetadata::broker_timestamp() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BrokerEntryMetadata.broker_timestamp)
  return _internal_broker_timestamp();
}
inline void BrokerEntryMetadata::set_broker_timestamp(::uint64_t value) {
  _internal_set_broker_timestamp(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.BrokerEntryMetadata.broker_timestamp)
}
inline ::uint64_t BrokerEntryMetadata::_internal_broker_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.broker_timestamp_;
}
inline void BrokerEntryMetadata::_internal_set_broker_timestamp(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.broker_timestamp_ = value;
}

// optional uint64 index = 2;
inline bool BrokerEntryMetadata::has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BrokerEntryMetadata::clear_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.index_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t BrokerEntryMetadata::index() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BrokerEntryMetadata.index)
  return _internal_index();
}
inline void BrokerEntryMetadata::set_index(::uint64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.BrokerEntryMetadata.index)
}
inline ::uint64_t BrokerEntryMetadata::_internal_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.index_;
}
inline void BrokerEntryMetadata::_internal_set_index(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.index_ = value;
}

// -------------------------------------------------------------------

// CommandConnect

// required string client_version = 1;
inline bool CommandConnect::has_client_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandConnect::clear_client_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandConnect::client_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.client_version)
  return _internal_client_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandConnect::set_client_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.client_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.client_version)
}
inline std::string* CommandConnect::mutable_client_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.client_version)
  return _s;
}
inline const std::string& CommandConnect::_internal_client_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.client_version_.Get();
}
inline void CommandConnect::_internal_set_client_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.client_version_.Set(value, GetArena());
}
inline std::string* CommandConnect::_internal_mutable_client_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.client_version_.Mutable( GetArena());
}
inline std::string* CommandConnect::release_client_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnect.client_version)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.client_version_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.client_version_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandConnect::set_allocated_client_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.client_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_version_.IsDefault()) {
          _impl_.client_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.client_version)
}

// optional .pulsar.proto.AuthMethod auth_method = 2;
inline bool CommandConnect::has_auth_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void CommandConnect::clear_auth_method() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.auth_method_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::pulsar::proto::AuthMethod CommandConnect::auth_method() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.auth_method)
  return _internal_auth_method();
}
inline void CommandConnect::set_auth_method(::pulsar::proto::AuthMethod value) {
  _internal_set_auth_method(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.auth_method)
}
inline ::pulsar::proto::AuthMethod CommandConnect::_internal_auth_method() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::AuthMethod>(_impl_.auth_method_);
}
inline void CommandConnect::_internal_set_auth_method(::pulsar::proto::AuthMethod value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::AuthMethod_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.auth_method_ = value;
}

// optional string auth_method_name = 5;
inline bool CommandConnect::has_auth_method_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandConnect::clear_auth_method_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.auth_method_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandConnect::auth_method_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.auth_method_name)
  return _internal_auth_method_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandConnect::set_auth_method_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.auth_method_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.auth_method_name)
}
inline std::string* CommandConnect::mutable_auth_method_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_auth_method_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.auth_method_name)
  return _s;
}
inline const std::string& CommandConnect::_internal_auth_method_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.auth_method_name_.Get();
}
inline void CommandConnect::_internal_set_auth_method_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.auth_method_name_.Set(value, GetArena());
}
inline std::string* CommandConnect::_internal_mutable_auth_method_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.auth_method_name_.Mutable( GetArena());
}
inline std::string* CommandConnect::release_auth_method_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnect.auth_method_name)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.auth_method_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.auth_method_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandConnect::set_allocated_auth_method_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.auth_method_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.auth_method_name_.IsDefault()) {
          _impl_.auth_method_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.auth_method_name)
}

// optional bytes auth_data = 3;
inline bool CommandConnect::has_auth_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandConnect::clear_auth_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.auth_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandConnect::auth_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.auth_data)
  return _internal_auth_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandConnect::set_auth_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.auth_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.auth_data)
}
inline std::string* CommandConnect::mutable_auth_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_auth_data();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.auth_data)
  return _s;
}
inline const std::string& CommandConnect::_internal_auth_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.auth_data_.Get();
}
inline void CommandConnect::_internal_set_auth_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.auth_data_.Set(value, GetArena());
}
inline std::string* CommandConnect::_internal_mutable_auth_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.auth_data_.Mutable( GetArena());
}
inline std::string* CommandConnect::release_auth_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnect.auth_data)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.auth_data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.auth_data_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandConnect::set_allocated_auth_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.auth_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.auth_data_.IsDefault()) {
          _impl_.auth_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.auth_data)
}

// optional int32 protocol_version = 4 [default = 0];
inline bool CommandConnect::has_protocol_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void CommandConnect::clear_protocol_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.protocol_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t CommandConnect::protocol_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.protocol_version)
  return _internal_protocol_version();
}
inline void CommandConnect::set_protocol_version(::int32_t value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.protocol_version)
}
inline ::int32_t CommandConnect::_internal_protocol_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.protocol_version_;
}
inline void CommandConnect::_internal_set_protocol_version(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.protocol_version_ = value;
}

// optional string proxy_to_broker_url = 6;
inline bool CommandConnect::has_proxy_to_broker_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandConnect::clear_proxy_to_broker_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.proxy_to_broker_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CommandConnect::proxy_to_broker_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.proxy_to_broker_url)
  return _internal_proxy_to_broker_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandConnect::set_proxy_to_broker_url(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.proxy_to_broker_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.proxy_to_broker_url)
}
inline std::string* CommandConnect::mutable_proxy_to_broker_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_proxy_to_broker_url();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.proxy_to_broker_url)
  return _s;
}
inline const std::string& CommandConnect::_internal_proxy_to_broker_url() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.proxy_to_broker_url_.Get();
}
inline void CommandConnect::_internal_set_proxy_to_broker_url(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.proxy_to_broker_url_.Set(value, GetArena());
}
inline std::string* CommandConnect::_internal_mutable_proxy_to_broker_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.proxy_to_broker_url_.Mutable( GetArena());
}
inline std::string* CommandConnect::release_proxy_to_broker_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnect.proxy_to_broker_url)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.proxy_to_broker_url_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.proxy_to_broker_url_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandConnect::set_allocated_proxy_to_broker_url(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.proxy_to_broker_url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proxy_to_broker_url_.IsDefault()) {
          _impl_.proxy_to_broker_url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.proxy_to_broker_url)
}

// optional string original_principal = 7;
inline bool CommandConnect::has_original_principal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandConnect::clear_original_principal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.original_principal_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CommandConnect::original_principal() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.original_principal)
  return _internal_original_principal();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandConnect::set_original_principal(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.original_principal_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.original_principal)
}
inline std::string* CommandConnect::mutable_original_principal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_original_principal();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.original_principal)
  return _s;
}
inline const std::string& CommandConnect::_internal_original_principal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.original_principal_.Get();
}
inline void CommandConnect::_internal_set_original_principal(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.original_principal_.Set(value, GetArena());
}
inline std::string* CommandConnect::_internal_mutable_original_principal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.original_principal_.Mutable( GetArena());
}
inline std::string* CommandConnect::release_original_principal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnect.original_principal)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.original_principal_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.original_principal_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandConnect::set_allocated_original_principal(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.original_principal_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.original_principal_.IsDefault()) {
          _impl_.original_principal_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.original_principal)
}

// optional string original_auth_data = 8;
inline bool CommandConnect::has_original_auth_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CommandConnect::clear_original_auth_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.original_auth_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CommandConnect::original_auth_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.original_auth_data)
  return _internal_original_auth_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandConnect::set_original_auth_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.original_auth_data_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.original_auth_data)
}
inline std::string* CommandConnect::mutable_original_auth_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_original_auth_data();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.original_auth_data)
  return _s;
}
inline const std::string& CommandConnect::_internal_original_auth_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.original_auth_data_.Get();
}
inline void CommandConnect::_internal_set_original_auth_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.original_auth_data_.Set(value, GetArena());
}
inline std::string* CommandConnect::_internal_mutable_original_auth_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.original_auth_data_.Mutable( GetArena());
}
inline std::string* CommandConnect::release_original_auth_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnect.original_auth_data)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.original_auth_data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.original_auth_data_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandConnect::set_allocated_original_auth_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.original_auth_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.original_auth_data_.IsDefault()) {
          _impl_.original_auth_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.original_auth_data)
}

// optional string original_auth_method = 9;
inline bool CommandConnect::has_original_auth_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void CommandConnect::clear_original_auth_method() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.original_auth_method_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CommandConnect::original_auth_method() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.original_auth_method)
  return _internal_original_auth_method();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandConnect::set_original_auth_method(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.original_auth_method_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnect.original_auth_method)
}
inline std::string* CommandConnect::mutable_original_auth_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_original_auth_method();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.original_auth_method)
  return _s;
}
inline const std::string& CommandConnect::_internal_original_auth_method() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.original_auth_method_.Get();
}
inline void CommandConnect::_internal_set_original_auth_method(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.original_auth_method_.Set(value, GetArena());
}
inline std::string* CommandConnect::_internal_mutable_original_auth_method() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.original_auth_method_.Mutable( GetArena());
}
inline std::string* CommandConnect::release_original_auth_method() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnect.original_auth_method)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.original_auth_method_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.original_auth_method_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandConnect::set_allocated_original_auth_method(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.original_auth_method_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.original_auth_method_.IsDefault()) {
          _impl_.original_auth_method_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.original_auth_method)
}

// optional .pulsar.proto.FeatureFlags feature_flags = 10;
inline bool CommandConnect::has_feature_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.feature_flags_ != nullptr);
  return value;
}
inline void CommandConnect::clear_feature_flags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.feature_flags_ != nullptr) _impl_.feature_flags_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::pulsar::proto::FeatureFlags& CommandConnect::_internal_feature_flags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::FeatureFlags* p = _impl_.feature_flags_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::FeatureFlags&>(::pulsar::proto::_FeatureFlags_default_instance_);
}
inline const ::pulsar::proto::FeatureFlags& CommandConnect::feature_flags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnect.feature_flags)
  return _internal_feature_flags();
}
inline void CommandConnect::unsafe_arena_set_allocated_feature_flags(::pulsar::proto::FeatureFlags* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.feature_flags_);
  }
  _impl_.feature_flags_ = reinterpret_cast<::pulsar::proto::FeatureFlags*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandConnect.feature_flags)
}
inline ::pulsar::proto::FeatureFlags* CommandConnect::release_feature_flags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::pulsar::proto::FeatureFlags* released = _impl_.feature_flags_;
  _impl_.feature_flags_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::FeatureFlags* CommandConnect::unsafe_arena_release_feature_flags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnect.feature_flags)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::pulsar::proto::FeatureFlags* temp = _impl_.feature_flags_;
  _impl_.feature_flags_ = nullptr;
  return temp;
}
inline ::pulsar::proto::FeatureFlags* CommandConnect::_internal_mutable_feature_flags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.feature_flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::FeatureFlags>(GetArena());
    _impl_.feature_flags_ = reinterpret_cast<::pulsar::proto::FeatureFlags*>(p);
  }
  return _impl_.feature_flags_;
}
inline ::pulsar::proto::FeatureFlags* CommandConnect::mutable_feature_flags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::FeatureFlags* _msg = _internal_mutable_feature_flags();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnect.feature_flags)
  return _msg;
}
inline void CommandConnect::set_allocated_feature_flags(::pulsar::proto::FeatureFlags* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::FeatureFlags*>(_impl_.feature_flags_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::FeatureFlags*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.feature_flags_ = reinterpret_cast<::pulsar::proto::FeatureFlags*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnect.feature_flags)
}

// -------------------------------------------------------------------

// FeatureFlags

// optional bool supports_auth_refresh = 1 [default = false];
inline bool FeatureFlags::has_supports_auth_refresh() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FeatureFlags::clear_supports_auth_refresh() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.supports_auth_refresh_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool FeatureFlags::supports_auth_refresh() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.FeatureFlags.supports_auth_refresh)
  return _internal_supports_auth_refresh();
}
inline void FeatureFlags::set_supports_auth_refresh(bool value) {
  _internal_set_supports_auth_refresh(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.FeatureFlags.supports_auth_refresh)
}
inline bool FeatureFlags::_internal_supports_auth_refresh() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.supports_auth_refresh_;
}
inline void FeatureFlags::_internal_set_supports_auth_refresh(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.supports_auth_refresh_ = value;
}

// optional bool supports_broker_entry_metadata = 2 [default = false];
inline bool FeatureFlags::has_supports_broker_entry_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FeatureFlags::clear_supports_broker_entry_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.supports_broker_entry_metadata_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool FeatureFlags::supports_broker_entry_metadata() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.FeatureFlags.supports_broker_entry_metadata)
  return _internal_supports_broker_entry_metadata();
}
inline void FeatureFlags::set_supports_broker_entry_metadata(bool value) {
  _internal_set_supports_broker_entry_metadata(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.FeatureFlags.supports_broker_entry_metadata)
}
inline bool FeatureFlags::_internal_supports_broker_entry_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.supports_broker_entry_metadata_;
}
inline void FeatureFlags::_internal_set_supports_broker_entry_metadata(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.supports_broker_entry_metadata_ = value;
}

// optional bool supports_partial_producer = 3 [default = false];
inline bool FeatureFlags::has_supports_partial_producer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FeatureFlags::clear_supports_partial_producer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.supports_partial_producer_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool FeatureFlags::supports_partial_producer() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.FeatureFlags.supports_partial_producer)
  return _internal_supports_partial_producer();
}
inline void FeatureFlags::set_supports_partial_producer(bool value) {
  _internal_set_supports_partial_producer(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.FeatureFlags.supports_partial_producer)
}
inline bool FeatureFlags::_internal_supports_partial_producer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.supports_partial_producer_;
}
inline void FeatureFlags::_internal_set_supports_partial_producer(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.supports_partial_producer_ = value;
}

// optional bool supports_topic_watchers = 4 [default = false];
inline bool FeatureFlags::has_supports_topic_watchers() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FeatureFlags::clear_supports_topic_watchers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.supports_topic_watchers_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool FeatureFlags::supports_topic_watchers() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.FeatureFlags.supports_topic_watchers)
  return _internal_supports_topic_watchers();
}
inline void FeatureFlags::set_supports_topic_watchers(bool value) {
  _internal_set_supports_topic_watchers(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.FeatureFlags.supports_topic_watchers)
}
inline bool FeatureFlags::_internal_supports_topic_watchers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.supports_topic_watchers_;
}
inline void FeatureFlags::_internal_set_supports_topic_watchers(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.supports_topic_watchers_ = value;
}

// -------------------------------------------------------------------

// CommandConnected

// required string server_version = 1;
inline bool CommandConnected::has_server_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandConnected::clear_server_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.server_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandConnected::server_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnected.server_version)
  return _internal_server_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandConnected::set_server_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.server_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnected.server_version)
}
inline std::string* CommandConnected::mutable_server_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_server_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnected.server_version)
  return _s;
}
inline const std::string& CommandConnected::_internal_server_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.server_version_.Get();
}
inline void CommandConnected::_internal_set_server_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.server_version_.Set(value, GetArena());
}
inline std::string* CommandConnected::_internal_mutable_server_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.server_version_.Mutable( GetArena());
}
inline std::string* CommandConnected::release_server_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnected.server_version)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.server_version_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.server_version_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandConnected::set_allocated_server_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.server_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.server_version_.IsDefault()) {
          _impl_.server_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnected.server_version)
}

// optional int32 protocol_version = 2 [default = 0];
inline bool CommandConnected::has_protocol_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandConnected::clear_protocol_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.protocol_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t CommandConnected::protocol_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnected.protocol_version)
  return _internal_protocol_version();
}
inline void CommandConnected::set_protocol_version(::int32_t value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnected.protocol_version)
}
inline ::int32_t CommandConnected::_internal_protocol_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.protocol_version_;
}
inline void CommandConnected::_internal_set_protocol_version(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.protocol_version_ = value;
}

// optional int32 max_message_size = 3;
inline bool CommandConnected::has_max_message_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandConnected::clear_max_message_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_message_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t CommandConnected::max_message_size() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnected.max_message_size)
  return _internal_max_message_size();
}
inline void CommandConnected::set_max_message_size(::int32_t value) {
  _internal_set_max_message_size(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConnected.max_message_size)
}
inline ::int32_t CommandConnected::_internal_max_message_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_message_size_;
}
inline void CommandConnected::_internal_set_max_message_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.max_message_size_ = value;
}

// optional .pulsar.proto.FeatureFlags feature_flags = 4;
inline bool CommandConnected::has_feature_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.feature_flags_ != nullptr);
  return value;
}
inline void CommandConnected::clear_feature_flags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.feature_flags_ != nullptr) _impl_.feature_flags_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::pulsar::proto::FeatureFlags& CommandConnected::_internal_feature_flags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::FeatureFlags* p = _impl_.feature_flags_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::FeatureFlags&>(::pulsar::proto::_FeatureFlags_default_instance_);
}
inline const ::pulsar::proto::FeatureFlags& CommandConnected::feature_flags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConnected.feature_flags)
  return _internal_feature_flags();
}
inline void CommandConnected::unsafe_arena_set_allocated_feature_flags(::pulsar::proto::FeatureFlags* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.feature_flags_);
  }
  _impl_.feature_flags_ = reinterpret_cast<::pulsar::proto::FeatureFlags*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandConnected.feature_flags)
}
inline ::pulsar::proto::FeatureFlags* CommandConnected::release_feature_flags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::FeatureFlags* released = _impl_.feature_flags_;
  _impl_.feature_flags_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::FeatureFlags* CommandConnected::unsafe_arena_release_feature_flags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConnected.feature_flags)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::FeatureFlags* temp = _impl_.feature_flags_;
  _impl_.feature_flags_ = nullptr;
  return temp;
}
inline ::pulsar::proto::FeatureFlags* CommandConnected::_internal_mutable_feature_flags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.feature_flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::FeatureFlags>(GetArena());
    _impl_.feature_flags_ = reinterpret_cast<::pulsar::proto::FeatureFlags*>(p);
  }
  return _impl_.feature_flags_;
}
inline ::pulsar::proto::FeatureFlags* CommandConnected::mutable_feature_flags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::FeatureFlags* _msg = _internal_mutable_feature_flags();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConnected.feature_flags)
  return _msg;
}
inline void CommandConnected::set_allocated_feature_flags(::pulsar::proto::FeatureFlags* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::FeatureFlags*>(_impl_.feature_flags_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::FeatureFlags*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.feature_flags_ = reinterpret_cast<::pulsar::proto::FeatureFlags*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConnected.feature_flags)
}

// -------------------------------------------------------------------

// CommandAuthResponse

// optional string client_version = 1;
inline bool CommandAuthResponse::has_client_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandAuthResponse::clear_client_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandAuthResponse::client_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthResponse.client_version)
  return _internal_client_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandAuthResponse::set_client_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.client_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAuthResponse.client_version)
}
inline std::string* CommandAuthResponse::mutable_client_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAuthResponse.client_version)
  return _s;
}
inline const std::string& CommandAuthResponse::_internal_client_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.client_version_.Get();
}
inline void CommandAuthResponse::_internal_set_client_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.client_version_.Set(value, GetArena());
}
inline std::string* CommandAuthResponse::_internal_mutable_client_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.client_version_.Mutable( GetArena());
}
inline std::string* CommandAuthResponse::release_client_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandAuthResponse.client_version)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.client_version_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.client_version_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandAuthResponse::set_allocated_client_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.client_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_version_.IsDefault()) {
          _impl_.client_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAuthResponse.client_version)
}

// optional .pulsar.proto.AuthData response = 2;
inline bool CommandAuthResponse::has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.response_ != nullptr);
  return value;
}
inline void CommandAuthResponse::clear_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.response_ != nullptr) _impl_.response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::pulsar::proto::AuthData& CommandAuthResponse::_internal_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::AuthData* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::AuthData&>(::pulsar::proto::_AuthData_default_instance_);
}
inline const ::pulsar::proto::AuthData& CommandAuthResponse::response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthResponse.response)
  return _internal_response();
}
inline void CommandAuthResponse::unsafe_arena_set_allocated_response(::pulsar::proto::AuthData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = reinterpret_cast<::pulsar::proto::AuthData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandAuthResponse.response)
}
inline ::pulsar::proto::AuthData* CommandAuthResponse::release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::AuthData* released = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::AuthData* CommandAuthResponse::unsafe_arena_release_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandAuthResponse.response)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::AuthData* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::pulsar::proto::AuthData* CommandAuthResponse::_internal_mutable_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::AuthData>(GetArena());
    _impl_.response_ = reinterpret_cast<::pulsar::proto::AuthData*>(p);
  }
  return _impl_.response_;
}
inline ::pulsar::proto::AuthData* CommandAuthResponse::mutable_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::AuthData* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAuthResponse.response)
  return _msg;
}
inline void CommandAuthResponse::set_allocated_response(::pulsar::proto::AuthData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::AuthData*>(_impl_.response_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::AuthData*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.response_ = reinterpret_cast<::pulsar::proto::AuthData*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAuthResponse.response)
}

// optional int32 protocol_version = 3 [default = 0];
inline bool CommandAuthResponse::has_protocol_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandAuthResponse::clear_protocol_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.protocol_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t CommandAuthResponse::protocol_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthResponse.protocol_version)
  return _internal_protocol_version();
}
inline void CommandAuthResponse::set_protocol_version(::int32_t value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAuthResponse.protocol_version)
}
inline ::int32_t CommandAuthResponse::_internal_protocol_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.protocol_version_;
}
inline void CommandAuthResponse::_internal_set_protocol_version(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.protocol_version_ = value;
}

// -------------------------------------------------------------------

// CommandAuthChallenge

// optional string server_version = 1;
inline bool CommandAuthChallenge::has_server_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandAuthChallenge::clear_server_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.server_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandAuthChallenge::server_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthChallenge.server_version)
  return _internal_server_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandAuthChallenge::set_server_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.server_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAuthChallenge.server_version)
}
inline std::string* CommandAuthChallenge::mutable_server_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_server_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAuthChallenge.server_version)
  return _s;
}
inline const std::string& CommandAuthChallenge::_internal_server_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.server_version_.Get();
}
inline void CommandAuthChallenge::_internal_set_server_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.server_version_.Set(value, GetArena());
}
inline std::string* CommandAuthChallenge::_internal_mutable_server_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.server_version_.Mutable( GetArena());
}
inline std::string* CommandAuthChallenge::release_server_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandAuthChallenge.server_version)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.server_version_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.server_version_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandAuthChallenge::set_allocated_server_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.server_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.server_version_.IsDefault()) {
          _impl_.server_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAuthChallenge.server_version)
}

// optional .pulsar.proto.AuthData challenge = 2;
inline bool CommandAuthChallenge::has_challenge() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.challenge_ != nullptr);
  return value;
}
inline void CommandAuthChallenge::clear_challenge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.challenge_ != nullptr) _impl_.challenge_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::pulsar::proto::AuthData& CommandAuthChallenge::_internal_challenge() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::AuthData* p = _impl_.challenge_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::AuthData&>(::pulsar::proto::_AuthData_default_instance_);
}
inline const ::pulsar::proto::AuthData& CommandAuthChallenge::challenge() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthChallenge.challenge)
  return _internal_challenge();
}
inline void CommandAuthChallenge::unsafe_arena_set_allocated_challenge(::pulsar::proto::AuthData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.challenge_);
  }
  _impl_.challenge_ = reinterpret_cast<::pulsar::proto::AuthData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandAuthChallenge.challenge)
}
inline ::pulsar::proto::AuthData* CommandAuthChallenge::release_challenge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::AuthData* released = _impl_.challenge_;
  _impl_.challenge_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::AuthData* CommandAuthChallenge::unsafe_arena_release_challenge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandAuthChallenge.challenge)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::AuthData* temp = _impl_.challenge_;
  _impl_.challenge_ = nullptr;
  return temp;
}
inline ::pulsar::proto::AuthData* CommandAuthChallenge::_internal_mutable_challenge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.challenge_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::AuthData>(GetArena());
    _impl_.challenge_ = reinterpret_cast<::pulsar::proto::AuthData*>(p);
  }
  return _impl_.challenge_;
}
inline ::pulsar::proto::AuthData* CommandAuthChallenge::mutable_challenge() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::AuthData* _msg = _internal_mutable_challenge();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAuthChallenge.challenge)
  return _msg;
}
inline void CommandAuthChallenge::set_allocated_challenge(::pulsar::proto::AuthData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::AuthData*>(_impl_.challenge_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::AuthData*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.challenge_ = reinterpret_cast<::pulsar::proto::AuthData*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAuthChallenge.challenge)
}

// optional int32 protocol_version = 3 [default = 0];
inline bool CommandAuthChallenge::has_protocol_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandAuthChallenge::clear_protocol_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.protocol_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t CommandAuthChallenge::protocol_version() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAuthChallenge.protocol_version)
  return _internal_protocol_version();
}
inline void CommandAuthChallenge::set_protocol_version(::int32_t value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAuthChallenge.protocol_version)
}
inline ::int32_t CommandAuthChallenge::_internal_protocol_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.protocol_version_;
}
inline void CommandAuthChallenge::_internal_set_protocol_version(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.protocol_version_ = value;
}

// -------------------------------------------------------------------

// AuthData

// optional string auth_method_name = 1;
inline bool AuthData::has_auth_method_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AuthData::clear_auth_method_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.auth_method_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AuthData::auth_method_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.AuthData.auth_method_name)
  return _internal_auth_method_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthData::set_auth_method_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.auth_method_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.AuthData.auth_method_name)
}
inline std::string* AuthData::mutable_auth_method_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_auth_method_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.AuthData.auth_method_name)
  return _s;
}
inline const std::string& AuthData::_internal_auth_method_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.auth_method_name_.Get();
}
inline void AuthData::_internal_set_auth_method_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.auth_method_name_.Set(value, GetArena());
}
inline std::string* AuthData::_internal_mutable_auth_method_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.auth_method_name_.Mutable( GetArena());
}
inline std::string* AuthData::release_auth_method_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.AuthData.auth_method_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.auth_method_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.auth_method_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AuthData::set_allocated_auth_method_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.auth_method_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.auth_method_name_.IsDefault()) {
          _impl_.auth_method_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.AuthData.auth_method_name)
}

// optional bytes auth_data = 2;
inline bool AuthData::has_auth_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AuthData::clear_auth_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.auth_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AuthData::auth_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.AuthData.auth_data)
  return _internal_auth_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AuthData::set_auth_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.auth_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.AuthData.auth_data)
}
inline std::string* AuthData::mutable_auth_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_auth_data();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.AuthData.auth_data)
  return _s;
}
inline const std::string& AuthData::_internal_auth_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.auth_data_.Get();
}
inline void AuthData::_internal_set_auth_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.auth_data_.Set(value, GetArena());
}
inline std::string* AuthData::_internal_mutable_auth_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.auth_data_.Mutable( GetArena());
}
inline std::string* AuthData::release_auth_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.AuthData.auth_data)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.auth_data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.auth_data_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AuthData::set_allocated_auth_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.auth_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.auth_data_.IsDefault()) {
          _impl_.auth_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.AuthData.auth_data)
}

// -------------------------------------------------------------------

// KeySharedMeta

// required .pulsar.proto.KeySharedMode keySharedMode = 1;
inline bool KeySharedMeta::has_keysharedmode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void KeySharedMeta::clear_keysharedmode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.keysharedmode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::pulsar::proto::KeySharedMode KeySharedMeta::keysharedmode() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeySharedMeta.keySharedMode)
  return _internal_keysharedmode();
}
inline void KeySharedMeta::set_keysharedmode(::pulsar::proto::KeySharedMode value) {
  _internal_set_keysharedmode(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.KeySharedMeta.keySharedMode)
}
inline ::pulsar::proto::KeySharedMode KeySharedMeta::_internal_keysharedmode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::KeySharedMode>(_impl_.keysharedmode_);
}
inline void KeySharedMeta::_internal_set_keysharedmode(::pulsar::proto::KeySharedMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::KeySharedMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.keysharedmode_ = value;
}

// repeated .pulsar.proto.IntRange hashRanges = 3;
inline int KeySharedMeta::_internal_hashranges_size() const {
  return _internal_hashranges().size();
}
inline int KeySharedMeta::hashranges_size() const {
  return _internal_hashranges_size();
}
inline void KeySharedMeta::clear_hashranges() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hashranges_.Clear();
}
inline ::pulsar::proto::IntRange* KeySharedMeta::mutable_hashranges(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.KeySharedMeta.hashRanges)
  return _internal_mutable_hashranges()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::IntRange>* KeySharedMeta::mutable_hashranges()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.KeySharedMeta.hashRanges)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_hashranges();
}
inline const ::pulsar::proto::IntRange& KeySharedMeta::hashranges(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeySharedMeta.hashRanges)
  return _internal_hashranges().Get(index);
}
inline ::pulsar::proto::IntRange* KeySharedMeta::add_hashranges() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pulsar::proto::IntRange* _add = _internal_mutable_hashranges()->Add();
  // @@protoc_insertion_point(field_add:pulsar.proto.KeySharedMeta.hashRanges)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::IntRange>& KeySharedMeta::hashranges() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.KeySharedMeta.hashRanges)
  return _internal_hashranges();
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::IntRange>&
KeySharedMeta::_internal_hashranges() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hashranges_;
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::IntRange>*
KeySharedMeta::_internal_mutable_hashranges() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.hashranges_;
}

// optional bool allowOutOfOrderDelivery = 4 [default = false];
inline bool KeySharedMeta::has_allowoutoforderdelivery() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void KeySharedMeta::clear_allowoutoforderdelivery() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allowoutoforderdelivery_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool KeySharedMeta::allowoutoforderdelivery() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.KeySharedMeta.allowOutOfOrderDelivery)
  return _internal_allowoutoforderdelivery();
}
inline void KeySharedMeta::set_allowoutoforderdelivery(bool value) {
  _internal_set_allowoutoforderdelivery(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.KeySharedMeta.allowOutOfOrderDelivery)
}
inline bool KeySharedMeta::_internal_allowoutoforderdelivery() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allowoutoforderdelivery_;
}
inline void KeySharedMeta::_internal_set_allowoutoforderdelivery(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.allowoutoforderdelivery_ = value;
}

// -------------------------------------------------------------------

// CommandSubscribe

// required string topic = 1;
inline bool CommandSubscribe::has_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandSubscribe::clear_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandSubscribe::topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.topic)
  return _internal_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandSubscribe::set_topic(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.topic)
}
inline std::string* CommandSubscribe::mutable_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.topic)
  return _s;
}
inline const std::string& CommandSubscribe::_internal_topic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_.Get();
}
inline void CommandSubscribe::_internal_set_topic(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(value, GetArena());
}
inline std::string* CommandSubscribe::_internal_mutable_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.topic_.Mutable( GetArena());
}
inline std::string* CommandSubscribe::release_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSubscribe.topic)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.topic_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topic_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandSubscribe::set_allocated_topic(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.topic_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topic_.IsDefault()) {
          _impl_.topic_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSubscribe.topic)
}

// required string subscription = 2;
inline bool CommandSubscribe::has_subscription() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandSubscribe::clear_subscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subscription_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandSubscribe::subscription() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.subscription)
  return _internal_subscription();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandSubscribe::set_subscription(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subscription_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.subscription)
}
inline std::string* CommandSubscribe::mutable_subscription() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.subscription)
  return _s;
}
inline const std::string& CommandSubscribe::_internal_subscription() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subscription_.Get();
}
inline void CommandSubscribe::_internal_set_subscription(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subscription_.Set(value, GetArena());
}
inline std::string* CommandSubscribe::_internal_mutable_subscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.subscription_.Mutable( GetArena());
}
inline std::string* CommandSubscribe::release_subscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSubscribe.subscription)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.subscription_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subscription_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandSubscribe::set_allocated_subscription(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.subscription_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subscription_.IsDefault()) {
          _impl_.subscription_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSubscribe.subscription)
}

// required .pulsar.proto.CommandSubscribe.SubType subType = 3;
inline bool CommandSubscribe::has_subtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void CommandSubscribe::clear_subtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::pulsar::proto::CommandSubscribe_SubType CommandSubscribe::subtype() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.subType)
  return _internal_subtype();
}
inline void CommandSubscribe::set_subtype(::pulsar::proto::CommandSubscribe_SubType value) {
  _internal_set_subtype(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.subType)
}
inline ::pulsar::proto::CommandSubscribe_SubType CommandSubscribe::_internal_subtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::CommandSubscribe_SubType>(_impl_.subtype_);
}
inline void CommandSubscribe::_internal_set_subtype(::pulsar::proto::CommandSubscribe_SubType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::CommandSubscribe_SubType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.subtype_ = value;
}

// required uint64 consumer_id = 4;
inline bool CommandSubscribe::has_consumer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void CommandSubscribe::clear_consumer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t CommandSubscribe::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.consumer_id)
  return _internal_consumer_id();
}
inline void CommandSubscribe::set_consumer_id(::uint64_t value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.consumer_id)
}
inline ::uint64_t CommandSubscribe::_internal_consumer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumer_id_;
}
inline void CommandSubscribe::_internal_set_consumer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.consumer_id_ = value;
}

// required uint64 request_id = 5;
inline bool CommandSubscribe::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void CommandSubscribe::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint64_t CommandSubscribe::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.request_id)
  return _internal_request_id();
}
inline void CommandSubscribe::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.request_id)
}
inline ::uint64_t CommandSubscribe::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandSubscribe::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.request_id_ = value;
}

// optional string consumer_name = 6;
inline bool CommandSubscribe::has_consumer_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandSubscribe::clear_consumer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumer_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandSubscribe::consumer_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.consumer_name)
  return _internal_consumer_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandSubscribe::set_consumer_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.consumer_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.consumer_name)
}
inline std::string* CommandSubscribe::mutable_consumer_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_consumer_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.consumer_name)
  return _s;
}
inline const std::string& CommandSubscribe::_internal_consumer_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumer_name_.Get();
}
inline void CommandSubscribe::_internal_set_consumer_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.consumer_name_.Set(value, GetArena());
}
inline std::string* CommandSubscribe::_internal_mutable_consumer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.consumer_name_.Mutable( GetArena());
}
inline std::string* CommandSubscribe::release_consumer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSubscribe.consumer_name)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.consumer_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.consumer_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandSubscribe::set_allocated_consumer_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.consumer_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.consumer_name_.IsDefault()) {
          _impl_.consumer_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSubscribe.consumer_name)
}

// optional int32 priority_level = 7;
inline bool CommandSubscribe::has_priority_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void CommandSubscribe::clear_priority_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.priority_level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t CommandSubscribe::priority_level() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.priority_level)
  return _internal_priority_level();
}
inline void CommandSubscribe::set_priority_level(::int32_t value) {
  _internal_set_priority_level(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.priority_level)
}
inline ::int32_t CommandSubscribe::_internal_priority_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.priority_level_;
}
inline void CommandSubscribe::_internal_set_priority_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.priority_level_ = value;
}

// optional bool durable = 8 [default = true];
inline bool CommandSubscribe::has_durable() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void CommandSubscribe::clear_durable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.durable_ = true;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool CommandSubscribe::durable() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.durable)
  return _internal_durable();
}
inline void CommandSubscribe::set_durable(bool value) {
  _internal_set_durable(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.durable)
}
inline bool CommandSubscribe::_internal_durable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.durable_;
}
inline void CommandSubscribe::_internal_set_durable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.durable_ = value;
}

// optional .pulsar.proto.MessageIdData start_message_id = 9;
inline bool CommandSubscribe::has_start_message_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_message_id_ != nullptr);
  return value;
}
inline void CommandSubscribe::clear_start_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.start_message_id_ != nullptr) _impl_.start_message_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::pulsar::proto::MessageIdData& CommandSubscribe::_internal_start_message_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::MessageIdData* p = _impl_.start_message_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::MessageIdData&>(::pulsar::proto::_MessageIdData_default_instance_);
}
inline const ::pulsar::proto::MessageIdData& CommandSubscribe::start_message_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.start_message_id)
  return _internal_start_message_id();
}
inline void CommandSubscribe::unsafe_arena_set_allocated_start_message_id(::pulsar::proto::MessageIdData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_message_id_);
  }
  _impl_.start_message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandSubscribe.start_message_id)
}
inline ::pulsar::proto::MessageIdData* CommandSubscribe::release_start_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::pulsar::proto::MessageIdData* released = _impl_.start_message_id_;
  _impl_.start_message_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::MessageIdData* CommandSubscribe::unsafe_arena_release_start_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSubscribe.start_message_id)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::pulsar::proto::MessageIdData* temp = _impl_.start_message_id_;
  _impl_.start_message_id_ = nullptr;
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandSubscribe::_internal_mutable_start_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.start_message_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::MessageIdData>(GetArena());
    _impl_.start_message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(p);
  }
  return _impl_.start_message_id_;
}
inline ::pulsar::proto::MessageIdData* CommandSubscribe::mutable_start_message_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::MessageIdData* _msg = _internal_mutable_start_message_id();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.start_message_id)
  return _msg;
}
inline void CommandSubscribe::set_allocated_start_message_id(::pulsar::proto::MessageIdData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::MessageIdData*>(_impl_.start_message_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::MessageIdData*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.start_message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSubscribe.start_message_id)
}

// repeated .pulsar.proto.KeyValue metadata = 10;
inline int CommandSubscribe::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int CommandSubscribe::metadata_size() const {
  return _internal_metadata_size();
}
inline void CommandSubscribe::clear_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metadata_.Clear();
}
inline ::pulsar::proto::KeyValue* CommandSubscribe::mutable_metadata(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.metadata)
  return _internal_mutable_metadata()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>* CommandSubscribe::mutable_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandSubscribe.metadata)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_metadata();
}
inline const ::pulsar::proto::KeyValue& CommandSubscribe::metadata(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.metadata)
  return _internal_metadata().Get(index);
}
inline ::pulsar::proto::KeyValue* CommandSubscribe::add_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pulsar::proto::KeyValue* _add = _internal_mutable_metadata()->Add();
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandSubscribe.metadata)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>& CommandSubscribe::metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandSubscribe.metadata)
  return _internal_metadata();
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>&
CommandSubscribe::_internal_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metadata_;
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>*
CommandSubscribe::_internal_mutable_metadata() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.metadata_;
}

// optional bool read_compacted = 11;
inline bool CommandSubscribe::has_read_compacted() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void CommandSubscribe::clear_read_compacted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.read_compacted_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool CommandSubscribe::read_compacted() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.read_compacted)
  return _internal_read_compacted();
}
inline void CommandSubscribe::set_read_compacted(bool value) {
  _internal_set_read_compacted(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.read_compacted)
}
inline bool CommandSubscribe::_internal_read_compacted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.read_compacted_;
}
inline void CommandSubscribe::_internal_set_read_compacted(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.read_compacted_ = value;
}

// optional .pulsar.proto.Schema schema = 12;
inline bool CommandSubscribe::has_schema() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schema_ != nullptr);
  return value;
}
inline void CommandSubscribe::clear_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.schema_ != nullptr) _impl_.schema_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::pulsar::proto::Schema& CommandSubscribe::_internal_schema() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::Schema* p = _impl_.schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::Schema&>(::pulsar::proto::_Schema_default_instance_);
}
inline const ::pulsar::proto::Schema& CommandSubscribe::schema() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.schema)
  return _internal_schema();
}
inline void CommandSubscribe::unsafe_arena_set_allocated_schema(::pulsar::proto::Schema* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.schema_);
  }
  _impl_.schema_ = reinterpret_cast<::pulsar::proto::Schema*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandSubscribe.schema)
}
inline ::pulsar::proto::Schema* CommandSubscribe::release_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::pulsar::proto::Schema* released = _impl_.schema_;
  _impl_.schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::Schema* CommandSubscribe::unsafe_arena_release_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSubscribe.schema)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::pulsar::proto::Schema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
  return temp;
}
inline ::pulsar::proto::Schema* CommandSubscribe::_internal_mutable_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::Schema>(GetArena());
    _impl_.schema_ = reinterpret_cast<::pulsar::proto::Schema*>(p);
  }
  return _impl_.schema_;
}
inline ::pulsar::proto::Schema* CommandSubscribe::mutable_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::Schema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.schema)
  return _msg;
}
inline void CommandSubscribe::set_allocated_schema(::pulsar::proto::Schema* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::Schema*>(_impl_.schema_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::Schema*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.schema_ = reinterpret_cast<::pulsar::proto::Schema*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSubscribe.schema)
}

// optional .pulsar.proto.CommandSubscribe.InitialPosition initialPosition = 13 [default = Latest];
inline bool CommandSubscribe::has_initialposition() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void CommandSubscribe::clear_initialposition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.initialposition_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::pulsar::proto::CommandSubscribe_InitialPosition CommandSubscribe::initialposition() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.initialPosition)
  return _internal_initialposition();
}
inline void CommandSubscribe::set_initialposition(::pulsar::proto::CommandSubscribe_InitialPosition value) {
  _internal_set_initialposition(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.initialPosition)
}
inline ::pulsar::proto::CommandSubscribe_InitialPosition CommandSubscribe::_internal_initialposition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::CommandSubscribe_InitialPosition>(_impl_.initialposition_);
}
inline void CommandSubscribe::_internal_set_initialposition(::pulsar::proto::CommandSubscribe_InitialPosition value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::CommandSubscribe_InitialPosition_IsValid(value));
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.initialposition_ = value;
}

// optional bool replicate_subscription_state = 14;
inline bool CommandSubscribe::has_replicate_subscription_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void CommandSubscribe::clear_replicate_subscription_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.replicate_subscription_state_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool CommandSubscribe::replicate_subscription_state() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.replicate_subscription_state)
  return _internal_replicate_subscription_state();
}
inline void CommandSubscribe::set_replicate_subscription_state(bool value) {
  _internal_set_replicate_subscription_state(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.replicate_subscription_state)
}
inline bool CommandSubscribe::_internal_replicate_subscription_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.replicate_subscription_state_;
}
inline void CommandSubscribe::_internal_set_replicate_subscription_state(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.replicate_subscription_state_ = value;
}

// optional bool force_topic_creation = 15 [default = true];
inline bool CommandSubscribe::has_force_topic_creation() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void CommandSubscribe::clear_force_topic_creation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.force_topic_creation_ = true;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool CommandSubscribe::force_topic_creation() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.force_topic_creation)
  return _internal_force_topic_creation();
}
inline void CommandSubscribe::set_force_topic_creation(bool value) {
  _internal_set_force_topic_creation(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.force_topic_creation)
}
inline bool CommandSubscribe::_internal_force_topic_creation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.force_topic_creation_;
}
inline void CommandSubscribe::_internal_set_force_topic_creation(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.force_topic_creation_ = value;
}

// optional uint64 start_message_rollback_duration_sec = 16 [default = 0];
inline bool CommandSubscribe::has_start_message_rollback_duration_sec() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void CommandSubscribe::clear_start_message_rollback_duration_sec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_message_rollback_duration_sec_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::uint64_t CommandSubscribe::start_message_rollback_duration_sec() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.start_message_rollback_duration_sec)
  return _internal_start_message_rollback_duration_sec();
}
inline void CommandSubscribe::set_start_message_rollback_duration_sec(::uint64_t value) {
  _internal_set_start_message_rollback_duration_sec(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.start_message_rollback_duration_sec)
}
inline ::uint64_t CommandSubscribe::_internal_start_message_rollback_duration_sec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_message_rollback_duration_sec_;
}
inline void CommandSubscribe::_internal_set_start_message_rollback_duration_sec(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.start_message_rollback_duration_sec_ = value;
}

// optional .pulsar.proto.KeySharedMeta keySharedMeta = 17;
inline bool CommandSubscribe::has_keysharedmeta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.keysharedmeta_ != nullptr);
  return value;
}
inline void CommandSubscribe::clear_keysharedmeta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.keysharedmeta_ != nullptr) _impl_.keysharedmeta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::pulsar::proto::KeySharedMeta& CommandSubscribe::_internal_keysharedmeta() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::KeySharedMeta* p = _impl_.keysharedmeta_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::KeySharedMeta&>(::pulsar::proto::_KeySharedMeta_default_instance_);
}
inline const ::pulsar::proto::KeySharedMeta& CommandSubscribe::keysharedmeta() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.keySharedMeta)
  return _internal_keysharedmeta();
}
inline void CommandSubscribe::unsafe_arena_set_allocated_keysharedmeta(::pulsar::proto::KeySharedMeta* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.keysharedmeta_);
  }
  _impl_.keysharedmeta_ = reinterpret_cast<::pulsar::proto::KeySharedMeta*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandSubscribe.keySharedMeta)
}
inline ::pulsar::proto::KeySharedMeta* CommandSubscribe::release_keysharedmeta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::pulsar::proto::KeySharedMeta* released = _impl_.keysharedmeta_;
  _impl_.keysharedmeta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::KeySharedMeta* CommandSubscribe::unsafe_arena_release_keysharedmeta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSubscribe.keySharedMeta)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::pulsar::proto::KeySharedMeta* temp = _impl_.keysharedmeta_;
  _impl_.keysharedmeta_ = nullptr;
  return temp;
}
inline ::pulsar::proto::KeySharedMeta* CommandSubscribe::_internal_mutable_keysharedmeta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.keysharedmeta_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::KeySharedMeta>(GetArena());
    _impl_.keysharedmeta_ = reinterpret_cast<::pulsar::proto::KeySharedMeta*>(p);
  }
  return _impl_.keysharedmeta_;
}
inline ::pulsar::proto::KeySharedMeta* CommandSubscribe::mutable_keysharedmeta() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::KeySharedMeta* _msg = _internal_mutable_keysharedmeta();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.keySharedMeta)
  return _msg;
}
inline void CommandSubscribe::set_allocated_keysharedmeta(::pulsar::proto::KeySharedMeta* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::KeySharedMeta*>(_impl_.keysharedmeta_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::KeySharedMeta*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.keysharedmeta_ = reinterpret_cast<::pulsar::proto::KeySharedMeta*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSubscribe.keySharedMeta)
}

// repeated .pulsar.proto.KeyValue subscription_properties = 18;
inline int CommandSubscribe::_internal_subscription_properties_size() const {
  return _internal_subscription_properties().size();
}
inline int CommandSubscribe::subscription_properties_size() const {
  return _internal_subscription_properties_size();
}
inline void CommandSubscribe::clear_subscription_properties() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subscription_properties_.Clear();
}
inline ::pulsar::proto::KeyValue* CommandSubscribe::mutable_subscription_properties(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSubscribe.subscription_properties)
  return _internal_mutable_subscription_properties()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>* CommandSubscribe::mutable_subscription_properties()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandSubscribe.subscription_properties)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_subscription_properties();
}
inline const ::pulsar::proto::KeyValue& CommandSubscribe::subscription_properties(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.subscription_properties)
  return _internal_subscription_properties().Get(index);
}
inline ::pulsar::proto::KeyValue* CommandSubscribe::add_subscription_properties() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pulsar::proto::KeyValue* _add = _internal_mutable_subscription_properties()->Add();
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandSubscribe.subscription_properties)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>& CommandSubscribe::subscription_properties() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandSubscribe.subscription_properties)
  return _internal_subscription_properties();
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>&
CommandSubscribe::_internal_subscription_properties() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subscription_properties_;
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>*
CommandSubscribe::_internal_mutable_subscription_properties() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.subscription_properties_;
}

// optional uint64 consumer_epoch = 19;
inline bool CommandSubscribe::has_consumer_epoch() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void CommandSubscribe::clear_consumer_epoch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumer_epoch_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::uint64_t CommandSubscribe::consumer_epoch() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSubscribe.consumer_epoch)
  return _internal_consumer_epoch();
}
inline void CommandSubscribe::set_consumer_epoch(::uint64_t value) {
  _internal_set_consumer_epoch(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSubscribe.consumer_epoch)
}
inline ::uint64_t CommandSubscribe::_internal_consumer_epoch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumer_epoch_;
}
inline void CommandSubscribe::_internal_set_consumer_epoch(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.consumer_epoch_ = value;
}

// -------------------------------------------------------------------

// CommandPartitionedTopicMetadata

// required string topic = 1;
inline bool CommandPartitionedTopicMetadata::has_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandPartitionedTopicMetadata::clear_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandPartitionedTopicMetadata::topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadata.topic)
  return _internal_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandPartitionedTopicMetadata::set_topic(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadata.topic)
}
inline std::string* CommandPartitionedTopicMetadata::mutable_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandPartitionedTopicMetadata.topic)
  return _s;
}
inline const std::string& CommandPartitionedTopicMetadata::_internal_topic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_.Get();
}
inline void CommandPartitionedTopicMetadata::_internal_set_topic(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(value, GetArena());
}
inline std::string* CommandPartitionedTopicMetadata::_internal_mutable_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.topic_.Mutable( GetArena());
}
inline std::string* CommandPartitionedTopicMetadata::release_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandPartitionedTopicMetadata.topic)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.topic_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topic_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandPartitionedTopicMetadata::set_allocated_topic(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.topic_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topic_.IsDefault()) {
          _impl_.topic_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandPartitionedTopicMetadata.topic)
}

// required uint64 request_id = 2;
inline bool CommandPartitionedTopicMetadata::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandPartitionedTopicMetadata::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t CommandPartitionedTopicMetadata::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadata.request_id)
  return _internal_request_id();
}
inline void CommandPartitionedTopicMetadata::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadata.request_id)
}
inline ::uint64_t CommandPartitionedTopicMetadata::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandPartitionedTopicMetadata::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.request_id_ = value;
}

// optional string original_principal = 3;
inline bool CommandPartitionedTopicMetadata::has_original_principal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandPartitionedTopicMetadata::clear_original_principal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.original_principal_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandPartitionedTopicMetadata::original_principal() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadata.original_principal)
  return _internal_original_principal();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandPartitionedTopicMetadata::set_original_principal(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.original_principal_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadata.original_principal)
}
inline std::string* CommandPartitionedTopicMetadata::mutable_original_principal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_original_principal();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandPartitionedTopicMetadata.original_principal)
  return _s;
}
inline const std::string& CommandPartitionedTopicMetadata::_internal_original_principal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.original_principal_.Get();
}
inline void CommandPartitionedTopicMetadata::_internal_set_original_principal(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.original_principal_.Set(value, GetArena());
}
inline std::string* CommandPartitionedTopicMetadata::_internal_mutable_original_principal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.original_principal_.Mutable( GetArena());
}
inline std::string* CommandPartitionedTopicMetadata::release_original_principal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandPartitionedTopicMetadata.original_principal)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.original_principal_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.original_principal_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandPartitionedTopicMetadata::set_allocated_original_principal(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.original_principal_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.original_principal_.IsDefault()) {
          _impl_.original_principal_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandPartitionedTopicMetadata.original_principal)
}

// optional string original_auth_data = 4;
inline bool CommandPartitionedTopicMetadata::has_original_auth_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandPartitionedTopicMetadata::clear_original_auth_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.original_auth_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandPartitionedTopicMetadata::original_auth_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_data)
  return _internal_original_auth_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandPartitionedTopicMetadata::set_original_auth_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.original_auth_data_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_data)
}
inline std::string* CommandPartitionedTopicMetadata::mutable_original_auth_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_original_auth_data();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_data)
  return _s;
}
inline const std::string& CommandPartitionedTopicMetadata::_internal_original_auth_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.original_auth_data_.Get();
}
inline void CommandPartitionedTopicMetadata::_internal_set_original_auth_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.original_auth_data_.Set(value, GetArena());
}
inline std::string* CommandPartitionedTopicMetadata::_internal_mutable_original_auth_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.original_auth_data_.Mutable( GetArena());
}
inline std::string* CommandPartitionedTopicMetadata::release_original_auth_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_data)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.original_auth_data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.original_auth_data_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandPartitionedTopicMetadata::set_allocated_original_auth_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.original_auth_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.original_auth_data_.IsDefault()) {
          _impl_.original_auth_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_data)
}

// optional string original_auth_method = 5;
inline bool CommandPartitionedTopicMetadata::has_original_auth_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandPartitionedTopicMetadata::clear_original_auth_method() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.original_auth_method_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CommandPartitionedTopicMetadata::original_auth_method() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_method)
  return _internal_original_auth_method();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandPartitionedTopicMetadata::set_original_auth_method(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.original_auth_method_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_method)
}
inline std::string* CommandPartitionedTopicMetadata::mutable_original_auth_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_original_auth_method();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_method)
  return _s;
}
inline const std::string& CommandPartitionedTopicMetadata::_internal_original_auth_method() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.original_auth_method_.Get();
}
inline void CommandPartitionedTopicMetadata::_internal_set_original_auth_method(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.original_auth_method_.Set(value, GetArena());
}
inline std::string* CommandPartitionedTopicMetadata::_internal_mutable_original_auth_method() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.original_auth_method_.Mutable( GetArena());
}
inline std::string* CommandPartitionedTopicMetadata::release_original_auth_method() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_method)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.original_auth_method_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.original_auth_method_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandPartitionedTopicMetadata::set_allocated_original_auth_method(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.original_auth_method_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.original_auth_method_.IsDefault()) {
          _impl_.original_auth_method_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandPartitionedTopicMetadata.original_auth_method)
}

// -------------------------------------------------------------------

// CommandPartitionedTopicMetadataResponse

// optional uint32 partitions = 1;
inline bool CommandPartitionedTopicMetadataResponse::has_partitions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandPartitionedTopicMetadataResponse::clear_partitions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.partitions_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t CommandPartitionedTopicMetadataResponse::partitions() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadataResponse.partitions)
  return _internal_partitions();
}
inline void CommandPartitionedTopicMetadataResponse::set_partitions(::uint32_t value) {
  _internal_set_partitions(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadataResponse.partitions)
}
inline ::uint32_t CommandPartitionedTopicMetadataResponse::_internal_partitions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.partitions_;
}
inline void CommandPartitionedTopicMetadataResponse::_internal_set_partitions(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.partitions_ = value;
}

// required uint64 request_id = 2;
inline bool CommandPartitionedTopicMetadataResponse::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandPartitionedTopicMetadataResponse::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandPartitionedTopicMetadataResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadataResponse.request_id)
  return _internal_request_id();
}
inline void CommandPartitionedTopicMetadataResponse::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadataResponse.request_id)
}
inline ::uint64_t CommandPartitionedTopicMetadataResponse::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandPartitionedTopicMetadataResponse::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}

// optional .pulsar.proto.CommandPartitionedTopicMetadataResponse.LookupType response = 3;
inline bool CommandPartitionedTopicMetadataResponse::has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandPartitionedTopicMetadataResponse::clear_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.response_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse::response() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadataResponse.response)
  return _internal_response();
}
inline void CommandPartitionedTopicMetadataResponse::set_response(::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadataResponse.response)
}
inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse::_internal_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType>(_impl_.response_);
}
inline void CommandPartitionedTopicMetadataResponse::_internal_set_response(::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.response_ = value;
}

// optional .pulsar.proto.ServerError error = 4;
inline bool CommandPartitionedTopicMetadataResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandPartitionedTopicMetadataResponse::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::ServerError CommandPartitionedTopicMetadataResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadataResponse.error)
  return _internal_error();
}
inline void CommandPartitionedTopicMetadataResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadataResponse.error)
}
inline ::pulsar::proto::ServerError CommandPartitionedTopicMetadataResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::ServerError>(_impl_.error_);
}
inline void CommandPartitionedTopicMetadataResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::ServerError_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.error_ = value;
}

// optional string message = 5;
inline bool CommandPartitionedTopicMetadataResponse::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandPartitionedTopicMetadataResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandPartitionedTopicMetadataResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandPartitionedTopicMetadataResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandPartitionedTopicMetadataResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandPartitionedTopicMetadataResponse.message)
}
inline std::string* CommandPartitionedTopicMetadataResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandPartitionedTopicMetadataResponse.message)
  return _s;
}
inline const std::string& CommandPartitionedTopicMetadataResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void CommandPartitionedTopicMetadataResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* CommandPartitionedTopicMetadataResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* CommandPartitionedTopicMetadataResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandPartitionedTopicMetadataResponse.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandPartitionedTopicMetadataResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandPartitionedTopicMetadataResponse.message)
}

// -------------------------------------------------------------------

// CommandLookupTopic

// required string topic = 1;
inline bool CommandLookupTopic::has_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandLookupTopic::clear_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandLookupTopic::topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.topic)
  return _internal_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandLookupTopic::set_topic(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.topic)
}
inline std::string* CommandLookupTopic::mutable_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopic.topic)
  return _s;
}
inline const std::string& CommandLookupTopic::_internal_topic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_.Get();
}
inline void CommandLookupTopic::_internal_set_topic(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(value, GetArena());
}
inline std::string* CommandLookupTopic::_internal_mutable_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.topic_.Mutable( GetArena());
}
inline std::string* CommandLookupTopic::release_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandLookupTopic.topic)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.topic_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topic_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandLookupTopic::set_allocated_topic(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.topic_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topic_.IsDefault()) {
          _impl_.topic_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopic.topic)
}

// required uint64 request_id = 2;
inline bool CommandLookupTopic::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CommandLookupTopic::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t CommandLookupTopic::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.request_id)
  return _internal_request_id();
}
inline void CommandLookupTopic::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.request_id)
}
inline ::uint64_t CommandLookupTopic::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandLookupTopic::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.request_id_ = value;
}

// optional bool authoritative = 3 [default = false];
inline bool CommandLookupTopic::has_authoritative() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void CommandLookupTopic::clear_authoritative() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.authoritative_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool CommandLookupTopic::authoritative() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.authoritative)
  return _internal_authoritative();
}
inline void CommandLookupTopic::set_authoritative(bool value) {
  _internal_set_authoritative(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.authoritative)
}
inline bool CommandLookupTopic::_internal_authoritative() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.authoritative_;
}
inline void CommandLookupTopic::_internal_set_authoritative(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.authoritative_ = value;
}

// optional string original_principal = 4;
inline bool CommandLookupTopic::has_original_principal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandLookupTopic::clear_original_principal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.original_principal_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandLookupTopic::original_principal() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.original_principal)
  return _internal_original_principal();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandLookupTopic::set_original_principal(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.original_principal_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.original_principal)
}
inline std::string* CommandLookupTopic::mutable_original_principal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_original_principal();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopic.original_principal)
  return _s;
}
inline const std::string& CommandLookupTopic::_internal_original_principal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.original_principal_.Get();
}
inline void CommandLookupTopic::_internal_set_original_principal(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.original_principal_.Set(value, GetArena());
}
inline std::string* CommandLookupTopic::_internal_mutable_original_principal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.original_principal_.Mutable( GetArena());
}
inline std::string* CommandLookupTopic::release_original_principal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandLookupTopic.original_principal)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.original_principal_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.original_principal_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandLookupTopic::set_allocated_original_principal(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.original_principal_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.original_principal_.IsDefault()) {
          _impl_.original_principal_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopic.original_principal)
}

// optional string original_auth_data = 5;
inline bool CommandLookupTopic::has_original_auth_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandLookupTopic::clear_original_auth_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.original_auth_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandLookupTopic::original_auth_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.original_auth_data)
  return _internal_original_auth_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandLookupTopic::set_original_auth_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.original_auth_data_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.original_auth_data)
}
inline std::string* CommandLookupTopic::mutable_original_auth_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_original_auth_data();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopic.original_auth_data)
  return _s;
}
inline const std::string& CommandLookupTopic::_internal_original_auth_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.original_auth_data_.Get();
}
inline void CommandLookupTopic::_internal_set_original_auth_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.original_auth_data_.Set(value, GetArena());
}
inline std::string* CommandLookupTopic::_internal_mutable_original_auth_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.original_auth_data_.Mutable( GetArena());
}
inline std::string* CommandLookupTopic::release_original_auth_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandLookupTopic.original_auth_data)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.original_auth_data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.original_auth_data_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandLookupTopic::set_allocated_original_auth_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.original_auth_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.original_auth_data_.IsDefault()) {
          _impl_.original_auth_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopic.original_auth_data)
}

// optional string original_auth_method = 6;
inline bool CommandLookupTopic::has_original_auth_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandLookupTopic::clear_original_auth_method() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.original_auth_method_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CommandLookupTopic::original_auth_method() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.original_auth_method)
  return _internal_original_auth_method();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandLookupTopic::set_original_auth_method(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.original_auth_method_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.original_auth_method)
}
inline std::string* CommandLookupTopic::mutable_original_auth_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_original_auth_method();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopic.original_auth_method)
  return _s;
}
inline const std::string& CommandLookupTopic::_internal_original_auth_method() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.original_auth_method_.Get();
}
inline void CommandLookupTopic::_internal_set_original_auth_method(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.original_auth_method_.Set(value, GetArena());
}
inline std::string* CommandLookupTopic::_internal_mutable_original_auth_method() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.original_auth_method_.Mutable( GetArena());
}
inline std::string* CommandLookupTopic::release_original_auth_method() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandLookupTopic.original_auth_method)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.original_auth_method_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.original_auth_method_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandLookupTopic::set_allocated_original_auth_method(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.original_auth_method_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.original_auth_method_.IsDefault()) {
          _impl_.original_auth_method_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopic.original_auth_method)
}

// optional string advertised_listener_name = 7;
inline bool CommandLookupTopic::has_advertised_listener_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandLookupTopic::clear_advertised_listener_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.advertised_listener_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CommandLookupTopic::advertised_listener_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopic.advertised_listener_name)
  return _internal_advertised_listener_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandLookupTopic::set_advertised_listener_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.advertised_listener_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopic.advertised_listener_name)
}
inline std::string* CommandLookupTopic::mutable_advertised_listener_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_advertised_listener_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopic.advertised_listener_name)
  return _s;
}
inline const std::string& CommandLookupTopic::_internal_advertised_listener_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.advertised_listener_name_.Get();
}
inline void CommandLookupTopic::_internal_set_advertised_listener_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.advertised_listener_name_.Set(value, GetArena());
}
inline std::string* CommandLookupTopic::_internal_mutable_advertised_listener_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.advertised_listener_name_.Mutable( GetArena());
}
inline std::string* CommandLookupTopic::release_advertised_listener_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandLookupTopic.advertised_listener_name)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.advertised_listener_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.advertised_listener_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandLookupTopic::set_allocated_advertised_listener_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.advertised_listener_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.advertised_listener_name_.IsDefault()) {
          _impl_.advertised_listener_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopic.advertised_listener_name)
}

// -------------------------------------------------------------------

// CommandLookupTopicResponse

// optional string brokerServiceUrl = 1;
inline bool CommandLookupTopicResponse::has_brokerserviceurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandLookupTopicResponse::clear_brokerserviceurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.brokerserviceurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandLookupTopicResponse::brokerserviceurl() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrl)
  return _internal_brokerserviceurl();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandLookupTopicResponse::set_brokerserviceurl(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.brokerserviceurl_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrl)
}
inline std::string* CommandLookupTopicResponse::mutable_brokerserviceurl() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_brokerserviceurl();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrl)
  return _s;
}
inline const std::string& CommandLookupTopicResponse::_internal_brokerserviceurl() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.brokerserviceurl_.Get();
}
inline void CommandLookupTopicResponse::_internal_set_brokerserviceurl(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.brokerserviceurl_.Set(value, GetArena());
}
inline std::string* CommandLookupTopicResponse::_internal_mutable_brokerserviceurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.brokerserviceurl_.Mutable( GetArena());
}
inline std::string* CommandLookupTopicResponse::release_brokerserviceurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrl)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.brokerserviceurl_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.brokerserviceurl_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandLookupTopicResponse::set_allocated_brokerserviceurl(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.brokerserviceurl_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.brokerserviceurl_.IsDefault()) {
          _impl_.brokerserviceurl_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrl)
}

// optional string brokerServiceUrlTls = 2;
inline bool CommandLookupTopicResponse::has_brokerserviceurltls() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandLookupTopicResponse::clear_brokerserviceurltls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.brokerserviceurltls_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandLookupTopicResponse::brokerserviceurltls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrlTls)
  return _internal_brokerserviceurltls();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandLookupTopicResponse::set_brokerserviceurltls(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.brokerserviceurltls_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrlTls)
}
inline std::string* CommandLookupTopicResponse::mutable_brokerserviceurltls() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_brokerserviceurltls();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrlTls)
  return _s;
}
inline const std::string& CommandLookupTopicResponse::_internal_brokerserviceurltls() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.brokerserviceurltls_.Get();
}
inline void CommandLookupTopicResponse::_internal_set_brokerserviceurltls(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.brokerserviceurltls_.Set(value, GetArena());
}
inline std::string* CommandLookupTopicResponse::_internal_mutable_brokerserviceurltls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.brokerserviceurltls_.Mutable( GetArena());
}
inline std::string* CommandLookupTopicResponse::release_brokerserviceurltls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrlTls)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.brokerserviceurltls_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.brokerserviceurltls_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandLookupTopicResponse::set_allocated_brokerserviceurltls(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.brokerserviceurltls_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.brokerserviceurltls_.IsDefault()) {
          _impl_.brokerserviceurltls_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopicResponse.brokerServiceUrlTls)
}

// optional .pulsar.proto.CommandLookupTopicResponse.LookupType response = 3;
inline bool CommandLookupTopicResponse::has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandLookupTopicResponse::clear_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.response_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::CommandLookupTopicResponse_LookupType CommandLookupTopicResponse::response() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.response)
  return _internal_response();
}
inline void CommandLookupTopicResponse::set_response(::pulsar::proto::CommandLookupTopicResponse_LookupType value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.response)
}
inline ::pulsar::proto::CommandLookupTopicResponse_LookupType CommandLookupTopicResponse::_internal_response() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::CommandLookupTopicResponse_LookupType>(_impl_.response_);
}
inline void CommandLookupTopicResponse::_internal_set_response(::pulsar::proto::CommandLookupTopicResponse_LookupType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::CommandLookupTopicResponse_LookupType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.response_ = value;
}

// required uint64 request_id = 4;
inline bool CommandLookupTopicResponse::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandLookupTopicResponse::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandLookupTopicResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.request_id)
  return _internal_request_id();
}
inline void CommandLookupTopicResponse::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.request_id)
}
inline ::uint64_t CommandLookupTopicResponse::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandLookupTopicResponse::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.request_id_ = value;
}

// optional bool authoritative = 5 [default = false];
inline bool CommandLookupTopicResponse::has_authoritative() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void CommandLookupTopicResponse::clear_authoritative() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.authoritative_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool CommandLookupTopicResponse::authoritative() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.authoritative)
  return _internal_authoritative();
}
inline void CommandLookupTopicResponse::set_authoritative(bool value) {
  _internal_set_authoritative(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.authoritative)
}
inline bool CommandLookupTopicResponse::_internal_authoritative() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.authoritative_;
}
inline void CommandLookupTopicResponse::_internal_set_authoritative(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.authoritative_ = value;
}

// optional .pulsar.proto.ServerError error = 6;
inline bool CommandLookupTopicResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CommandLookupTopicResponse::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::pulsar::proto::ServerError CommandLookupTopicResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.error)
  return _internal_error();
}
inline void CommandLookupTopicResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.error)
}
inline ::pulsar::proto::ServerError CommandLookupTopicResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::ServerError>(_impl_.error_);
}
inline void CommandLookupTopicResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::ServerError_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.error_ = value;
}

// optional string message = 7;
inline bool CommandLookupTopicResponse::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandLookupTopicResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandLookupTopicResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandLookupTopicResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.message)
}
inline std::string* CommandLookupTopicResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandLookupTopicResponse.message)
  return _s;
}
inline const std::string& CommandLookupTopicResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void CommandLookupTopicResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* CommandLookupTopicResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* CommandLookupTopicResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandLookupTopicResponse.message)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandLookupTopicResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandLookupTopicResponse.message)
}

// optional bool proxy_through_service_url = 8 [default = false];
inline bool CommandLookupTopicResponse::has_proxy_through_service_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void CommandLookupTopicResponse::clear_proxy_through_service_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.proxy_through_service_url_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool CommandLookupTopicResponse::proxy_through_service_url() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandLookupTopicResponse.proxy_through_service_url)
  return _internal_proxy_through_service_url();
}
inline void CommandLookupTopicResponse::set_proxy_through_service_url(bool value) {
  _internal_set_proxy_through_service_url(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandLookupTopicResponse.proxy_through_service_url)
}
inline bool CommandLookupTopicResponse::_internal_proxy_through_service_url() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.proxy_through_service_url_;
}
inline void CommandLookupTopicResponse::_internal_set_proxy_through_service_url(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.proxy_through_service_url_ = value;
}

// -------------------------------------------------------------------

// CommandProducer

// required string topic = 1;
inline bool CommandProducer::has_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandProducer::clear_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandProducer::topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.topic)
  return _internal_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandProducer::set_topic(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.topic)
}
inline std::string* CommandProducer::mutable_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducer.topic)
  return _s;
}
inline const std::string& CommandProducer::_internal_topic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_.Get();
}
inline void CommandProducer::_internal_set_topic(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(value, GetArena());
}
inline std::string* CommandProducer::_internal_mutable_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.topic_.Mutable( GetArena());
}
inline std::string* CommandProducer::release_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandProducer.topic)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.topic_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topic_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandProducer::set_allocated_topic(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.topic_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topic_.IsDefault()) {
          _impl_.topic_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandProducer.topic)
}

// required uint64 producer_id = 2;
inline bool CommandProducer::has_producer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandProducer::clear_producer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.producer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t CommandProducer::producer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.producer_id)
  return _internal_producer_id();
}
inline void CommandProducer::set_producer_id(::uint64_t value) {
  _internal_set_producer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.producer_id)
}
inline ::uint64_t CommandProducer::_internal_producer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.producer_id_;
}
inline void CommandProducer::_internal_set_producer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.producer_id_ = value;
}

// required uint64 request_id = 3;
inline bool CommandProducer::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CommandProducer::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t CommandProducer::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.request_id)
  return _internal_request_id();
}
inline void CommandProducer::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.request_id)
}
inline ::uint64_t CommandProducer::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandProducer::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.request_id_ = value;
}

// optional string producer_name = 4;
inline bool CommandProducer::has_producer_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandProducer::clear_producer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.producer_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandProducer::producer_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.producer_name)
  return _internal_producer_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandProducer::set_producer_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.producer_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.producer_name)
}
inline std::string* CommandProducer::mutable_producer_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_producer_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducer.producer_name)
  return _s;
}
inline const std::string& CommandProducer::_internal_producer_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.producer_name_.Get();
}
inline void CommandProducer::_internal_set_producer_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.producer_name_.Set(value, GetArena());
}
inline std::string* CommandProducer::_internal_mutable_producer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.producer_name_.Mutable( GetArena());
}
inline std::string* CommandProducer::release_producer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandProducer.producer_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.producer_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.producer_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandProducer::set_allocated_producer_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.producer_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.producer_name_.IsDefault()) {
          _impl_.producer_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandProducer.producer_name)
}

// optional bool encrypted = 5 [default = false];
inline bool CommandProducer::has_encrypted() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void CommandProducer::clear_encrypted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.encrypted_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool CommandProducer::encrypted() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.encrypted)
  return _internal_encrypted();
}
inline void CommandProducer::set_encrypted(bool value) {
  _internal_set_encrypted(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.encrypted)
}
inline bool CommandProducer::_internal_encrypted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.encrypted_;
}
inline void CommandProducer::_internal_set_encrypted(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.encrypted_ = value;
}

// repeated .pulsar.proto.KeyValue metadata = 6;
inline int CommandProducer::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int CommandProducer::metadata_size() const {
  return _internal_metadata_size();
}
inline void CommandProducer::clear_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metadata_.Clear();
}
inline ::pulsar::proto::KeyValue* CommandProducer::mutable_metadata(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducer.metadata)
  return _internal_mutable_metadata()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>* CommandProducer::mutable_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandProducer.metadata)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_metadata();
}
inline const ::pulsar::proto::KeyValue& CommandProducer::metadata(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.metadata)
  return _internal_metadata().Get(index);
}
inline ::pulsar::proto::KeyValue* CommandProducer::add_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pulsar::proto::KeyValue* _add = _internal_mutable_metadata()->Add();
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandProducer.metadata)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>& CommandProducer::metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandProducer.metadata)
  return _internal_metadata();
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>&
CommandProducer::_internal_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metadata_;
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyValue>*
CommandProducer::_internal_mutable_metadata() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.metadata_;
}

// optional .pulsar.proto.Schema schema = 7;
inline bool CommandProducer::has_schema() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schema_ != nullptr);
  return value;
}
inline void CommandProducer::clear_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.schema_ != nullptr) _impl_.schema_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::pulsar::proto::Schema& CommandProducer::_internal_schema() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::Schema* p = _impl_.schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::Schema&>(::pulsar::proto::_Schema_default_instance_);
}
inline const ::pulsar::proto::Schema& CommandProducer::schema() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.schema)
  return _internal_schema();
}
inline void CommandProducer::unsafe_arena_set_allocated_schema(::pulsar::proto::Schema* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.schema_);
  }
  _impl_.schema_ = reinterpret_cast<::pulsar::proto::Schema*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandProducer.schema)
}
inline ::pulsar::proto::Schema* CommandProducer::release_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::pulsar::proto::Schema* released = _impl_.schema_;
  _impl_.schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::Schema* CommandProducer::unsafe_arena_release_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandProducer.schema)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::pulsar::proto::Schema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
  return temp;
}
inline ::pulsar::proto::Schema* CommandProducer::_internal_mutable_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::Schema>(GetArena());
    _impl_.schema_ = reinterpret_cast<::pulsar::proto::Schema*>(p);
  }
  return _impl_.schema_;
}
inline ::pulsar::proto::Schema* CommandProducer::mutable_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::Schema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducer.schema)
  return _msg;
}
inline void CommandProducer::set_allocated_schema(::pulsar::proto::Schema* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::Schema*>(_impl_.schema_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::Schema*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.schema_ = reinterpret_cast<::pulsar::proto::Schema*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandProducer.schema)
}

// optional uint64 epoch = 8 [default = 0];
inline bool CommandProducer::has_epoch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void CommandProducer::clear_epoch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.epoch_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t CommandProducer::epoch() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.epoch)
  return _internal_epoch();
}
inline void CommandProducer::set_epoch(::uint64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.epoch)
}
inline ::uint64_t CommandProducer::_internal_epoch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.epoch_;
}
inline void CommandProducer::_internal_set_epoch(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.epoch_ = value;
}

// optional bool user_provided_producer_name = 9 [default = true];
inline bool CommandProducer::has_user_provided_producer_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void CommandProducer::clear_user_provided_producer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_provided_producer_name_ = true;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool CommandProducer::user_provided_producer_name() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.user_provided_producer_name)
  return _internal_user_provided_producer_name();
}
inline void CommandProducer::set_user_provided_producer_name(bool value) {
  _internal_set_user_provided_producer_name(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.user_provided_producer_name)
}
inline bool CommandProducer::_internal_user_provided_producer_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_provided_producer_name_;
}
inline void CommandProducer::_internal_set_user_provided_producer_name(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.user_provided_producer_name_ = value;
}

// optional .pulsar.proto.ProducerAccessMode producer_access_mode = 10 [default = Shared];
inline bool CommandProducer::has_producer_access_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void CommandProducer::clear_producer_access_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.producer_access_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::pulsar::proto::ProducerAccessMode CommandProducer::producer_access_mode() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.producer_access_mode)
  return _internal_producer_access_mode();
}
inline void CommandProducer::set_producer_access_mode(::pulsar::proto::ProducerAccessMode value) {
  _internal_set_producer_access_mode(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.producer_access_mode)
}
inline ::pulsar::proto::ProducerAccessMode CommandProducer::_internal_producer_access_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::ProducerAccessMode>(_impl_.producer_access_mode_);
}
inline void CommandProducer::_internal_set_producer_access_mode(::pulsar::proto::ProducerAccessMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::ProducerAccessMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.producer_access_mode_ = value;
}

// optional uint64 topic_epoch = 11;
inline bool CommandProducer::has_topic_epoch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void CommandProducer::clear_topic_epoch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_epoch_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::uint64_t CommandProducer::topic_epoch() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.topic_epoch)
  return _internal_topic_epoch();
}
inline void CommandProducer::set_topic_epoch(::uint64_t value) {
  _internal_set_topic_epoch(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.topic_epoch)
}
inline ::uint64_t CommandProducer::_internal_topic_epoch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_epoch_;
}
inline void CommandProducer::_internal_set_topic_epoch(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.topic_epoch_ = value;
}

// optional bool txn_enabled = 12 [default = false];
inline bool CommandProducer::has_txn_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void CommandProducer::clear_txn_enabled() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txn_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool CommandProducer::txn_enabled() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.txn_enabled)
  return _internal_txn_enabled();
}
inline void CommandProducer::set_txn_enabled(bool value) {
  _internal_set_txn_enabled(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.txn_enabled)
}
inline bool CommandProducer::_internal_txn_enabled() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txn_enabled_;
}
inline void CommandProducer::_internal_set_txn_enabled(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.txn_enabled_ = value;
}

// optional string initial_subscription_name = 13;
inline bool CommandProducer::has_initial_subscription_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandProducer::clear_initial_subscription_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.initial_subscription_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandProducer::initial_subscription_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducer.initial_subscription_name)
  return _internal_initial_subscription_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandProducer::set_initial_subscription_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.initial_subscription_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducer.initial_subscription_name)
}
inline std::string* CommandProducer::mutable_initial_subscription_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_initial_subscription_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducer.initial_subscription_name)
  return _s;
}
inline const std::string& CommandProducer::_internal_initial_subscription_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.initial_subscription_name_.Get();
}
inline void CommandProducer::_internal_set_initial_subscription_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.initial_subscription_name_.Set(value, GetArena());
}
inline std::string* CommandProducer::_internal_mutable_initial_subscription_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.initial_subscription_name_.Mutable( GetArena());
}
inline std::string* CommandProducer::release_initial_subscription_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandProducer.initial_subscription_name)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.initial_subscription_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.initial_subscription_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandProducer::set_allocated_initial_subscription_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.initial_subscription_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.initial_subscription_name_.IsDefault()) {
          _impl_.initial_subscription_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandProducer.initial_subscription_name)
}

// -------------------------------------------------------------------

// CommandSend

// required uint64 producer_id = 1;
inline bool CommandSend::has_producer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandSend::clear_producer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.producer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandSend::producer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.producer_id)
  return _internal_producer_id();
}
inline void CommandSend::set_producer_id(::uint64_t value) {
  _internal_set_producer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.producer_id)
}
inline ::uint64_t CommandSend::_internal_producer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.producer_id_;
}
inline void CommandSend::_internal_set_producer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.producer_id_ = value;
}

// required uint64 sequence_id = 2;
inline bool CommandSend::has_sequence_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandSend::clear_sequence_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sequence_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandSend::sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.sequence_id)
  return _internal_sequence_id();
}
inline void CommandSend::set_sequence_id(::uint64_t value) {
  _internal_set_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.sequence_id)
}
inline ::uint64_t CommandSend::_internal_sequence_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequence_id_;
}
inline void CommandSend::_internal_set_sequence_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sequence_id_ = value;
}

// optional int32 num_messages = 3 [default = 1];
inline bool CommandSend::has_num_messages() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void CommandSend::clear_num_messages() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_messages_ = 1;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t CommandSend::num_messages() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.num_messages)
  return _internal_num_messages();
}
inline void CommandSend::set_num_messages(::int32_t value) {
  _internal_set_num_messages(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.num_messages)
}
inline ::int32_t CommandSend::_internal_num_messages() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_messages_;
}
inline void CommandSend::_internal_set_num_messages(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.num_messages_ = value;
}

// optional uint64 txnid_least_bits = 4 [default = 0];
inline bool CommandSend::has_txnid_least_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandSend::clear_txnid_least_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_least_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandSend::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandSend::set_txnid_least_bits(::uint64_t value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.txnid_least_bits)
}
inline ::uint64_t CommandSend::_internal_txnid_least_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_least_bits_;
}
inline void CommandSend::_internal_set_txnid_least_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.txnid_least_bits_ = value;
}

// optional uint64 txnid_most_bits = 5 [default = 0];
inline bool CommandSend::has_txnid_most_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandSend::clear_txnid_most_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_most_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t CommandSend::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandSend::set_txnid_most_bits(::uint64_t value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.txnid_most_bits)
}
inline ::uint64_t CommandSend::_internal_txnid_most_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_most_bits_;
}
inline void CommandSend::_internal_set_txnid_most_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.txnid_most_bits_ = value;
}

// optional uint64 highest_sequence_id = 6 [default = 0];
inline bool CommandSend::has_highest_sequence_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CommandSend::clear_highest_sequence_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.highest_sequence_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t CommandSend::highest_sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.highest_sequence_id)
  return _internal_highest_sequence_id();
}
inline void CommandSend::set_highest_sequence_id(::uint64_t value) {
  _internal_set_highest_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.highest_sequence_id)
}
inline ::uint64_t CommandSend::_internal_highest_sequence_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.highest_sequence_id_;
}
inline void CommandSend::_internal_set_highest_sequence_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.highest_sequence_id_ = value;
}

// optional bool is_chunk = 7 [default = false];
inline bool CommandSend::has_is_chunk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void CommandSend::clear_is_chunk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_chunk_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool CommandSend::is_chunk() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.is_chunk)
  return _internal_is_chunk();
}
inline void CommandSend::set_is_chunk(bool value) {
  _internal_set_is_chunk(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.is_chunk)
}
inline bool CommandSend::_internal_is_chunk() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_chunk_;
}
inline void CommandSend::_internal_set_is_chunk(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.is_chunk_ = value;
}

// optional bool marker = 8 [default = false];
inline bool CommandSend::has_marker() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void CommandSend::clear_marker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.marker_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool CommandSend::marker() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.marker)
  return _internal_marker();
}
inline void CommandSend::set_marker(bool value) {
  _internal_set_marker(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSend.marker)
}
inline bool CommandSend::_internal_marker() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.marker_;
}
inline void CommandSend::_internal_set_marker(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.marker_ = value;
}

// optional .pulsar.proto.MessageIdData message_id = 9;
inline bool CommandSend::has_message_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.message_id_ != nullptr);
  return value;
}
inline void CommandSend::clear_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.message_id_ != nullptr) _impl_.message_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::MessageIdData& CommandSend::_internal_message_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::MessageIdData* p = _impl_.message_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::MessageIdData&>(::pulsar::proto::_MessageIdData_default_instance_);
}
inline const ::pulsar::proto::MessageIdData& CommandSend::message_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSend.message_id)
  return _internal_message_id();
}
inline void CommandSend::unsafe_arena_set_allocated_message_id(::pulsar::proto::MessageIdData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.message_id_);
  }
  _impl_.message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandSend.message_id)
}
inline ::pulsar::proto::MessageIdData* CommandSend::release_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* released = _impl_.message_id_;
  _impl_.message_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::MessageIdData* CommandSend::unsafe_arena_release_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSend.message_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = _impl_.message_id_;
  _impl_.message_id_ = nullptr;
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandSend::_internal_mutable_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.message_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::MessageIdData>(GetArena());
    _impl_.message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(p);
  }
  return _impl_.message_id_;
}
inline ::pulsar::proto::MessageIdData* CommandSend::mutable_message_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::MessageIdData* _msg = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSend.message_id)
  return _msg;
}
inline void CommandSend::set_allocated_message_id(::pulsar::proto::MessageIdData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::MessageIdData*>(_impl_.message_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::MessageIdData*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSend.message_id)
}

// -------------------------------------------------------------------

// CommandSendReceipt

// required uint64 producer_id = 1;
inline bool CommandSendReceipt::has_producer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandSendReceipt::clear_producer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.producer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandSendReceipt::producer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendReceipt.producer_id)
  return _internal_producer_id();
}
inline void CommandSendReceipt::set_producer_id(::uint64_t value) {
  _internal_set_producer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendReceipt.producer_id)
}
inline ::uint64_t CommandSendReceipt::_internal_producer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.producer_id_;
}
inline void CommandSendReceipt::_internal_set_producer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.producer_id_ = value;
}

// required uint64 sequence_id = 2;
inline bool CommandSendReceipt::has_sequence_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandSendReceipt::clear_sequence_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sequence_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandSendReceipt::sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendReceipt.sequence_id)
  return _internal_sequence_id();
}
inline void CommandSendReceipt::set_sequence_id(::uint64_t value) {
  _internal_set_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendReceipt.sequence_id)
}
inline ::uint64_t CommandSendReceipt::_internal_sequence_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequence_id_;
}
inline void CommandSendReceipt::_internal_set_sequence_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sequence_id_ = value;
}

// optional .pulsar.proto.MessageIdData message_id = 3;
inline bool CommandSendReceipt::has_message_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.message_id_ != nullptr);
  return value;
}
inline void CommandSendReceipt::clear_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.message_id_ != nullptr) _impl_.message_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::MessageIdData& CommandSendReceipt::_internal_message_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::MessageIdData* p = _impl_.message_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::MessageIdData&>(::pulsar::proto::_MessageIdData_default_instance_);
}
inline const ::pulsar::proto::MessageIdData& CommandSendReceipt::message_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendReceipt.message_id)
  return _internal_message_id();
}
inline void CommandSendReceipt::unsafe_arena_set_allocated_message_id(::pulsar::proto::MessageIdData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.message_id_);
  }
  _impl_.message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandSendReceipt.message_id)
}
inline ::pulsar::proto::MessageIdData* CommandSendReceipt::release_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* released = _impl_.message_id_;
  _impl_.message_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::MessageIdData* CommandSendReceipt::unsafe_arena_release_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSendReceipt.message_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = _impl_.message_id_;
  _impl_.message_id_ = nullptr;
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandSendReceipt::_internal_mutable_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.message_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::MessageIdData>(GetArena());
    _impl_.message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(p);
  }
  return _impl_.message_id_;
}
inline ::pulsar::proto::MessageIdData* CommandSendReceipt::mutable_message_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::MessageIdData* _msg = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSendReceipt.message_id)
  return _msg;
}
inline void CommandSendReceipt::set_allocated_message_id(::pulsar::proto::MessageIdData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::MessageIdData*>(_impl_.message_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::MessageIdData*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSendReceipt.message_id)
}

// optional uint64 highest_sequence_id = 4 [default = 0];
inline bool CommandSendReceipt::has_highest_sequence_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandSendReceipt::clear_highest_sequence_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.highest_sequence_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandSendReceipt::highest_sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendReceipt.highest_sequence_id)
  return _internal_highest_sequence_id();
}
inline void CommandSendReceipt::set_highest_sequence_id(::uint64_t value) {
  _internal_set_highest_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendReceipt.highest_sequence_id)
}
inline ::uint64_t CommandSendReceipt::_internal_highest_sequence_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.highest_sequence_id_;
}
inline void CommandSendReceipt::_internal_set_highest_sequence_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.highest_sequence_id_ = value;
}

// -------------------------------------------------------------------

// CommandSendError

// required uint64 producer_id = 1;
inline bool CommandSendError::has_producer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandSendError::clear_producer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.producer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandSendError::producer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendError.producer_id)
  return _internal_producer_id();
}
inline void CommandSendError::set_producer_id(::uint64_t value) {
  _internal_set_producer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendError.producer_id)
}
inline ::uint64_t CommandSendError::_internal_producer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.producer_id_;
}
inline void CommandSendError::_internal_set_producer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.producer_id_ = value;
}

// required uint64 sequence_id = 2;
inline bool CommandSendError::has_sequence_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandSendError::clear_sequence_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sequence_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandSendError::sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendError.sequence_id)
  return _internal_sequence_id();
}
inline void CommandSendError::set_sequence_id(::uint64_t value) {
  _internal_set_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendError.sequence_id)
}
inline ::uint64_t CommandSendError::_internal_sequence_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequence_id_;
}
inline void CommandSendError::_internal_set_sequence_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sequence_id_ = value;
}

// required .pulsar.proto.ServerError error = 3;
inline bool CommandSendError::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandSendError::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::pulsar::proto::ServerError CommandSendError::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendError.error)
  return _internal_error();
}
inline void CommandSendError::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendError.error)
}
inline ::pulsar::proto::ServerError CommandSendError::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::ServerError>(_impl_.error_);
}
inline void CommandSendError::_internal_set_error(::pulsar::proto::ServerError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::ServerError_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.error_ = value;
}

// required string message = 4;
inline bool CommandSendError::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandSendError::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandSendError::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSendError.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandSendError::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSendError.message)
}
inline std::string* CommandSendError::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSendError.message)
  return _s;
}
inline const std::string& CommandSendError::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void CommandSendError::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* CommandSendError::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* CommandSendError::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSendError.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandSendError::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSendError.message)
}

// -------------------------------------------------------------------

// CommandMessage

// required uint64 consumer_id = 1;
inline bool CommandMessage::has_consumer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandMessage::clear_consumer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandMessage::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandMessage.consumer_id)
  return _internal_consumer_id();
}
inline void CommandMessage::set_consumer_id(::uint64_t value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandMessage.consumer_id)
}
inline ::uint64_t CommandMessage::_internal_consumer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumer_id_;
}
inline void CommandMessage::_internal_set_consumer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.consumer_id_ = value;
}

// required .pulsar.proto.MessageIdData message_id = 2;
inline bool CommandMessage::has_message_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.message_id_ != nullptr);
  return value;
}
inline void CommandMessage::clear_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.message_id_ != nullptr) _impl_.message_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::MessageIdData& CommandMessage::_internal_message_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::MessageIdData* p = _impl_.message_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::MessageIdData&>(::pulsar::proto::_MessageIdData_default_instance_);
}
inline const ::pulsar::proto::MessageIdData& CommandMessage::message_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandMessage.message_id)
  return _internal_message_id();
}
inline void CommandMessage::unsafe_arena_set_allocated_message_id(::pulsar::proto::MessageIdData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.message_id_);
  }
  _impl_.message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandMessage.message_id)
}
inline ::pulsar::proto::MessageIdData* CommandMessage::release_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* released = _impl_.message_id_;
  _impl_.message_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::MessageIdData* CommandMessage::unsafe_arena_release_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandMessage.message_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = _impl_.message_id_;
  _impl_.message_id_ = nullptr;
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandMessage::_internal_mutable_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.message_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::MessageIdData>(GetArena());
    _impl_.message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(p);
  }
  return _impl_.message_id_;
}
inline ::pulsar::proto::MessageIdData* CommandMessage::mutable_message_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::MessageIdData* _msg = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandMessage.message_id)
  return _msg;
}
inline void CommandMessage::set_allocated_message_id(::pulsar::proto::MessageIdData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::MessageIdData*>(_impl_.message_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::MessageIdData*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandMessage.message_id)
}

// optional uint32 redelivery_count = 3 [default = 0];
inline bool CommandMessage::has_redelivery_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandMessage::clear_redelivery_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.redelivery_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t CommandMessage::redelivery_count() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandMessage.redelivery_count)
  return _internal_redelivery_count();
}
inline void CommandMessage::set_redelivery_count(::uint32_t value) {
  _internal_set_redelivery_count(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandMessage.redelivery_count)
}
inline ::uint32_t CommandMessage::_internal_redelivery_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.redelivery_count_;
}
inline void CommandMessage::_internal_set_redelivery_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.redelivery_count_ = value;
}

// repeated int64 ack_set = 4;
inline int CommandMessage::_internal_ack_set_size() const {
  return _internal_ack_set().size();
}
inline int CommandMessage::ack_set_size() const {
  return _internal_ack_set_size();
}
inline void CommandMessage::clear_ack_set() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ack_set_.Clear();
}
inline ::int64_t CommandMessage::ack_set(int index) const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandMessage.ack_set)
  return _internal_ack_set().Get(index);
}
inline void CommandMessage::set_ack_set(int index, ::int64_t value) {
  _internal_mutable_ack_set()->Set(index, value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandMessage.ack_set)
}
inline void CommandMessage::add_ack_set(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ack_set()->Add(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandMessage.ack_set)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& CommandMessage::ack_set() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandMessage.ack_set)
  return _internal_ack_set();
}
inline ::google::protobuf::RepeatedField<::int64_t>* CommandMessage::mutable_ack_set()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandMessage.ack_set)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ack_set();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& CommandMessage::_internal_ack_set()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ack_set_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* CommandMessage::_internal_mutable_ack_set() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ack_set_;
}

// optional uint64 consumer_epoch = 5;
inline bool CommandMessage::has_consumer_epoch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandMessage::clear_consumer_epoch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumer_epoch_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandMessage::consumer_epoch() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandMessage.consumer_epoch)
  return _internal_consumer_epoch();
}
inline void CommandMessage::set_consumer_epoch(::uint64_t value) {
  _internal_set_consumer_epoch(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandMessage.consumer_epoch)
}
inline ::uint64_t CommandMessage::_internal_consumer_epoch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumer_epoch_;
}
inline void CommandMessage::_internal_set_consumer_epoch(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.consumer_epoch_ = value;
}

// -------------------------------------------------------------------

// CommandAck

// required uint64 consumer_id = 1;
inline bool CommandAck::has_consumer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandAck::clear_consumer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CommandAck::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.consumer_id)
  return _internal_consumer_id();
}
inline void CommandAck::set_consumer_id(::uint64_t value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAck.consumer_id)
}
inline ::uint64_t CommandAck::_internal_consumer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumer_id_;
}
inline void CommandAck::_internal_set_consumer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.consumer_id_ = value;
}

// required .pulsar.proto.CommandAck.AckType ack_type = 2;
inline bool CommandAck::has_ack_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandAck::clear_ack_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ack_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::pulsar::proto::CommandAck_AckType CommandAck::ack_type() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.ack_type)
  return _internal_ack_type();
}
inline void CommandAck::set_ack_type(::pulsar::proto::CommandAck_AckType value) {
  _internal_set_ack_type(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAck.ack_type)
}
inline ::pulsar::proto::CommandAck_AckType CommandAck::_internal_ack_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::CommandAck_AckType>(_impl_.ack_type_);
}
inline void CommandAck::_internal_set_ack_type(::pulsar::proto::CommandAck_AckType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::CommandAck_AckType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ack_type_ = value;
}

// repeated .pulsar.proto.MessageIdData message_id = 3;
inline int CommandAck::_internal_message_id_size() const {
  return _internal_message_id().size();
}
inline int CommandAck::message_id_size() const {
  return _internal_message_id_size();
}
inline void CommandAck::clear_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_id_.Clear();
}
inline ::pulsar::proto::MessageIdData* CommandAck::mutable_message_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAck.message_id)
  return _internal_mutable_message_id()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::MessageIdData>* CommandAck::mutable_message_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandAck.message_id)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_message_id();
}
inline const ::pulsar::proto::MessageIdData& CommandAck::message_id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.message_id)
  return _internal_message_id().Get(index);
}
inline ::pulsar::proto::MessageIdData* CommandAck::add_message_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pulsar::proto::MessageIdData* _add = _internal_mutable_message_id()->Add();
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandAck.message_id)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::MessageIdData>& CommandAck::message_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandAck.message_id)
  return _internal_message_id();
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::MessageIdData>&
CommandAck::_internal_message_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_id_;
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::MessageIdData>*
CommandAck::_internal_mutable_message_id() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.message_id_;
}

// optional .pulsar.proto.CommandAck.ValidationError validation_error = 4;
inline bool CommandAck::has_validation_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandAck::clear_validation_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.validation_error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::pulsar::proto::CommandAck_ValidationError CommandAck::validation_error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.validation_error)
  return _internal_validation_error();
}
inline void CommandAck::set_validation_error(::pulsar::proto::CommandAck_ValidationError value) {
  _internal_set_validation_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAck.validation_error)
}
inline ::pulsar::proto::CommandAck_ValidationError CommandAck::_internal_validation_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::CommandAck_ValidationError>(_impl_.validation_error_);
}
inline void CommandAck::_internal_set_validation_error(::pulsar::proto::CommandAck_ValidationError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::CommandAck_ValidationError_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.validation_error_ = value;
}

// repeated .pulsar.proto.KeyLongValue properties = 5;
inline int CommandAck::_internal_properties_size() const {
  return _internal_properties().size();
}
inline int CommandAck::properties_size() const {
  return _internal_properties_size();
}
inline void CommandAck::clear_properties() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.properties_.Clear();
}
inline ::pulsar::proto::KeyLongValue* CommandAck::mutable_properties(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAck.properties)
  return _internal_mutable_properties()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyLongValue>* CommandAck::mutable_properties()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandAck.properties)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_properties();
}
inline const ::pulsar::proto::KeyLongValue& CommandAck::properties(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.properties)
  return _internal_properties().Get(index);
}
inline ::pulsar::proto::KeyLongValue* CommandAck::add_properties() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pulsar::proto::KeyLongValue* _add = _internal_mutable_properties()->Add();
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandAck.properties)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyLongValue>& CommandAck::properties() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandAck.properties)
  return _internal_properties();
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyLongValue>&
CommandAck::_internal_properties() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.properties_;
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::KeyLongValue>*
CommandAck::_internal_mutable_properties() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.properties_;
}

// optional uint64 txnid_least_bits = 6 [default = 0];
inline bool CommandAck::has_txnid_least_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandAck::clear_txnid_least_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_least_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandAck::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandAck::set_txnid_least_bits(::uint64_t value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAck.txnid_least_bits)
}
inline ::uint64_t CommandAck::_internal_txnid_least_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_least_bits_;
}
inline void CommandAck::_internal_set_txnid_least_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.txnid_least_bits_ = value;
}

// optional uint64 txnid_most_bits = 7 [default = 0];
inline bool CommandAck::has_txnid_most_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandAck::clear_txnid_most_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_most_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t CommandAck::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandAck::set_txnid_most_bits(::uint64_t value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAck.txnid_most_bits)
}
inline ::uint64_t CommandAck::_internal_txnid_most_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_most_bits_;
}
inline void CommandAck::_internal_set_txnid_most_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.txnid_most_bits_ = value;
}

// optional uint64 request_id = 8;
inline bool CommandAck::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CommandAck::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t CommandAck::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAck.request_id)
  return _internal_request_id();
}
inline void CommandAck::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAck.request_id)
}
inline ::uint64_t CommandAck::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandAck::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.request_id_ = value;
}

// -------------------------------------------------------------------

// CommandAckResponse

// required uint64 consumer_id = 1;
inline bool CommandAckResponse::has_consumer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandAckResponse::clear_consumer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandAckResponse::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAckResponse.consumer_id)
  return _internal_consumer_id();
}
inline void CommandAckResponse::set_consumer_id(::uint64_t value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAckResponse.consumer_id)
}
inline ::uint64_t CommandAckResponse::_internal_consumer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumer_id_;
}
inline void CommandAckResponse::_internal_set_consumer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.consumer_id_ = value;
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandAckResponse::has_txnid_least_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandAckResponse::clear_txnid_least_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_least_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandAckResponse::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAckResponse.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandAckResponse::set_txnid_least_bits(::uint64_t value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAckResponse.txnid_least_bits)
}
inline ::uint64_t CommandAckResponse::_internal_txnid_least_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_least_bits_;
}
inline void CommandAckResponse::_internal_set_txnid_least_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.txnid_least_bits_ = value;
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandAckResponse::has_txnid_most_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandAckResponse::clear_txnid_most_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_most_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandAckResponse::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAckResponse.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandAckResponse::set_txnid_most_bits(::uint64_t value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAckResponse.txnid_most_bits)
}
inline ::uint64_t CommandAckResponse::_internal_txnid_most_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_most_bits_;
}
inline void CommandAckResponse::_internal_set_txnid_most_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.txnid_most_bits_ = value;
}

// optional .pulsar.proto.ServerError error = 4;
inline bool CommandAckResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CommandAckResponse::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::pulsar::proto::ServerError CommandAckResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAckResponse.error)
  return _internal_error();
}
inline void CommandAckResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAckResponse.error)
}
inline ::pulsar::proto::ServerError CommandAckResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::ServerError>(_impl_.error_);
}
inline void CommandAckResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::ServerError_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.error_ = value;
}

// optional string message = 5;
inline bool CommandAckResponse::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandAckResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandAckResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAckResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandAckResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAckResponse.message)
}
inline std::string* CommandAckResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAckResponse.message)
  return _s;
}
inline const std::string& CommandAckResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void CommandAckResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* CommandAckResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* CommandAckResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandAckResponse.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandAckResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAckResponse.message)
}

// optional uint64 request_id = 6;
inline bool CommandAckResponse::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandAckResponse::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t CommandAckResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAckResponse.request_id)
  return _internal_request_id();
}
inline void CommandAckResponse::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAckResponse.request_id)
}
inline ::uint64_t CommandAckResponse::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandAckResponse::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.request_id_ = value;
}

// -------------------------------------------------------------------

// CommandActiveConsumerChange

// required uint64 consumer_id = 1;
inline bool CommandActiveConsumerChange::has_consumer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandActiveConsumerChange::clear_consumer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CommandActiveConsumerChange::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandActiveConsumerChange.consumer_id)
  return _internal_consumer_id();
}
inline void CommandActiveConsumerChange::set_consumer_id(::uint64_t value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandActiveConsumerChange.consumer_id)
}
inline ::uint64_t CommandActiveConsumerChange::_internal_consumer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumer_id_;
}
inline void CommandActiveConsumerChange::_internal_set_consumer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.consumer_id_ = value;
}

// optional bool is_active = 2 [default = false];
inline bool CommandActiveConsumerChange::has_is_active() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandActiveConsumerChange::clear_is_active() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_active_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool CommandActiveConsumerChange::is_active() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandActiveConsumerChange.is_active)
  return _internal_is_active();
}
inline void CommandActiveConsumerChange::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandActiveConsumerChange.is_active)
}
inline bool CommandActiveConsumerChange::_internal_is_active() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_active_;
}
inline void CommandActiveConsumerChange::_internal_set_is_active(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.is_active_ = value;
}

// -------------------------------------------------------------------

// CommandFlow

// required uint64 consumer_id = 1;
inline bool CommandFlow::has_consumer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandFlow::clear_consumer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CommandFlow::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandFlow.consumer_id)
  return _internal_consumer_id();
}
inline void CommandFlow::set_consumer_id(::uint64_t value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandFlow.consumer_id)
}
inline ::uint64_t CommandFlow::_internal_consumer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumer_id_;
}
inline void CommandFlow::_internal_set_consumer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.consumer_id_ = value;
}

// required uint32 messagePermits = 2;
inline bool CommandFlow::has_messagepermits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandFlow::clear_messagepermits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.messagepermits_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t CommandFlow::messagepermits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandFlow.messagePermits)
  return _internal_messagepermits();
}
inline void CommandFlow::set_messagepermits(::uint32_t value) {
  _internal_set_messagepermits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandFlow.messagePermits)
}
inline ::uint32_t CommandFlow::_internal_messagepermits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.messagepermits_;
}
inline void CommandFlow::_internal_set_messagepermits(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.messagepermits_ = value;
}

// -------------------------------------------------------------------

// CommandUnsubscribe

// required uint64 consumer_id = 1;
inline bool CommandUnsubscribe::has_consumer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandUnsubscribe::clear_consumer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CommandUnsubscribe::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandUnsubscribe.consumer_id)
  return _internal_consumer_id();
}
inline void CommandUnsubscribe::set_consumer_id(::uint64_t value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandUnsubscribe.consumer_id)
}
inline ::uint64_t CommandUnsubscribe::_internal_consumer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumer_id_;
}
inline void CommandUnsubscribe::_internal_set_consumer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.consumer_id_ = value;
}

// required uint64 request_id = 2;
inline bool CommandUnsubscribe::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandUnsubscribe::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandUnsubscribe::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandUnsubscribe.request_id)
  return _internal_request_id();
}
inline void CommandUnsubscribe::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandUnsubscribe.request_id)
}
inline ::uint64_t CommandUnsubscribe::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandUnsubscribe::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}

// -------------------------------------------------------------------

// CommandSeek

// required uint64 consumer_id = 1;
inline bool CommandSeek::has_consumer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandSeek::clear_consumer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandSeek::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSeek.consumer_id)
  return _internal_consumer_id();
}
inline void CommandSeek::set_consumer_id(::uint64_t value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSeek.consumer_id)
}
inline ::uint64_t CommandSeek::_internal_consumer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumer_id_;
}
inline void CommandSeek::_internal_set_consumer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.consumer_id_ = value;
}

// required uint64 request_id = 2;
inline bool CommandSeek::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandSeek::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandSeek::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSeek.request_id)
  return _internal_request_id();
}
inline void CommandSeek::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSeek.request_id)
}
inline ::uint64_t CommandSeek::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandSeek::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.request_id_ = value;
}

// optional .pulsar.proto.MessageIdData message_id = 3;
inline bool CommandSeek::has_message_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.message_id_ != nullptr);
  return value;
}
inline void CommandSeek::clear_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.message_id_ != nullptr) _impl_.message_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::MessageIdData& CommandSeek::_internal_message_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::MessageIdData* p = _impl_.message_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::MessageIdData&>(::pulsar::proto::_MessageIdData_default_instance_);
}
inline const ::pulsar::proto::MessageIdData& CommandSeek::message_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSeek.message_id)
  return _internal_message_id();
}
inline void CommandSeek::unsafe_arena_set_allocated_message_id(::pulsar::proto::MessageIdData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.message_id_);
  }
  _impl_.message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandSeek.message_id)
}
inline ::pulsar::proto::MessageIdData* CommandSeek::release_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* released = _impl_.message_id_;
  _impl_.message_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::MessageIdData* CommandSeek::unsafe_arena_release_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSeek.message_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = _impl_.message_id_;
  _impl_.message_id_ = nullptr;
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandSeek::_internal_mutable_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.message_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::MessageIdData>(GetArena());
    _impl_.message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(p);
  }
  return _impl_.message_id_;
}
inline ::pulsar::proto::MessageIdData* CommandSeek::mutable_message_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::MessageIdData* _msg = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSeek.message_id)
  return _msg;
}
inline void CommandSeek::set_allocated_message_id(::pulsar::proto::MessageIdData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::MessageIdData*>(_impl_.message_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::MessageIdData*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSeek.message_id)
}

// optional uint64 message_publish_time = 4;
inline bool CommandSeek::has_message_publish_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandSeek::clear_message_publish_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_publish_time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandSeek::message_publish_time() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSeek.message_publish_time)
  return _internal_message_publish_time();
}
inline void CommandSeek::set_message_publish_time(::uint64_t value) {
  _internal_set_message_publish_time(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSeek.message_publish_time)
}
inline ::uint64_t CommandSeek::_internal_message_publish_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_publish_time_;
}
inline void CommandSeek::_internal_set_message_publish_time(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.message_publish_time_ = value;
}

// -------------------------------------------------------------------

// CommandReachedEndOfTopic

// required uint64 consumer_id = 1;
inline bool CommandReachedEndOfTopic::has_consumer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandReachedEndOfTopic::clear_consumer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CommandReachedEndOfTopic::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandReachedEndOfTopic.consumer_id)
  return _internal_consumer_id();
}
inline void CommandReachedEndOfTopic::set_consumer_id(::uint64_t value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandReachedEndOfTopic.consumer_id)
}
inline ::uint64_t CommandReachedEndOfTopic::_internal_consumer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumer_id_;
}
inline void CommandReachedEndOfTopic::_internal_set_consumer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.consumer_id_ = value;
}

// -------------------------------------------------------------------

// CommandTopicMigrated

// required uint64 resource_id = 1;
inline bool CommandTopicMigrated::has_resource_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandTopicMigrated::clear_resource_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resource_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandTopicMigrated::resource_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTopicMigrated.resource_id)
  return _internal_resource_id();
}
inline void CommandTopicMigrated::set_resource_id(::uint64_t value) {
  _internal_set_resource_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTopicMigrated.resource_id)
}
inline ::uint64_t CommandTopicMigrated::_internal_resource_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.resource_id_;
}
inline void CommandTopicMigrated::_internal_set_resource_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.resource_id_ = value;
}

// required .pulsar.proto.CommandTopicMigrated.ResourceType resource_type = 2;
inline bool CommandTopicMigrated::has_resource_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandTopicMigrated::clear_resource_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resource_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::pulsar::proto::CommandTopicMigrated_ResourceType CommandTopicMigrated::resource_type() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTopicMigrated.resource_type)
  return _internal_resource_type();
}
inline void CommandTopicMigrated::set_resource_type(::pulsar::proto::CommandTopicMigrated_ResourceType value) {
  _internal_set_resource_type(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTopicMigrated.resource_type)
}
inline ::pulsar::proto::CommandTopicMigrated_ResourceType CommandTopicMigrated::_internal_resource_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::CommandTopicMigrated_ResourceType>(_impl_.resource_type_);
}
inline void CommandTopicMigrated::_internal_set_resource_type(::pulsar::proto::CommandTopicMigrated_ResourceType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::CommandTopicMigrated_ResourceType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.resource_type_ = value;
}

// optional string brokerServiceUrl = 3;
inline bool CommandTopicMigrated::has_brokerserviceurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandTopicMigrated::clear_brokerserviceurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.brokerserviceurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandTopicMigrated::brokerserviceurl() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTopicMigrated.brokerServiceUrl)
  return _internal_brokerserviceurl();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandTopicMigrated::set_brokerserviceurl(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.brokerserviceurl_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTopicMigrated.brokerServiceUrl)
}
inline std::string* CommandTopicMigrated::mutable_brokerserviceurl() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_brokerserviceurl();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandTopicMigrated.brokerServiceUrl)
  return _s;
}
inline const std::string& CommandTopicMigrated::_internal_brokerserviceurl() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.brokerserviceurl_.Get();
}
inline void CommandTopicMigrated::_internal_set_brokerserviceurl(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.brokerserviceurl_.Set(value, GetArena());
}
inline std::string* CommandTopicMigrated::_internal_mutable_brokerserviceurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.brokerserviceurl_.Mutable( GetArena());
}
inline std::string* CommandTopicMigrated::release_brokerserviceurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandTopicMigrated.brokerServiceUrl)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.brokerserviceurl_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.brokerserviceurl_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandTopicMigrated::set_allocated_brokerserviceurl(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.brokerserviceurl_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.brokerserviceurl_.IsDefault()) {
          _impl_.brokerserviceurl_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandTopicMigrated.brokerServiceUrl)
}

// optional string brokerServiceUrlTls = 4;
inline bool CommandTopicMigrated::has_brokerserviceurltls() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandTopicMigrated::clear_brokerserviceurltls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.brokerserviceurltls_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandTopicMigrated::brokerserviceurltls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTopicMigrated.brokerServiceUrlTls)
  return _internal_brokerserviceurltls();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandTopicMigrated::set_brokerserviceurltls(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.brokerserviceurltls_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTopicMigrated.brokerServiceUrlTls)
}
inline std::string* CommandTopicMigrated::mutable_brokerserviceurltls() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_brokerserviceurltls();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandTopicMigrated.brokerServiceUrlTls)
  return _s;
}
inline const std::string& CommandTopicMigrated::_internal_brokerserviceurltls() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.brokerserviceurltls_.Get();
}
inline void CommandTopicMigrated::_internal_set_brokerserviceurltls(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.brokerserviceurltls_.Set(value, GetArena());
}
inline std::string* CommandTopicMigrated::_internal_mutable_brokerserviceurltls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.brokerserviceurltls_.Mutable( GetArena());
}
inline std::string* CommandTopicMigrated::release_brokerserviceurltls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandTopicMigrated.brokerServiceUrlTls)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.brokerserviceurltls_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.brokerserviceurltls_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandTopicMigrated::set_allocated_brokerserviceurltls(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.brokerserviceurltls_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.brokerserviceurltls_.IsDefault()) {
          _impl_.brokerserviceurltls_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandTopicMigrated.brokerServiceUrlTls)
}

// -------------------------------------------------------------------

// CommandCloseProducer

// required uint64 producer_id = 1;
inline bool CommandCloseProducer::has_producer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandCloseProducer::clear_producer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.producer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandCloseProducer::producer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseProducer.producer_id)
  return _internal_producer_id();
}
inline void CommandCloseProducer::set_producer_id(::uint64_t value) {
  _internal_set_producer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseProducer.producer_id)
}
inline ::uint64_t CommandCloseProducer::_internal_producer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.producer_id_;
}
inline void CommandCloseProducer::_internal_set_producer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.producer_id_ = value;
}

// required uint64 request_id = 2;
inline bool CommandCloseProducer::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandCloseProducer::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandCloseProducer::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseProducer.request_id)
  return _internal_request_id();
}
inline void CommandCloseProducer::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseProducer.request_id)
}
inline ::uint64_t CommandCloseProducer::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandCloseProducer::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.request_id_ = value;
}

// optional string assignedBrokerServiceUrl = 3;
inline bool CommandCloseProducer::has_assignedbrokerserviceurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandCloseProducer::clear_assignedbrokerserviceurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assignedbrokerserviceurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandCloseProducer::assignedbrokerserviceurl() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrl)
  return _internal_assignedbrokerserviceurl();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandCloseProducer::set_assignedbrokerserviceurl(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.assignedbrokerserviceurl_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrl)
}
inline std::string* CommandCloseProducer::mutable_assignedbrokerserviceurl() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_assignedbrokerserviceurl();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrl)
  return _s;
}
inline const std::string& CommandCloseProducer::_internal_assignedbrokerserviceurl() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.assignedbrokerserviceurl_.Get();
}
inline void CommandCloseProducer::_internal_set_assignedbrokerserviceurl(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.assignedbrokerserviceurl_.Set(value, GetArena());
}
inline std::string* CommandCloseProducer::_internal_mutable_assignedbrokerserviceurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.assignedbrokerserviceurl_.Mutable( GetArena());
}
inline std::string* CommandCloseProducer::release_assignedbrokerserviceurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrl)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.assignedbrokerserviceurl_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.assignedbrokerserviceurl_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandCloseProducer::set_allocated_assignedbrokerserviceurl(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.assignedbrokerserviceurl_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.assignedbrokerserviceurl_.IsDefault()) {
          _impl_.assignedbrokerserviceurl_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrl)
}

// optional string assignedBrokerServiceUrlTls = 4;
inline bool CommandCloseProducer::has_assignedbrokerserviceurltls() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandCloseProducer::clear_assignedbrokerserviceurltls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assignedbrokerserviceurltls_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandCloseProducer::assignedbrokerserviceurltls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrlTls)
  return _internal_assignedbrokerserviceurltls();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandCloseProducer::set_assignedbrokerserviceurltls(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.assignedbrokerserviceurltls_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrlTls)
}
inline std::string* CommandCloseProducer::mutable_assignedbrokerserviceurltls() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_assignedbrokerserviceurltls();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrlTls)
  return _s;
}
inline const std::string& CommandCloseProducer::_internal_assignedbrokerserviceurltls() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.assignedbrokerserviceurltls_.Get();
}
inline void CommandCloseProducer::_internal_set_assignedbrokerserviceurltls(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.assignedbrokerserviceurltls_.Set(value, GetArena());
}
inline std::string* CommandCloseProducer::_internal_mutable_assignedbrokerserviceurltls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.assignedbrokerserviceurltls_.Mutable( GetArena());
}
inline std::string* CommandCloseProducer::release_assignedbrokerserviceurltls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrlTls)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.assignedbrokerserviceurltls_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.assignedbrokerserviceurltls_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandCloseProducer::set_allocated_assignedbrokerserviceurltls(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.assignedbrokerserviceurltls_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.assignedbrokerserviceurltls_.IsDefault()) {
          _impl_.assignedbrokerserviceurltls_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandCloseProducer.assignedBrokerServiceUrlTls)
}

// -------------------------------------------------------------------

// CommandCloseConsumer

// required uint64 consumer_id = 1;
inline bool CommandCloseConsumer::has_consumer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandCloseConsumer::clear_consumer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandCloseConsumer::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseConsumer.consumer_id)
  return _internal_consumer_id();
}
inline void CommandCloseConsumer::set_consumer_id(::uint64_t value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseConsumer.consumer_id)
}
inline ::uint64_t CommandCloseConsumer::_internal_consumer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumer_id_;
}
inline void CommandCloseConsumer::_internal_set_consumer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.consumer_id_ = value;
}

// required uint64 request_id = 2;
inline bool CommandCloseConsumer::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandCloseConsumer::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandCloseConsumer::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseConsumer.request_id)
  return _internal_request_id();
}
inline void CommandCloseConsumer::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseConsumer.request_id)
}
inline ::uint64_t CommandCloseConsumer::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandCloseConsumer::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.request_id_ = value;
}

// optional string assignedBrokerServiceUrl = 3;
inline bool CommandCloseConsumer::has_assignedbrokerserviceurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandCloseConsumer::clear_assignedbrokerserviceurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assignedbrokerserviceurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandCloseConsumer::assignedbrokerserviceurl() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrl)
  return _internal_assignedbrokerserviceurl();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandCloseConsumer::set_assignedbrokerserviceurl(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.assignedbrokerserviceurl_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrl)
}
inline std::string* CommandCloseConsumer::mutable_assignedbrokerserviceurl() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_assignedbrokerserviceurl();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrl)
  return _s;
}
inline const std::string& CommandCloseConsumer::_internal_assignedbrokerserviceurl() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.assignedbrokerserviceurl_.Get();
}
inline void CommandCloseConsumer::_internal_set_assignedbrokerserviceurl(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.assignedbrokerserviceurl_.Set(value, GetArena());
}
inline std::string* CommandCloseConsumer::_internal_mutable_assignedbrokerserviceurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.assignedbrokerserviceurl_.Mutable( GetArena());
}
inline std::string* CommandCloseConsumer::release_assignedbrokerserviceurl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrl)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.assignedbrokerserviceurl_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.assignedbrokerserviceurl_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandCloseConsumer::set_allocated_assignedbrokerserviceurl(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.assignedbrokerserviceurl_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.assignedbrokerserviceurl_.IsDefault()) {
          _impl_.assignedbrokerserviceurl_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrl)
}

// optional string assignedBrokerServiceUrlTls = 4;
inline bool CommandCloseConsumer::has_assignedbrokerserviceurltls() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandCloseConsumer::clear_assignedbrokerserviceurltls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assignedbrokerserviceurltls_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandCloseConsumer::assignedbrokerserviceurltls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrlTls)
  return _internal_assignedbrokerserviceurltls();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandCloseConsumer::set_assignedbrokerserviceurltls(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.assignedbrokerserviceurltls_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrlTls)
}
inline std::string* CommandCloseConsumer::mutable_assignedbrokerserviceurltls() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_assignedbrokerserviceurltls();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrlTls)
  return _s;
}
inline const std::string& CommandCloseConsumer::_internal_assignedbrokerserviceurltls() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.assignedbrokerserviceurltls_.Get();
}
inline void CommandCloseConsumer::_internal_set_assignedbrokerserviceurltls(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.assignedbrokerserviceurltls_.Set(value, GetArena());
}
inline std::string* CommandCloseConsumer::_internal_mutable_assignedbrokerserviceurltls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.assignedbrokerserviceurltls_.Mutable( GetArena());
}
inline std::string* CommandCloseConsumer::release_assignedbrokerserviceurltls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrlTls)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.assignedbrokerserviceurltls_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.assignedbrokerserviceurltls_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandCloseConsumer::set_allocated_assignedbrokerserviceurltls(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.assignedbrokerserviceurltls_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.assignedbrokerserviceurltls_.IsDefault()) {
          _impl_.assignedbrokerserviceurltls_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandCloseConsumer.assignedBrokerServiceUrlTls)
}

// -------------------------------------------------------------------

// CommandRedeliverUnacknowledgedMessages

// required uint64 consumer_id = 1;
inline bool CommandRedeliverUnacknowledgedMessages::has_consumer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandRedeliverUnacknowledgedMessages::clear_consumer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CommandRedeliverUnacknowledgedMessages::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandRedeliverUnacknowledgedMessages.consumer_id)
  return _internal_consumer_id();
}
inline void CommandRedeliverUnacknowledgedMessages::set_consumer_id(::uint64_t value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandRedeliverUnacknowledgedMessages.consumer_id)
}
inline ::uint64_t CommandRedeliverUnacknowledgedMessages::_internal_consumer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumer_id_;
}
inline void CommandRedeliverUnacknowledgedMessages::_internal_set_consumer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.consumer_id_ = value;
}

// repeated .pulsar.proto.MessageIdData message_ids = 2;
inline int CommandRedeliverUnacknowledgedMessages::_internal_message_ids_size() const {
  return _internal_message_ids().size();
}
inline int CommandRedeliverUnacknowledgedMessages::message_ids_size() const {
  return _internal_message_ids_size();
}
inline void CommandRedeliverUnacknowledgedMessages::clear_message_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_ids_.Clear();
}
inline ::pulsar::proto::MessageIdData* CommandRedeliverUnacknowledgedMessages::mutable_message_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandRedeliverUnacknowledgedMessages.message_ids)
  return _internal_mutable_message_ids()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::MessageIdData>* CommandRedeliverUnacknowledgedMessages::mutable_message_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandRedeliverUnacknowledgedMessages.message_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_message_ids();
}
inline const ::pulsar::proto::MessageIdData& CommandRedeliverUnacknowledgedMessages::message_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandRedeliverUnacknowledgedMessages.message_ids)
  return _internal_message_ids().Get(index);
}
inline ::pulsar::proto::MessageIdData* CommandRedeliverUnacknowledgedMessages::add_message_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pulsar::proto::MessageIdData* _add = _internal_mutable_message_ids()->Add();
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandRedeliverUnacknowledgedMessages.message_ids)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::MessageIdData>& CommandRedeliverUnacknowledgedMessages::message_ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandRedeliverUnacknowledgedMessages.message_ids)
  return _internal_message_ids();
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::MessageIdData>&
CommandRedeliverUnacknowledgedMessages::_internal_message_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::MessageIdData>*
CommandRedeliverUnacknowledgedMessages::_internal_mutable_message_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.message_ids_;
}

// optional uint64 consumer_epoch = 3;
inline bool CommandRedeliverUnacknowledgedMessages::has_consumer_epoch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandRedeliverUnacknowledgedMessages::clear_consumer_epoch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumer_epoch_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandRedeliverUnacknowledgedMessages::consumer_epoch() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandRedeliverUnacknowledgedMessages.consumer_epoch)
  return _internal_consumer_epoch();
}
inline void CommandRedeliverUnacknowledgedMessages::set_consumer_epoch(::uint64_t value) {
  _internal_set_consumer_epoch(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandRedeliverUnacknowledgedMessages.consumer_epoch)
}
inline ::uint64_t CommandRedeliverUnacknowledgedMessages::_internal_consumer_epoch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumer_epoch_;
}
inline void CommandRedeliverUnacknowledgedMessages::_internal_set_consumer_epoch(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.consumer_epoch_ = value;
}

// -------------------------------------------------------------------

// CommandSuccess

// required uint64 request_id = 1;
inline bool CommandSuccess::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandSuccess::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandSuccess::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSuccess.request_id)
  return _internal_request_id();
}
inline void CommandSuccess::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandSuccess.request_id)
}
inline ::uint64_t CommandSuccess::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandSuccess::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}

// optional .pulsar.proto.Schema schema = 2;
inline bool CommandSuccess::has_schema() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schema_ != nullptr);
  return value;
}
inline void CommandSuccess::clear_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.schema_ != nullptr) _impl_.schema_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::Schema& CommandSuccess::_internal_schema() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::Schema* p = _impl_.schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::Schema&>(::pulsar::proto::_Schema_default_instance_);
}
inline const ::pulsar::proto::Schema& CommandSuccess::schema() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandSuccess.schema)
  return _internal_schema();
}
inline void CommandSuccess::unsafe_arena_set_allocated_schema(::pulsar::proto::Schema* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.schema_);
  }
  _impl_.schema_ = reinterpret_cast<::pulsar::proto::Schema*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandSuccess.schema)
}
inline ::pulsar::proto::Schema* CommandSuccess::release_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::Schema* released = _impl_.schema_;
  _impl_.schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::Schema* CommandSuccess::unsafe_arena_release_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandSuccess.schema)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::Schema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
  return temp;
}
inline ::pulsar::proto::Schema* CommandSuccess::_internal_mutable_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::Schema>(GetArena());
    _impl_.schema_ = reinterpret_cast<::pulsar::proto::Schema*>(p);
  }
  return _impl_.schema_;
}
inline ::pulsar::proto::Schema* CommandSuccess::mutable_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::Schema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandSuccess.schema)
  return _msg;
}
inline void CommandSuccess::set_allocated_schema(::pulsar::proto::Schema* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::Schema*>(_impl_.schema_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::Schema*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.schema_ = reinterpret_cast<::pulsar::proto::Schema*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandSuccess.schema)
}

// -------------------------------------------------------------------

// CommandProducerSuccess

// required uint64 request_id = 1;
inline bool CommandProducerSuccess::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandProducerSuccess::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandProducerSuccess::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducerSuccess.request_id)
  return _internal_request_id();
}
inline void CommandProducerSuccess::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducerSuccess.request_id)
}
inline ::uint64_t CommandProducerSuccess::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandProducerSuccess::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.request_id_ = value;
}

// required string producer_name = 2;
inline bool CommandProducerSuccess::has_producer_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandProducerSuccess::clear_producer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.producer_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandProducerSuccess::producer_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducerSuccess.producer_name)
  return _internal_producer_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandProducerSuccess::set_producer_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.producer_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducerSuccess.producer_name)
}
inline std::string* CommandProducerSuccess::mutable_producer_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_producer_name();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducerSuccess.producer_name)
  return _s;
}
inline const std::string& CommandProducerSuccess::_internal_producer_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.producer_name_.Get();
}
inline void CommandProducerSuccess::_internal_set_producer_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.producer_name_.Set(value, GetArena());
}
inline std::string* CommandProducerSuccess::_internal_mutable_producer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.producer_name_.Mutable( GetArena());
}
inline std::string* CommandProducerSuccess::release_producer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandProducerSuccess.producer_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.producer_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.producer_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandProducerSuccess::set_allocated_producer_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.producer_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.producer_name_.IsDefault()) {
          _impl_.producer_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandProducerSuccess.producer_name)
}

// optional int64 last_sequence_id = 3 [default = -1];
inline bool CommandProducerSuccess::has_last_sequence_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CommandProducerSuccess::clear_last_sequence_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.last_sequence_id_ = ::int64_t{-1};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t CommandProducerSuccess::last_sequence_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducerSuccess.last_sequence_id)
  return _internal_last_sequence_id();
}
inline void CommandProducerSuccess::set_last_sequence_id(::int64_t value) {
  _internal_set_last_sequence_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducerSuccess.last_sequence_id)
}
inline ::int64_t CommandProducerSuccess::_internal_last_sequence_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.last_sequence_id_;
}
inline void CommandProducerSuccess::_internal_set_last_sequence_id(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.last_sequence_id_ = value;
}

// optional bytes schema_version = 4;
inline bool CommandProducerSuccess::has_schema_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandProducerSuccess::clear_schema_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.schema_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandProducerSuccess::schema_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducerSuccess.schema_version)
  return _internal_schema_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandProducerSuccess::set_schema_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.schema_version_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducerSuccess.schema_version)
}
inline std::string* CommandProducerSuccess::mutable_schema_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_schema_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandProducerSuccess.schema_version)
  return _s;
}
inline const std::string& CommandProducerSuccess::_internal_schema_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.schema_version_.Get();
}
inline void CommandProducerSuccess::_internal_set_schema_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.schema_version_.Set(value, GetArena());
}
inline std::string* CommandProducerSuccess::_internal_mutable_schema_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.schema_version_.Mutable( GetArena());
}
inline std::string* CommandProducerSuccess::release_schema_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandProducerSuccess.schema_version)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.schema_version_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.schema_version_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandProducerSuccess::set_allocated_schema_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.schema_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_version_.IsDefault()) {
          _impl_.schema_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandProducerSuccess.schema_version)
}

// optional uint64 topic_epoch = 5;
inline bool CommandProducerSuccess::has_topic_epoch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandProducerSuccess::clear_topic_epoch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_epoch_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandProducerSuccess::topic_epoch() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducerSuccess.topic_epoch)
  return _internal_topic_epoch();
}
inline void CommandProducerSuccess::set_topic_epoch(::uint64_t value) {
  _internal_set_topic_epoch(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducerSuccess.topic_epoch)
}
inline ::uint64_t CommandProducerSuccess::_internal_topic_epoch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_epoch_;
}
inline void CommandProducerSuccess::_internal_set_topic_epoch(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.topic_epoch_ = value;
}

// optional bool producer_ready = 6 [default = true];
inline bool CommandProducerSuccess::has_producer_ready() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandProducerSuccess::clear_producer_ready() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.producer_ready_ = true;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool CommandProducerSuccess::producer_ready() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandProducerSuccess.producer_ready)
  return _internal_producer_ready();
}
inline void CommandProducerSuccess::set_producer_ready(bool value) {
  _internal_set_producer_ready(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandProducerSuccess.producer_ready)
}
inline bool CommandProducerSuccess::_internal_producer_ready() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.producer_ready_;
}
inline void CommandProducerSuccess::_internal_set_producer_ready(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.producer_ready_ = value;
}

// -------------------------------------------------------------------

// CommandError

// required uint64 request_id = 1;
inline bool CommandError::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandError::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandError::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandError.request_id)
  return _internal_request_id();
}
inline void CommandError::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandError.request_id)
}
inline ::uint64_t CommandError::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandError::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}

// required .pulsar.proto.ServerError error = 2;
inline bool CommandError::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandError::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::pulsar::proto::ServerError CommandError::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandError.error)
  return _internal_error();
}
inline void CommandError::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandError.error)
}
inline ::pulsar::proto::ServerError CommandError::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::ServerError>(_impl_.error_);
}
inline void CommandError::_internal_set_error(::pulsar::proto::ServerError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::ServerError_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.error_ = value;
}

// required string message = 3;
inline bool CommandError::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandError::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandError::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandError.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandError::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandError.message)
}
inline std::string* CommandError::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandError.message)
  return _s;
}
inline const std::string& CommandError::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void CommandError::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* CommandError::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* CommandError::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandError.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandError::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandError.message)
}

// -------------------------------------------------------------------

// CommandPing

// -------------------------------------------------------------------

// CommandPong

// -------------------------------------------------------------------

// CommandConsumerStats

// required uint64 request_id = 1;
inline bool CommandConsumerStats::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandConsumerStats::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CommandConsumerStats::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStats.request_id)
  return _internal_request_id();
}
inline void CommandConsumerStats::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStats.request_id)
}
inline ::uint64_t CommandConsumerStats::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandConsumerStats::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.request_id_ = value;
}

// required uint64 consumer_id = 4;
inline bool CommandConsumerStats::has_consumer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandConsumerStats::clear_consumer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandConsumerStats::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStats.consumer_id)
  return _internal_consumer_id();
}
inline void CommandConsumerStats::set_consumer_id(::uint64_t value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStats.consumer_id)
}
inline ::uint64_t CommandConsumerStats::_internal_consumer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumer_id_;
}
inline void CommandConsumerStats::_internal_set_consumer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.consumer_id_ = value;
}

// -------------------------------------------------------------------

// CommandConsumerStatsResponse

// required uint64 request_id = 1;
inline bool CommandConsumerStatsResponse::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CommandConsumerStatsResponse::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t CommandConsumerStatsResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.request_id)
  return _internal_request_id();
}
inline void CommandConsumerStatsResponse::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.request_id)
}
inline ::uint64_t CommandConsumerStatsResponse::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandConsumerStatsResponse::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.request_id_ = value;
}

// optional .pulsar.proto.ServerError error_code = 2;
inline bool CommandConsumerStatsResponse::has_error_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void CommandConsumerStatsResponse::clear_error_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::pulsar::proto::ServerError CommandConsumerStatsResponse::error_code() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.error_code)
  return _internal_error_code();
}
inline void CommandConsumerStatsResponse::set_error_code(::pulsar::proto::ServerError value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.error_code)
}
inline ::pulsar::proto::ServerError CommandConsumerStatsResponse::_internal_error_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::ServerError>(_impl_.error_code_);
}
inline void CommandConsumerStatsResponse::_internal_set_error_code(::pulsar::proto::ServerError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::ServerError_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.error_code_ = value;
}

// optional string error_message = 3;
inline bool CommandConsumerStatsResponse::has_error_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandConsumerStatsResponse::clear_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandConsumerStatsResponse::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandConsumerStatsResponse::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.error_message)
}
inline std::string* CommandConsumerStatsResponse::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConsumerStatsResponse.error_message)
  return _s;
}
inline const std::string& CommandConsumerStatsResponse::_internal_error_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_message_.Get();
}
inline void CommandConsumerStatsResponse::_internal_set_error_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* CommandConsumerStatsResponse::_internal_mutable_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* CommandConsumerStatsResponse::release_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConsumerStatsResponse.error_message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.error_message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.error_message_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandConsumerStatsResponse::set_allocated_error_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConsumerStatsResponse.error_message)
}

// optional double msgRateOut = 4;
inline bool CommandConsumerStatsResponse::has_msgrateout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void CommandConsumerStatsResponse::clear_msgrateout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgrateout_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double CommandConsumerStatsResponse::msgrateout() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.msgRateOut)
  return _internal_msgrateout();
}
inline void CommandConsumerStatsResponse::set_msgrateout(double value) {
  _internal_set_msgrateout(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.msgRateOut)
}
inline double CommandConsumerStatsResponse::_internal_msgrateout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.msgrateout_;
}
inline void CommandConsumerStatsResponse::_internal_set_msgrateout(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.msgrateout_ = value;
}

// optional double msgThroughputOut = 5;
inline bool CommandConsumerStatsResponse::has_msgthroughputout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void CommandConsumerStatsResponse::clear_msgthroughputout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgthroughputout_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double CommandConsumerStatsResponse::msgthroughputout() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.msgThroughputOut)
  return _internal_msgthroughputout();
}
inline void CommandConsumerStatsResponse::set_msgthroughputout(double value) {
  _internal_set_msgthroughputout(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.msgThroughputOut)
}
inline double CommandConsumerStatsResponse::_internal_msgthroughputout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.msgthroughputout_;
}
inline void CommandConsumerStatsResponse::_internal_set_msgthroughputout(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.msgthroughputout_ = value;
}

// optional double msgRateRedeliver = 6;
inline bool CommandConsumerStatsResponse::has_msgrateredeliver() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void CommandConsumerStatsResponse::clear_msgrateredeliver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgrateredeliver_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double CommandConsumerStatsResponse::msgrateredeliver() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.msgRateRedeliver)
  return _internal_msgrateredeliver();
}
inline void CommandConsumerStatsResponse::set_msgrateredeliver(double value) {
  _internal_set_msgrateredeliver(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.msgRateRedeliver)
}
inline double CommandConsumerStatsResponse::_internal_msgrateredeliver() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.msgrateredeliver_;
}
inline void CommandConsumerStatsResponse::_internal_set_msgrateredeliver(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.msgrateredeliver_ = value;
}

// optional string consumerName = 7;
inline bool CommandConsumerStatsResponse::has_consumername() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandConsumerStatsResponse::clear_consumername() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumername_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandConsumerStatsResponse::consumername() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.consumerName)
  return _internal_consumername();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandConsumerStatsResponse::set_consumername(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.consumername_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.consumerName)
}
inline std::string* CommandConsumerStatsResponse::mutable_consumername() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_consumername();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConsumerStatsResponse.consumerName)
  return _s;
}
inline const std::string& CommandConsumerStatsResponse::_internal_consumername() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumername_.Get();
}
inline void CommandConsumerStatsResponse::_internal_set_consumername(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.consumername_.Set(value, GetArena());
}
inline std::string* CommandConsumerStatsResponse::_internal_mutable_consumername() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.consumername_.Mutable( GetArena());
}
inline std::string* CommandConsumerStatsResponse::release_consumername() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConsumerStatsResponse.consumerName)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.consumername_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.consumername_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandConsumerStatsResponse::set_allocated_consumername(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.consumername_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.consumername_.IsDefault()) {
          _impl_.consumername_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConsumerStatsResponse.consumerName)
}

// optional uint64 availablePermits = 8;
inline bool CommandConsumerStatsResponse::has_availablepermits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void CommandConsumerStatsResponse::clear_availablepermits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.availablepermits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::uint64_t CommandConsumerStatsResponse::availablepermits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.availablePermits)
  return _internal_availablepermits();
}
inline void CommandConsumerStatsResponse::set_availablepermits(::uint64_t value) {
  _internal_set_availablepermits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.availablePermits)
}
inline ::uint64_t CommandConsumerStatsResponse::_internal_availablepermits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.availablepermits_;
}
inline void CommandConsumerStatsResponse::_internal_set_availablepermits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.availablepermits_ = value;
}

// optional uint64 unackedMessages = 9;
inline bool CommandConsumerStatsResponse::has_unackedmessages() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void CommandConsumerStatsResponse::clear_unackedmessages() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.unackedmessages_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::uint64_t CommandConsumerStatsResponse::unackedmessages() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.unackedMessages)
  return _internal_unackedmessages();
}
inline void CommandConsumerStatsResponse::set_unackedmessages(::uint64_t value) {
  _internal_set_unackedmessages(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.unackedMessages)
}
inline ::uint64_t CommandConsumerStatsResponse::_internal_unackedmessages() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unackedmessages_;
}
inline void CommandConsumerStatsResponse::_internal_set_unackedmessages(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.unackedmessages_ = value;
}

// optional bool blockedConsumerOnUnackedMsgs = 10;
inline bool CommandConsumerStatsResponse::has_blockedconsumeronunackedmsgs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void CommandConsumerStatsResponse::clear_blockedconsumeronunackedmsgs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blockedconsumeronunackedmsgs_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool CommandConsumerStatsResponse::blockedconsumeronunackedmsgs() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.blockedConsumerOnUnackedMsgs)
  return _internal_blockedconsumeronunackedmsgs();
}
inline void CommandConsumerStatsResponse::set_blockedconsumeronunackedmsgs(bool value) {
  _internal_set_blockedconsumeronunackedmsgs(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.blockedConsumerOnUnackedMsgs)
}
inline bool CommandConsumerStatsResponse::_internal_blockedconsumeronunackedmsgs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blockedconsumeronunackedmsgs_;
}
inline void CommandConsumerStatsResponse::_internal_set_blockedconsumeronunackedmsgs(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.blockedconsumeronunackedmsgs_ = value;
}

// optional string address = 11;
inline bool CommandConsumerStatsResponse::has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandConsumerStatsResponse::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandConsumerStatsResponse::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandConsumerStatsResponse::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.address)
}
inline std::string* CommandConsumerStatsResponse::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConsumerStatsResponse.address)
  return _s;
}
inline const std::string& CommandConsumerStatsResponse::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void CommandConsumerStatsResponse::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.address_.Set(value, GetArena());
}
inline std::string* CommandConsumerStatsResponse::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* CommandConsumerStatsResponse::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConsumerStatsResponse.address)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.address_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.address_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandConsumerStatsResponse::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConsumerStatsResponse.address)
}

// optional string connectedSince = 12;
inline bool CommandConsumerStatsResponse::has_connectedsince() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandConsumerStatsResponse::clear_connectedsince() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.connectedsince_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CommandConsumerStatsResponse::connectedsince() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.connectedSince)
  return _internal_connectedsince();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandConsumerStatsResponse::set_connectedsince(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.connectedsince_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.connectedSince)
}
inline std::string* CommandConsumerStatsResponse::mutable_connectedsince() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_connectedsince();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConsumerStatsResponse.connectedSince)
  return _s;
}
inline const std::string& CommandConsumerStatsResponse::_internal_connectedsince() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.connectedsince_.Get();
}
inline void CommandConsumerStatsResponse::_internal_set_connectedsince(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.connectedsince_.Set(value, GetArena());
}
inline std::string* CommandConsumerStatsResponse::_internal_mutable_connectedsince() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.connectedsince_.Mutable( GetArena());
}
inline std::string* CommandConsumerStatsResponse::release_connectedsince() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConsumerStatsResponse.connectedSince)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.connectedsince_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.connectedsince_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandConsumerStatsResponse::set_allocated_connectedsince(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.connectedsince_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.connectedsince_.IsDefault()) {
          _impl_.connectedsince_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConsumerStatsResponse.connectedSince)
}

// optional string type = 13;
inline bool CommandConsumerStatsResponse::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandConsumerStatsResponse::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CommandConsumerStatsResponse::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandConsumerStatsResponse::set_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.type)
}
inline std::string* CommandConsumerStatsResponse::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandConsumerStatsResponse.type)
  return _s;
}
inline const std::string& CommandConsumerStatsResponse::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_.Get();
}
inline void CommandConsumerStatsResponse::_internal_set_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* CommandConsumerStatsResponse::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* CommandConsumerStatsResponse::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandConsumerStatsResponse.type)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandConsumerStatsResponse::set_allocated_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandConsumerStatsResponse.type)
}

// optional double msgRateExpired = 14;
inline bool CommandConsumerStatsResponse::has_msgrateexpired() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void CommandConsumerStatsResponse::clear_msgrateexpired() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgrateexpired_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline double CommandConsumerStatsResponse::msgrateexpired() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.msgRateExpired)
  return _internal_msgrateexpired();
}
inline void CommandConsumerStatsResponse::set_msgrateexpired(double value) {
  _internal_set_msgrateexpired(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.msgRateExpired)
}
inline double CommandConsumerStatsResponse::_internal_msgrateexpired() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.msgrateexpired_;
}
inline void CommandConsumerStatsResponse::_internal_set_msgrateexpired(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.msgrateexpired_ = value;
}

// optional uint64 msgBacklog = 15;
inline bool CommandConsumerStatsResponse::has_msgbacklog() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void CommandConsumerStatsResponse::clear_msgbacklog() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgbacklog_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::uint64_t CommandConsumerStatsResponse::msgbacklog() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.msgBacklog)
  return _internal_msgbacklog();
}
inline void CommandConsumerStatsResponse::set_msgbacklog(::uint64_t value) {
  _internal_set_msgbacklog(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.msgBacklog)
}
inline ::uint64_t CommandConsumerStatsResponse::_internal_msgbacklog() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.msgbacklog_;
}
inline void CommandConsumerStatsResponse::_internal_set_msgbacklog(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.msgbacklog_ = value;
}

// optional double messageAckRate = 16;
inline bool CommandConsumerStatsResponse::has_messageackrate() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void CommandConsumerStatsResponse::clear_messageackrate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.messageackrate_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline double CommandConsumerStatsResponse::messageackrate() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandConsumerStatsResponse.messageAckRate)
  return _internal_messageackrate();
}
inline void CommandConsumerStatsResponse::set_messageackrate(double value) {
  _internal_set_messageackrate(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandConsumerStatsResponse.messageAckRate)
}
inline double CommandConsumerStatsResponse::_internal_messageackrate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.messageackrate_;
}
inline void CommandConsumerStatsResponse::_internal_set_messageackrate(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.messageackrate_ = value;
}

// -------------------------------------------------------------------

// CommandGetLastMessageId

// required uint64 consumer_id = 1;
inline bool CommandGetLastMessageId::has_consumer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandGetLastMessageId::clear_consumer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumer_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CommandGetLastMessageId::consumer_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetLastMessageId.consumer_id)
  return _internal_consumer_id();
}
inline void CommandGetLastMessageId::set_consumer_id(::uint64_t value) {
  _internal_set_consumer_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetLastMessageId.consumer_id)
}
inline ::uint64_t CommandGetLastMessageId::_internal_consumer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumer_id_;
}
inline void CommandGetLastMessageId::_internal_set_consumer_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.consumer_id_ = value;
}

// required uint64 request_id = 2;
inline bool CommandGetLastMessageId::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandGetLastMessageId::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandGetLastMessageId::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetLastMessageId.request_id)
  return _internal_request_id();
}
inline void CommandGetLastMessageId::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetLastMessageId.request_id)
}
inline ::uint64_t CommandGetLastMessageId::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandGetLastMessageId::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}

// -------------------------------------------------------------------

// CommandGetLastMessageIdResponse

// required .pulsar.proto.MessageIdData last_message_id = 1;
inline bool CommandGetLastMessageIdResponse::has_last_message_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_message_id_ != nullptr);
  return value;
}
inline void CommandGetLastMessageIdResponse::clear_last_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.last_message_id_ != nullptr) _impl_.last_message_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::MessageIdData& CommandGetLastMessageIdResponse::_internal_last_message_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::MessageIdData* p = _impl_.last_message_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::MessageIdData&>(::pulsar::proto::_MessageIdData_default_instance_);
}
inline const ::pulsar::proto::MessageIdData& CommandGetLastMessageIdResponse::last_message_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetLastMessageIdResponse.last_message_id)
  return _internal_last_message_id();
}
inline void CommandGetLastMessageIdResponse::unsafe_arena_set_allocated_last_message_id(::pulsar::proto::MessageIdData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_message_id_);
  }
  _impl_.last_message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandGetLastMessageIdResponse.last_message_id)
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::release_last_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* released = _impl_.last_message_id_;
  _impl_.last_message_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::unsafe_arena_release_last_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetLastMessageIdResponse.last_message_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::MessageIdData* temp = _impl_.last_message_id_;
  _impl_.last_message_id_ = nullptr;
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::_internal_mutable_last_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.last_message_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::MessageIdData>(GetArena());
    _impl_.last_message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(p);
  }
  return _impl_.last_message_id_;
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::mutable_last_message_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::MessageIdData* _msg = _internal_mutable_last_message_id();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetLastMessageIdResponse.last_message_id)
  return _msg;
}
inline void CommandGetLastMessageIdResponse::set_allocated_last_message_id(::pulsar::proto::MessageIdData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::MessageIdData*>(_impl_.last_message_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::MessageIdData*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.last_message_id_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetLastMessageIdResponse.last_message_id)
}

// required uint64 request_id = 2;
inline bool CommandGetLastMessageIdResponse::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandGetLastMessageIdResponse::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandGetLastMessageIdResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetLastMessageIdResponse.request_id)
  return _internal_request_id();
}
inline void CommandGetLastMessageIdResponse::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetLastMessageIdResponse.request_id)
}
inline ::uint64_t CommandGetLastMessageIdResponse::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandGetLastMessageIdResponse::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.request_id_ = value;
}

// optional .pulsar.proto.MessageIdData consumer_mark_delete_position = 3;
inline bool CommandGetLastMessageIdResponse::has_consumer_mark_delete_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.consumer_mark_delete_position_ != nullptr);
  return value;
}
inline void CommandGetLastMessageIdResponse::clear_consumer_mark_delete_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.consumer_mark_delete_position_ != nullptr) _impl_.consumer_mark_delete_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::pulsar::proto::MessageIdData& CommandGetLastMessageIdResponse::_internal_consumer_mark_delete_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::MessageIdData* p = _impl_.consumer_mark_delete_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::MessageIdData&>(::pulsar::proto::_MessageIdData_default_instance_);
}
inline const ::pulsar::proto::MessageIdData& CommandGetLastMessageIdResponse::consumer_mark_delete_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetLastMessageIdResponse.consumer_mark_delete_position)
  return _internal_consumer_mark_delete_position();
}
inline void CommandGetLastMessageIdResponse::unsafe_arena_set_allocated_consumer_mark_delete_position(::pulsar::proto::MessageIdData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.consumer_mark_delete_position_);
  }
  _impl_.consumer_mark_delete_position_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandGetLastMessageIdResponse.consumer_mark_delete_position)
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::release_consumer_mark_delete_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::MessageIdData* released = _impl_.consumer_mark_delete_position_;
  _impl_.consumer_mark_delete_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::unsafe_arena_release_consumer_mark_delete_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetLastMessageIdResponse.consumer_mark_delete_position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::MessageIdData* temp = _impl_.consumer_mark_delete_position_;
  _impl_.consumer_mark_delete_position_ = nullptr;
  return temp;
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::_internal_mutable_consumer_mark_delete_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.consumer_mark_delete_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::MessageIdData>(GetArena());
    _impl_.consumer_mark_delete_position_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(p);
  }
  return _impl_.consumer_mark_delete_position_;
}
inline ::pulsar::proto::MessageIdData* CommandGetLastMessageIdResponse::mutable_consumer_mark_delete_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::MessageIdData* _msg = _internal_mutable_consumer_mark_delete_position();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetLastMessageIdResponse.consumer_mark_delete_position)
  return _msg;
}
inline void CommandGetLastMessageIdResponse::set_allocated_consumer_mark_delete_position(::pulsar::proto::MessageIdData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::MessageIdData*>(_impl_.consumer_mark_delete_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::MessageIdData*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.consumer_mark_delete_position_ = reinterpret_cast<::pulsar::proto::MessageIdData*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetLastMessageIdResponse.consumer_mark_delete_position)
}

// -------------------------------------------------------------------

// CommandGetTopicsOfNamespace

// required uint64 request_id = 1;
inline bool CommandGetTopicsOfNamespace::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandGetTopicsOfNamespace::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandGetTopicsOfNamespace::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespace.request_id)
  return _internal_request_id();
}
inline void CommandGetTopicsOfNamespace::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespace.request_id)
}
inline ::uint64_t CommandGetTopicsOfNamespace::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandGetTopicsOfNamespace::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.request_id_ = value;
}

// required string namespace = 2;
inline bool CommandGetTopicsOfNamespace::has_namespace_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandGetTopicsOfNamespace::clear_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.namespace__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetTopicsOfNamespace::namespace_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespace.namespace)
  return _internal_namespace_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandGetTopicsOfNamespace::set_namespace_(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.namespace__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespace.namespace)
}
inline std::string* CommandGetTopicsOfNamespace::mutable_namespace_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetTopicsOfNamespace.namespace)
  return _s;
}
inline const std::string& CommandGetTopicsOfNamespace::_internal_namespace_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.namespace__.Get();
}
inline void CommandGetTopicsOfNamespace::_internal_set_namespace_(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.namespace__.Set(value, GetArena());
}
inline std::string* CommandGetTopicsOfNamespace::_internal_mutable_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.namespace__.Mutable( GetArena());
}
inline std::string* CommandGetTopicsOfNamespace::release_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetTopicsOfNamespace.namespace)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.namespace__.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.namespace__.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandGetTopicsOfNamespace::set_allocated_namespace_(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.namespace__.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.namespace__.IsDefault()) {
          _impl_.namespace__.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetTopicsOfNamespace.namespace)
}

// optional .pulsar.proto.CommandGetTopicsOfNamespace.Mode mode = 3 [default = PERSISTENT];
inline bool CommandGetTopicsOfNamespace::has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandGetTopicsOfNamespace::clear_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace::mode() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespace.mode)
  return _internal_mode();
}
inline void CommandGetTopicsOfNamespace::set_mode(::pulsar::proto::CommandGetTopicsOfNamespace_Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespace.mode)
}
inline ::pulsar::proto::CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace::_internal_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::CommandGetTopicsOfNamespace_Mode>(_impl_.mode_);
}
inline void CommandGetTopicsOfNamespace::_internal_set_mode(::pulsar::proto::CommandGetTopicsOfNamespace_Mode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::CommandGetTopicsOfNamespace_Mode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.mode_ = value;
}

// optional string topics_pattern = 4;
inline bool CommandGetTopicsOfNamespace::has_topics_pattern() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandGetTopicsOfNamespace::clear_topics_pattern() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topics_pattern_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandGetTopicsOfNamespace::topics_pattern() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespace.topics_pattern)
  return _internal_topics_pattern();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandGetTopicsOfNamespace::set_topics_pattern(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.topics_pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespace.topics_pattern)
}
inline std::string* CommandGetTopicsOfNamespace::mutable_topics_pattern() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topics_pattern();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetTopicsOfNamespace.topics_pattern)
  return _s;
}
inline const std::string& CommandGetTopicsOfNamespace::_internal_topics_pattern() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topics_pattern_.Get();
}
inline void CommandGetTopicsOfNamespace::_internal_set_topics_pattern(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.topics_pattern_.Set(value, GetArena());
}
inline std::string* CommandGetTopicsOfNamespace::_internal_mutable_topics_pattern() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.topics_pattern_.Mutable( GetArena());
}
inline std::string* CommandGetTopicsOfNamespace::release_topics_pattern() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetTopicsOfNamespace.topics_pattern)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.topics_pattern_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topics_pattern_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandGetTopicsOfNamespace::set_allocated_topics_pattern(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.topics_pattern_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topics_pattern_.IsDefault()) {
          _impl_.topics_pattern_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetTopicsOfNamespace.topics_pattern)
}

// optional string topics_hash = 5;
inline bool CommandGetTopicsOfNamespace::has_topics_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandGetTopicsOfNamespace::clear_topics_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topics_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandGetTopicsOfNamespace::topics_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespace.topics_hash)
  return _internal_topics_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandGetTopicsOfNamespace::set_topics_hash(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.topics_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespace.topics_hash)
}
inline std::string* CommandGetTopicsOfNamespace::mutable_topics_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topics_hash();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetTopicsOfNamespace.topics_hash)
  return _s;
}
inline const std::string& CommandGetTopicsOfNamespace::_internal_topics_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topics_hash_.Get();
}
inline void CommandGetTopicsOfNamespace::_internal_set_topics_hash(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.topics_hash_.Set(value, GetArena());
}
inline std::string* CommandGetTopicsOfNamespace::_internal_mutable_topics_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.topics_hash_.Mutable( GetArena());
}
inline std::string* CommandGetTopicsOfNamespace::release_topics_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetTopicsOfNamespace.topics_hash)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.topics_hash_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topics_hash_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandGetTopicsOfNamespace::set_allocated_topics_hash(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.topics_hash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topics_hash_.IsDefault()) {
          _impl_.topics_hash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetTopicsOfNamespace.topics_hash)
}

// -------------------------------------------------------------------

// CommandGetTopicsOfNamespaceResponse

// required uint64 request_id = 1;
inline bool CommandGetTopicsOfNamespaceResponse::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandGetTopicsOfNamespaceResponse::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandGetTopicsOfNamespaceResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespaceResponse.request_id)
  return _internal_request_id();
}
inline void CommandGetTopicsOfNamespaceResponse::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespaceResponse.request_id)
}
inline ::uint64_t CommandGetTopicsOfNamespaceResponse::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandGetTopicsOfNamespaceResponse::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}

// repeated string topics = 2;
inline int CommandGetTopicsOfNamespaceResponse::_internal_topics_size() const {
  return _internal_topics().size();
}
inline int CommandGetTopicsOfNamespaceResponse::topics_size() const {
  return _internal_topics_size();
}
inline void CommandGetTopicsOfNamespaceResponse::clear_topics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topics_.Clear();
}
inline std::string* CommandGetTopicsOfNamespaceResponse::add_topics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_topics()->Add();
  // @@protoc_insertion_point(field_add_mutable:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
  return _s;
}
inline const std::string& CommandGetTopicsOfNamespaceResponse::topics(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
  return _internal_topics().Get(index);
}
inline std::string* CommandGetTopicsOfNamespaceResponse::mutable_topics(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
  return _internal_mutable_topics()->Mutable(index);
}
inline void CommandGetTopicsOfNamespaceResponse::set_topics(int index, const std::string& value) {
  _internal_mutable_topics()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::set_topics(int index, std::string&& value) {
  _internal_mutable_topics()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::set_topics(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_topics()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::set_topics(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_topics()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::set_topics(int index, absl::string_view value) {
  _internal_mutable_topics()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::add_topics(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topics()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::add_topics(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topics()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::add_topics(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topics()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::add_topics(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topics()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline void CommandGetTopicsOfNamespaceResponse::add_topics(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topics()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CommandGetTopicsOfNamespaceResponse::topics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
  return _internal_topics();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CommandGetTopicsOfNamespaceResponse::mutable_topics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_topics();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CommandGetTopicsOfNamespaceResponse::_internal_topics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topics_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CommandGetTopicsOfNamespaceResponse::_internal_mutable_topics() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.topics_;
}

// optional bool filtered = 3 [default = false];
inline bool CommandGetTopicsOfNamespaceResponse::has_filtered() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandGetTopicsOfNamespaceResponse::clear_filtered() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filtered_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool CommandGetTopicsOfNamespaceResponse::filtered() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespaceResponse.filtered)
  return _internal_filtered();
}
inline void CommandGetTopicsOfNamespaceResponse::set_filtered(bool value) {
  _internal_set_filtered(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespaceResponse.filtered)
}
inline bool CommandGetTopicsOfNamespaceResponse::_internal_filtered() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filtered_;
}
inline void CommandGetTopicsOfNamespaceResponse::_internal_set_filtered(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.filtered_ = value;
}

// optional string topics_hash = 4;
inline bool CommandGetTopicsOfNamespaceResponse::has_topics_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandGetTopicsOfNamespaceResponse::clear_topics_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topics_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetTopicsOfNamespaceResponse::topics_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics_hash)
  return _internal_topics_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandGetTopicsOfNamespaceResponse::set_topics_hash(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topics_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics_hash)
}
inline std::string* CommandGetTopicsOfNamespaceResponse::mutable_topics_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topics_hash();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics_hash)
  return _s;
}
inline const std::string& CommandGetTopicsOfNamespaceResponse::_internal_topics_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topics_hash_.Get();
}
inline void CommandGetTopicsOfNamespaceResponse::_internal_set_topics_hash(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topics_hash_.Set(value, GetArena());
}
inline std::string* CommandGetTopicsOfNamespaceResponse::_internal_mutable_topics_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.topics_hash_.Mutable( GetArena());
}
inline std::string* CommandGetTopicsOfNamespaceResponse::release_topics_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics_hash)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.topics_hash_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topics_hash_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandGetTopicsOfNamespaceResponse::set_allocated_topics_hash(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.topics_hash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topics_hash_.IsDefault()) {
          _impl_.topics_hash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetTopicsOfNamespaceResponse.topics_hash)
}

// optional bool changed = 5 [default = true];
inline bool CommandGetTopicsOfNamespaceResponse::has_changed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandGetTopicsOfNamespaceResponse::clear_changed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.changed_ = true;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool CommandGetTopicsOfNamespaceResponse::changed() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetTopicsOfNamespaceResponse.changed)
  return _internal_changed();
}
inline void CommandGetTopicsOfNamespaceResponse::set_changed(bool value) {
  _internal_set_changed(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetTopicsOfNamespaceResponse.changed)
}
inline bool CommandGetTopicsOfNamespaceResponse::_internal_changed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.changed_;
}
inline void CommandGetTopicsOfNamespaceResponse::_internal_set_changed(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.changed_ = value;
}

// -------------------------------------------------------------------

// CommandWatchTopicList

// required uint64 request_id = 1;
inline bool CommandWatchTopicList::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandWatchTopicList::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandWatchTopicList::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicList.request_id)
  return _internal_request_id();
}
inline void CommandWatchTopicList::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicList.request_id)
}
inline ::uint64_t CommandWatchTopicList::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandWatchTopicList::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.request_id_ = value;
}

// required uint64 watcher_id = 2;
inline bool CommandWatchTopicList::has_watcher_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandWatchTopicList::clear_watcher_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.watcher_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t CommandWatchTopicList::watcher_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicList.watcher_id)
  return _internal_watcher_id();
}
inline void CommandWatchTopicList::set_watcher_id(::uint64_t value) {
  _internal_set_watcher_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicList.watcher_id)
}
inline ::uint64_t CommandWatchTopicList::_internal_watcher_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.watcher_id_;
}
inline void CommandWatchTopicList::_internal_set_watcher_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.watcher_id_ = value;
}

// required string namespace = 3;
inline bool CommandWatchTopicList::has_namespace_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandWatchTopicList::clear_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.namespace__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandWatchTopicList::namespace_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicList.namespace)
  return _internal_namespace_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandWatchTopicList::set_namespace_(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.namespace__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicList.namespace)
}
inline std::string* CommandWatchTopicList::mutable_namespace_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandWatchTopicList.namespace)
  return _s;
}
inline const std::string& CommandWatchTopicList::_internal_namespace_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.namespace__.Get();
}
inline void CommandWatchTopicList::_internal_set_namespace_(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.namespace__.Set(value, GetArena());
}
inline std::string* CommandWatchTopicList::_internal_mutable_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.namespace__.Mutable( GetArena());
}
inline std::string* CommandWatchTopicList::release_namespace_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandWatchTopicList.namespace)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.namespace__.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.namespace__.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandWatchTopicList::set_allocated_namespace_(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.namespace__.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.namespace__.IsDefault()) {
          _impl_.namespace__.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandWatchTopicList.namespace)
}

// required string topics_pattern = 4;
inline bool CommandWatchTopicList::has_topics_pattern() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandWatchTopicList::clear_topics_pattern() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topics_pattern_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandWatchTopicList::topics_pattern() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicList.topics_pattern)
  return _internal_topics_pattern();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandWatchTopicList::set_topics_pattern(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.topics_pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicList.topics_pattern)
}
inline std::string* CommandWatchTopicList::mutable_topics_pattern() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topics_pattern();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandWatchTopicList.topics_pattern)
  return _s;
}
inline const std::string& CommandWatchTopicList::_internal_topics_pattern() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topics_pattern_.Get();
}
inline void CommandWatchTopicList::_internal_set_topics_pattern(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.topics_pattern_.Set(value, GetArena());
}
inline std::string* CommandWatchTopicList::_internal_mutable_topics_pattern() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.topics_pattern_.Mutable( GetArena());
}
inline std::string* CommandWatchTopicList::release_topics_pattern() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandWatchTopicList.topics_pattern)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.topics_pattern_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topics_pattern_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandWatchTopicList::set_allocated_topics_pattern(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.topics_pattern_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topics_pattern_.IsDefault()) {
          _impl_.topics_pattern_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandWatchTopicList.topics_pattern)
}

// optional string topics_hash = 5;
inline bool CommandWatchTopicList::has_topics_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandWatchTopicList::clear_topics_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topics_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandWatchTopicList::topics_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicList.topics_hash)
  return _internal_topics_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandWatchTopicList::set_topics_hash(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.topics_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicList.topics_hash)
}
inline std::string* CommandWatchTopicList::mutable_topics_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topics_hash();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandWatchTopicList.topics_hash)
  return _s;
}
inline const std::string& CommandWatchTopicList::_internal_topics_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topics_hash_.Get();
}
inline void CommandWatchTopicList::_internal_set_topics_hash(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.topics_hash_.Set(value, GetArena());
}
inline std::string* CommandWatchTopicList::_internal_mutable_topics_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.topics_hash_.Mutable( GetArena());
}
inline std::string* CommandWatchTopicList::release_topics_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandWatchTopicList.topics_hash)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.topics_hash_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topics_hash_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandWatchTopicList::set_allocated_topics_hash(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.topics_hash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topics_hash_.IsDefault()) {
          _impl_.topics_hash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandWatchTopicList.topics_hash)
}

// -------------------------------------------------------------------

// CommandWatchTopicListSuccess

// required uint64 request_id = 1;
inline bool CommandWatchTopicListSuccess::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandWatchTopicListSuccess::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandWatchTopicListSuccess::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicListSuccess.request_id)
  return _internal_request_id();
}
inline void CommandWatchTopicListSuccess::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicListSuccess.request_id)
}
inline ::uint64_t CommandWatchTopicListSuccess::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandWatchTopicListSuccess::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}

// required uint64 watcher_id = 2;
inline bool CommandWatchTopicListSuccess::has_watcher_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandWatchTopicListSuccess::clear_watcher_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.watcher_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandWatchTopicListSuccess::watcher_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicListSuccess.watcher_id)
  return _internal_watcher_id();
}
inline void CommandWatchTopicListSuccess::set_watcher_id(::uint64_t value) {
  _internal_set_watcher_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicListSuccess.watcher_id)
}
inline ::uint64_t CommandWatchTopicListSuccess::_internal_watcher_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.watcher_id_;
}
inline void CommandWatchTopicListSuccess::_internal_set_watcher_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.watcher_id_ = value;
}

// repeated string topic = 3;
inline int CommandWatchTopicListSuccess::_internal_topic_size() const {
  return _internal_topic().size();
}
inline int CommandWatchTopicListSuccess::topic_size() const {
  return _internal_topic_size();
}
inline void CommandWatchTopicListSuccess::clear_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.Clear();
}
inline std::string* CommandWatchTopicListSuccess::add_topic()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_topic()->Add();
  // @@protoc_insertion_point(field_add_mutable:pulsar.proto.CommandWatchTopicListSuccess.topic)
  return _s;
}
inline const std::string& CommandWatchTopicListSuccess::topic(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicListSuccess.topic)
  return _internal_topic().Get(index);
}
inline std::string* CommandWatchTopicListSuccess::mutable_topic(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandWatchTopicListSuccess.topic)
  return _internal_mutable_topic()->Mutable(index);
}
inline void CommandWatchTopicListSuccess::set_topic(int index, const std::string& value) {
  _internal_mutable_topic()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline void CommandWatchTopicListSuccess::set_topic(int index, std::string&& value) {
  _internal_mutable_topic()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline void CommandWatchTopicListSuccess::set_topic(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_topic()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline void CommandWatchTopicListSuccess::set_topic(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_topic()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline void CommandWatchTopicListSuccess::set_topic(int index, absl::string_view value) {
  _internal_mutable_topic()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline void CommandWatchTopicListSuccess::add_topic(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topic()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline void CommandWatchTopicListSuccess::add_topic(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topic()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline void CommandWatchTopicListSuccess::add_topic(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topic()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline void CommandWatchTopicListSuccess::add_topic(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topic()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline void CommandWatchTopicListSuccess::add_topic(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topic()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:pulsar.proto.CommandWatchTopicListSuccess.topic)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CommandWatchTopicListSuccess::topic() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandWatchTopicListSuccess.topic)
  return _internal_topic();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CommandWatchTopicListSuccess::mutable_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandWatchTopicListSuccess.topic)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_topic();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CommandWatchTopicListSuccess::_internal_topic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CommandWatchTopicListSuccess::_internal_mutable_topic() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.topic_;
}

// required string topics_hash = 4;
inline bool CommandWatchTopicListSuccess::has_topics_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandWatchTopicListSuccess::clear_topics_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topics_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandWatchTopicListSuccess::topics_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicListSuccess.topics_hash)
  return _internal_topics_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandWatchTopicListSuccess::set_topics_hash(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topics_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicListSuccess.topics_hash)
}
inline std::string* CommandWatchTopicListSuccess::mutable_topics_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topics_hash();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandWatchTopicListSuccess.topics_hash)
  return _s;
}
inline const std::string& CommandWatchTopicListSuccess::_internal_topics_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topics_hash_.Get();
}
inline void CommandWatchTopicListSuccess::_internal_set_topics_hash(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topics_hash_.Set(value, GetArena());
}
inline std::string* CommandWatchTopicListSuccess::_internal_mutable_topics_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.topics_hash_.Mutable( GetArena());
}
inline std::string* CommandWatchTopicListSuccess::release_topics_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandWatchTopicListSuccess.topics_hash)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.topics_hash_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topics_hash_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandWatchTopicListSuccess::set_allocated_topics_hash(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.topics_hash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topics_hash_.IsDefault()) {
          _impl_.topics_hash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandWatchTopicListSuccess.topics_hash)
}

// -------------------------------------------------------------------

// CommandWatchTopicUpdate

// required uint64 watcher_id = 1;
inline bool CommandWatchTopicUpdate::has_watcher_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandWatchTopicUpdate::clear_watcher_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.watcher_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandWatchTopicUpdate::watcher_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicUpdate.watcher_id)
  return _internal_watcher_id();
}
inline void CommandWatchTopicUpdate::set_watcher_id(::uint64_t value) {
  _internal_set_watcher_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicUpdate.watcher_id)
}
inline ::uint64_t CommandWatchTopicUpdate::_internal_watcher_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.watcher_id_;
}
inline void CommandWatchTopicUpdate::_internal_set_watcher_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.watcher_id_ = value;
}

// repeated string new_topics = 2;
inline int CommandWatchTopicUpdate::_internal_new_topics_size() const {
  return _internal_new_topics().size();
}
inline int CommandWatchTopicUpdate::new_topics_size() const {
  return _internal_new_topics_size();
}
inline void CommandWatchTopicUpdate::clear_new_topics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_topics_.Clear();
}
inline std::string* CommandWatchTopicUpdate::add_new_topics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_new_topics()->Add();
  // @@protoc_insertion_point(field_add_mutable:pulsar.proto.CommandWatchTopicUpdate.new_topics)
  return _s;
}
inline const std::string& CommandWatchTopicUpdate::new_topics(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicUpdate.new_topics)
  return _internal_new_topics().Get(index);
}
inline std::string* CommandWatchTopicUpdate::mutable_new_topics(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandWatchTopicUpdate.new_topics)
  return _internal_mutable_new_topics()->Mutable(index);
}
inline void CommandWatchTopicUpdate::set_new_topics(int index, const std::string& value) {
  _internal_mutable_new_topics()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline void CommandWatchTopicUpdate::set_new_topics(int index, std::string&& value) {
  _internal_mutable_new_topics()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline void CommandWatchTopicUpdate::set_new_topics(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_new_topics()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline void CommandWatchTopicUpdate::set_new_topics(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_new_topics()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline void CommandWatchTopicUpdate::set_new_topics(int index, absl::string_view value) {
  _internal_mutable_new_topics()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline void CommandWatchTopicUpdate::add_new_topics(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_new_topics()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline void CommandWatchTopicUpdate::add_new_topics(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_new_topics()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline void CommandWatchTopicUpdate::add_new_topics(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_new_topics()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline void CommandWatchTopicUpdate::add_new_topics(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_new_topics()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline void CommandWatchTopicUpdate::add_new_topics(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_new_topics()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:pulsar.proto.CommandWatchTopicUpdate.new_topics)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CommandWatchTopicUpdate::new_topics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandWatchTopicUpdate.new_topics)
  return _internal_new_topics();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CommandWatchTopicUpdate::mutable_new_topics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandWatchTopicUpdate.new_topics)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_new_topics();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CommandWatchTopicUpdate::_internal_new_topics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.new_topics_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CommandWatchTopicUpdate::_internal_mutable_new_topics() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.new_topics_;
}

// repeated string deleted_topics = 3;
inline int CommandWatchTopicUpdate::_internal_deleted_topics_size() const {
  return _internal_deleted_topics().size();
}
inline int CommandWatchTopicUpdate::deleted_topics_size() const {
  return _internal_deleted_topics_size();
}
inline void CommandWatchTopicUpdate::clear_deleted_topics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deleted_topics_.Clear();
}
inline std::string* CommandWatchTopicUpdate::add_deleted_topics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_deleted_topics()->Add();
  // @@protoc_insertion_point(field_add_mutable:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
  return _s;
}
inline const std::string& CommandWatchTopicUpdate::deleted_topics(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
  return _internal_deleted_topics().Get(index);
}
inline std::string* CommandWatchTopicUpdate::mutable_deleted_topics(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
  return _internal_mutable_deleted_topics()->Mutable(index);
}
inline void CommandWatchTopicUpdate::set_deleted_topics(int index, const std::string& value) {
  _internal_mutable_deleted_topics()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline void CommandWatchTopicUpdate::set_deleted_topics(int index, std::string&& value) {
  _internal_mutable_deleted_topics()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline void CommandWatchTopicUpdate::set_deleted_topics(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_deleted_topics()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline void CommandWatchTopicUpdate::set_deleted_topics(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_deleted_topics()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline void CommandWatchTopicUpdate::set_deleted_topics(int index, absl::string_view value) {
  _internal_mutable_deleted_topics()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline void CommandWatchTopicUpdate::add_deleted_topics(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_deleted_topics()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline void CommandWatchTopicUpdate::add_deleted_topics(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_deleted_topics()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline void CommandWatchTopicUpdate::add_deleted_topics(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_deleted_topics()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline void CommandWatchTopicUpdate::add_deleted_topics(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_deleted_topics()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline void CommandWatchTopicUpdate::add_deleted_topics(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_deleted_topics()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CommandWatchTopicUpdate::deleted_topics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
  return _internal_deleted_topics();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CommandWatchTopicUpdate::mutable_deleted_topics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandWatchTopicUpdate.deleted_topics)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_deleted_topics();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CommandWatchTopicUpdate::_internal_deleted_topics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.deleted_topics_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CommandWatchTopicUpdate::_internal_mutable_deleted_topics() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.deleted_topics_;
}

// required string topics_hash = 4;
inline bool CommandWatchTopicUpdate::has_topics_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandWatchTopicUpdate::clear_topics_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topics_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandWatchTopicUpdate::topics_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicUpdate.topics_hash)
  return _internal_topics_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandWatchTopicUpdate::set_topics_hash(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topics_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicUpdate.topics_hash)
}
inline std::string* CommandWatchTopicUpdate::mutable_topics_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topics_hash();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandWatchTopicUpdate.topics_hash)
  return _s;
}
inline const std::string& CommandWatchTopicUpdate::_internal_topics_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topics_hash_.Get();
}
inline void CommandWatchTopicUpdate::_internal_set_topics_hash(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topics_hash_.Set(value, GetArena());
}
inline std::string* CommandWatchTopicUpdate::_internal_mutable_topics_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.topics_hash_.Mutable( GetArena());
}
inline std::string* CommandWatchTopicUpdate::release_topics_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandWatchTopicUpdate.topics_hash)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.topics_hash_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topics_hash_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandWatchTopicUpdate::set_allocated_topics_hash(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.topics_hash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topics_hash_.IsDefault()) {
          _impl_.topics_hash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandWatchTopicUpdate.topics_hash)
}

// -------------------------------------------------------------------

// CommandWatchTopicListClose

// required uint64 request_id = 1;
inline bool CommandWatchTopicListClose::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandWatchTopicListClose::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CommandWatchTopicListClose::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicListClose.request_id)
  return _internal_request_id();
}
inline void CommandWatchTopicListClose::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicListClose.request_id)
}
inline ::uint64_t CommandWatchTopicListClose::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandWatchTopicListClose::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.request_id_ = value;
}

// required uint64 watcher_id = 2;
inline bool CommandWatchTopicListClose::has_watcher_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandWatchTopicListClose::clear_watcher_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.watcher_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandWatchTopicListClose::watcher_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandWatchTopicListClose.watcher_id)
  return _internal_watcher_id();
}
inline void CommandWatchTopicListClose::set_watcher_id(::uint64_t value) {
  _internal_set_watcher_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandWatchTopicListClose.watcher_id)
}
inline ::uint64_t CommandWatchTopicListClose::_internal_watcher_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.watcher_id_;
}
inline void CommandWatchTopicListClose::_internal_set_watcher_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.watcher_id_ = value;
}

// -------------------------------------------------------------------

// CommandGetSchema

// required uint64 request_id = 1;
inline bool CommandGetSchema::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandGetSchema::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandGetSchema::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchema.request_id)
  return _internal_request_id();
}
inline void CommandGetSchema::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchema.request_id)
}
inline ::uint64_t CommandGetSchema::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandGetSchema::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.request_id_ = value;
}

// required string topic = 2;
inline bool CommandGetSchema::has_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandGetSchema::clear_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetSchema::topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchema.topic)
  return _internal_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandGetSchema::set_topic(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchema.topic)
}
inline std::string* CommandGetSchema::mutable_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetSchema.topic)
  return _s;
}
inline const std::string& CommandGetSchema::_internal_topic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_.Get();
}
inline void CommandGetSchema::_internal_set_topic(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(value, GetArena());
}
inline std::string* CommandGetSchema::_internal_mutable_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.topic_.Mutable( GetArena());
}
inline std::string* CommandGetSchema::release_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetSchema.topic)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.topic_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topic_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandGetSchema::set_allocated_topic(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.topic_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topic_.IsDefault()) {
          _impl_.topic_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetSchema.topic)
}

// optional bytes schema_version = 3;
inline bool CommandGetSchema::has_schema_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandGetSchema::clear_schema_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.schema_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandGetSchema::schema_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchema.schema_version)
  return _internal_schema_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandGetSchema::set_schema_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.schema_version_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchema.schema_version)
}
inline std::string* CommandGetSchema::mutable_schema_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_schema_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetSchema.schema_version)
  return _s;
}
inline const std::string& CommandGetSchema::_internal_schema_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.schema_version_.Get();
}
inline void CommandGetSchema::_internal_set_schema_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.schema_version_.Set(value, GetArena());
}
inline std::string* CommandGetSchema::_internal_mutable_schema_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.schema_version_.Mutable( GetArena());
}
inline std::string* CommandGetSchema::release_schema_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetSchema.schema_version)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.schema_version_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.schema_version_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandGetSchema::set_allocated_schema_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.schema_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_version_.IsDefault()) {
          _impl_.schema_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetSchema.schema_version)
}

// -------------------------------------------------------------------

// CommandGetSchemaResponse

// required uint64 request_id = 1;
inline bool CommandGetSchemaResponse::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandGetSchemaResponse::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandGetSchemaResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchemaResponse.request_id)
  return _internal_request_id();
}
inline void CommandGetSchemaResponse::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchemaResponse.request_id)
}
inline ::uint64_t CommandGetSchemaResponse::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandGetSchemaResponse::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.request_id_ = value;
}

// optional .pulsar.proto.ServerError error_code = 2;
inline bool CommandGetSchemaResponse::has_error_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandGetSchemaResponse::clear_error_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::ServerError CommandGetSchemaResponse::error_code() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchemaResponse.error_code)
  return _internal_error_code();
}
inline void CommandGetSchemaResponse::set_error_code(::pulsar::proto::ServerError value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchemaResponse.error_code)
}
inline ::pulsar::proto::ServerError CommandGetSchemaResponse::_internal_error_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::ServerError>(_impl_.error_code_);
}
inline void CommandGetSchemaResponse::_internal_set_error_code(::pulsar::proto::ServerError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::ServerError_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.error_code_ = value;
}

// optional string error_message = 3;
inline bool CommandGetSchemaResponse::has_error_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandGetSchemaResponse::clear_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetSchemaResponse::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchemaResponse.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandGetSchemaResponse::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchemaResponse.error_message)
}
inline std::string* CommandGetSchemaResponse::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetSchemaResponse.error_message)
  return _s;
}
inline const std::string& CommandGetSchemaResponse::_internal_error_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_message_.Get();
}
inline void CommandGetSchemaResponse::_internal_set_error_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* CommandGetSchemaResponse::_internal_mutable_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* CommandGetSchemaResponse::release_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetSchemaResponse.error_message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.error_message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.error_message_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandGetSchemaResponse::set_allocated_error_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetSchemaResponse.error_message)
}

// optional .pulsar.proto.Schema schema = 4;
inline bool CommandGetSchemaResponse::has_schema() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schema_ != nullptr);
  return value;
}
inline void CommandGetSchemaResponse::clear_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.schema_ != nullptr) _impl_.schema_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::pulsar::proto::Schema& CommandGetSchemaResponse::_internal_schema() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::Schema* p = _impl_.schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::Schema&>(::pulsar::proto::_Schema_default_instance_);
}
inline const ::pulsar::proto::Schema& CommandGetSchemaResponse::schema() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchemaResponse.schema)
  return _internal_schema();
}
inline void CommandGetSchemaResponse::unsafe_arena_set_allocated_schema(::pulsar::proto::Schema* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.schema_);
  }
  _impl_.schema_ = reinterpret_cast<::pulsar::proto::Schema*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandGetSchemaResponse.schema)
}
inline ::pulsar::proto::Schema* CommandGetSchemaResponse::release_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::pulsar::proto::Schema* released = _impl_.schema_;
  _impl_.schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::Schema* CommandGetSchemaResponse::unsafe_arena_release_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetSchemaResponse.schema)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::pulsar::proto::Schema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
  return temp;
}
inline ::pulsar::proto::Schema* CommandGetSchemaResponse::_internal_mutable_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::Schema>(GetArena());
    _impl_.schema_ = reinterpret_cast<::pulsar::proto::Schema*>(p);
  }
  return _impl_.schema_;
}
inline ::pulsar::proto::Schema* CommandGetSchemaResponse::mutable_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::Schema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetSchemaResponse.schema)
  return _msg;
}
inline void CommandGetSchemaResponse::set_allocated_schema(::pulsar::proto::Schema* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::Schema*>(_impl_.schema_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::Schema*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.schema_ = reinterpret_cast<::pulsar::proto::Schema*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetSchemaResponse.schema)
}

// optional bytes schema_version = 5;
inline bool CommandGetSchemaResponse::has_schema_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandGetSchemaResponse::clear_schema_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.schema_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandGetSchemaResponse::schema_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetSchemaResponse.schema_version)
  return _internal_schema_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandGetSchemaResponse::set_schema_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.schema_version_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetSchemaResponse.schema_version)
}
inline std::string* CommandGetSchemaResponse::mutable_schema_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_schema_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetSchemaResponse.schema_version)
  return _s;
}
inline const std::string& CommandGetSchemaResponse::_internal_schema_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.schema_version_.Get();
}
inline void CommandGetSchemaResponse::_internal_set_schema_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.schema_version_.Set(value, GetArena());
}
inline std::string* CommandGetSchemaResponse::_internal_mutable_schema_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.schema_version_.Mutable( GetArena());
}
inline std::string* CommandGetSchemaResponse::release_schema_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetSchemaResponse.schema_version)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.schema_version_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.schema_version_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandGetSchemaResponse::set_allocated_schema_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.schema_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_version_.IsDefault()) {
          _impl_.schema_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetSchemaResponse.schema_version)
}

// -------------------------------------------------------------------

// CommandGetOrCreateSchema

// required uint64 request_id = 1;
inline bool CommandGetOrCreateSchema::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandGetOrCreateSchema::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandGetOrCreateSchema::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetOrCreateSchema.request_id)
  return _internal_request_id();
}
inline void CommandGetOrCreateSchema::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetOrCreateSchema.request_id)
}
inline ::uint64_t CommandGetOrCreateSchema::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandGetOrCreateSchema::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.request_id_ = value;
}

// required string topic = 2;
inline bool CommandGetOrCreateSchema::has_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandGetOrCreateSchema::clear_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetOrCreateSchema::topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetOrCreateSchema.topic)
  return _internal_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandGetOrCreateSchema::set_topic(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetOrCreateSchema.topic)
}
inline std::string* CommandGetOrCreateSchema::mutable_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetOrCreateSchema.topic)
  return _s;
}
inline const std::string& CommandGetOrCreateSchema::_internal_topic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_.Get();
}
inline void CommandGetOrCreateSchema::_internal_set_topic(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(value, GetArena());
}
inline std::string* CommandGetOrCreateSchema::_internal_mutable_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.topic_.Mutable( GetArena());
}
inline std::string* CommandGetOrCreateSchema::release_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetOrCreateSchema.topic)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.topic_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topic_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandGetOrCreateSchema::set_allocated_topic(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.topic_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topic_.IsDefault()) {
          _impl_.topic_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetOrCreateSchema.topic)
}

// required .pulsar.proto.Schema schema = 3;
inline bool CommandGetOrCreateSchema::has_schema() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schema_ != nullptr);
  return value;
}
inline void CommandGetOrCreateSchema::clear_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.schema_ != nullptr) _impl_.schema_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::pulsar::proto::Schema& CommandGetOrCreateSchema::_internal_schema() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::Schema* p = _impl_.schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::Schema&>(::pulsar::proto::_Schema_default_instance_);
}
inline const ::pulsar::proto::Schema& CommandGetOrCreateSchema::schema() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetOrCreateSchema.schema)
  return _internal_schema();
}
inline void CommandGetOrCreateSchema::unsafe_arena_set_allocated_schema(::pulsar::proto::Schema* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.schema_);
  }
  _impl_.schema_ = reinterpret_cast<::pulsar::proto::Schema*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandGetOrCreateSchema.schema)
}
inline ::pulsar::proto::Schema* CommandGetOrCreateSchema::release_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::Schema* released = _impl_.schema_;
  _impl_.schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::Schema* CommandGetOrCreateSchema::unsafe_arena_release_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetOrCreateSchema.schema)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::Schema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
  return temp;
}
inline ::pulsar::proto::Schema* CommandGetOrCreateSchema::_internal_mutable_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::Schema>(GetArena());
    _impl_.schema_ = reinterpret_cast<::pulsar::proto::Schema*>(p);
  }
  return _impl_.schema_;
}
inline ::pulsar::proto::Schema* CommandGetOrCreateSchema::mutable_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::Schema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetOrCreateSchema.schema)
  return _msg;
}
inline void CommandGetOrCreateSchema::set_allocated_schema(::pulsar::proto::Schema* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::Schema*>(_impl_.schema_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::Schema*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.schema_ = reinterpret_cast<::pulsar::proto::Schema*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetOrCreateSchema.schema)
}

// -------------------------------------------------------------------

// CommandGetOrCreateSchemaResponse

// required uint64 request_id = 1;
inline bool CommandGetOrCreateSchemaResponse::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandGetOrCreateSchemaResponse::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandGetOrCreateSchemaResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetOrCreateSchemaResponse.request_id)
  return _internal_request_id();
}
inline void CommandGetOrCreateSchemaResponse::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetOrCreateSchemaResponse.request_id)
}
inline ::uint64_t CommandGetOrCreateSchemaResponse::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandGetOrCreateSchemaResponse::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.request_id_ = value;
}

// optional .pulsar.proto.ServerError error_code = 2;
inline bool CommandGetOrCreateSchemaResponse::has_error_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandGetOrCreateSchemaResponse::clear_error_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::pulsar::proto::ServerError CommandGetOrCreateSchemaResponse::error_code() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetOrCreateSchemaResponse.error_code)
  return _internal_error_code();
}
inline void CommandGetOrCreateSchemaResponse::set_error_code(::pulsar::proto::ServerError value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetOrCreateSchemaResponse.error_code)
}
inline ::pulsar::proto::ServerError CommandGetOrCreateSchemaResponse::_internal_error_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::ServerError>(_impl_.error_code_);
}
inline void CommandGetOrCreateSchemaResponse::_internal_set_error_code(::pulsar::proto::ServerError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::ServerError_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.error_code_ = value;
}

// optional string error_message = 3;
inline bool CommandGetOrCreateSchemaResponse::has_error_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandGetOrCreateSchemaResponse::clear_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetOrCreateSchemaResponse::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetOrCreateSchemaResponse.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandGetOrCreateSchemaResponse::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetOrCreateSchemaResponse.error_message)
}
inline std::string* CommandGetOrCreateSchemaResponse::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetOrCreateSchemaResponse.error_message)
  return _s;
}
inline const std::string& CommandGetOrCreateSchemaResponse::_internal_error_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_message_.Get();
}
inline void CommandGetOrCreateSchemaResponse::_internal_set_error_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* CommandGetOrCreateSchemaResponse::_internal_mutable_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* CommandGetOrCreateSchemaResponse::release_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetOrCreateSchemaResponse.error_message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.error_message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.error_message_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandGetOrCreateSchemaResponse::set_allocated_error_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetOrCreateSchemaResponse.error_message)
}

// optional bytes schema_version = 4;
inline bool CommandGetOrCreateSchemaResponse::has_schema_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandGetOrCreateSchemaResponse::clear_schema_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.schema_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandGetOrCreateSchemaResponse::schema_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandGetOrCreateSchemaResponse.schema_version)
  return _internal_schema_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandGetOrCreateSchemaResponse::set_schema_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.schema_version_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandGetOrCreateSchemaResponse.schema_version)
}
inline std::string* CommandGetOrCreateSchemaResponse::mutable_schema_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_schema_version();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandGetOrCreateSchemaResponse.schema_version)
  return _s;
}
inline const std::string& CommandGetOrCreateSchemaResponse::_internal_schema_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.schema_version_.Get();
}
inline void CommandGetOrCreateSchemaResponse::_internal_set_schema_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.schema_version_.Set(value, GetArena());
}
inline std::string* CommandGetOrCreateSchemaResponse::_internal_mutable_schema_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.schema_version_.Mutable( GetArena());
}
inline std::string* CommandGetOrCreateSchemaResponse::release_schema_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandGetOrCreateSchemaResponse.schema_version)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.schema_version_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.schema_version_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandGetOrCreateSchemaResponse::set_allocated_schema_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.schema_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_version_.IsDefault()) {
          _impl_.schema_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandGetOrCreateSchemaResponse.schema_version)
}

// -------------------------------------------------------------------

// CommandTcClientConnectRequest

// required uint64 request_id = 1;
inline bool CommandTcClientConnectRequest::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandTcClientConnectRequest::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CommandTcClientConnectRequest::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTcClientConnectRequest.request_id)
  return _internal_request_id();
}
inline void CommandTcClientConnectRequest::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTcClientConnectRequest.request_id)
}
inline ::uint64_t CommandTcClientConnectRequest::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandTcClientConnectRequest::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.request_id_ = value;
}

// required uint64 tc_id = 2 [default = 0];
inline bool CommandTcClientConnectRequest::has_tc_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandTcClientConnectRequest::clear_tc_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tc_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandTcClientConnectRequest::tc_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTcClientConnectRequest.tc_id)
  return _internal_tc_id();
}
inline void CommandTcClientConnectRequest::set_tc_id(::uint64_t value) {
  _internal_set_tc_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTcClientConnectRequest.tc_id)
}
inline ::uint64_t CommandTcClientConnectRequest::_internal_tc_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tc_id_;
}
inline void CommandTcClientConnectRequest::_internal_set_tc_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tc_id_ = value;
}

// -------------------------------------------------------------------

// CommandTcClientConnectResponse

// required uint64 request_id = 1;
inline bool CommandTcClientConnectResponse::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandTcClientConnectResponse::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandTcClientConnectResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTcClientConnectResponse.request_id)
  return _internal_request_id();
}
inline void CommandTcClientConnectResponse::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTcClientConnectResponse.request_id)
}
inline ::uint64_t CommandTcClientConnectResponse::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandTcClientConnectResponse::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}

// optional .pulsar.proto.ServerError error = 2;
inline bool CommandTcClientConnectResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandTcClientConnectResponse::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::pulsar::proto::ServerError CommandTcClientConnectResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTcClientConnectResponse.error)
  return _internal_error();
}
inline void CommandTcClientConnectResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTcClientConnectResponse.error)
}
inline ::pulsar::proto::ServerError CommandTcClientConnectResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::ServerError>(_impl_.error_);
}
inline void CommandTcClientConnectResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::ServerError_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.error_ = value;
}

// optional string message = 3;
inline bool CommandTcClientConnectResponse::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandTcClientConnectResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandTcClientConnectResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandTcClientConnectResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandTcClientConnectResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandTcClientConnectResponse.message)
}
inline std::string* CommandTcClientConnectResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandTcClientConnectResponse.message)
  return _s;
}
inline const std::string& CommandTcClientConnectResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void CommandTcClientConnectResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* CommandTcClientConnectResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* CommandTcClientConnectResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandTcClientConnectResponse.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandTcClientConnectResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandTcClientConnectResponse.message)
}

// -------------------------------------------------------------------

// CommandNewTxn

// required uint64 request_id = 1;
inline bool CommandNewTxn::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandNewTxn::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CommandNewTxn::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandNewTxn.request_id)
  return _internal_request_id();
}
inline void CommandNewTxn::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandNewTxn.request_id)
}
inline ::uint64_t CommandNewTxn::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandNewTxn::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.request_id_ = value;
}

// optional uint64 txn_ttl_seconds = 2 [default = 0];
inline bool CommandNewTxn::has_txn_ttl_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandNewTxn::clear_txn_ttl_seconds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txn_ttl_seconds_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandNewTxn::txn_ttl_seconds() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandNewTxn.txn_ttl_seconds)
  return _internal_txn_ttl_seconds();
}
inline void CommandNewTxn::set_txn_ttl_seconds(::uint64_t value) {
  _internal_set_txn_ttl_seconds(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandNewTxn.txn_ttl_seconds)
}
inline ::uint64_t CommandNewTxn::_internal_txn_ttl_seconds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txn_ttl_seconds_;
}
inline void CommandNewTxn::_internal_set_txn_ttl_seconds(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.txn_ttl_seconds_ = value;
}

// optional uint64 tc_id = 3 [default = 0];
inline bool CommandNewTxn::has_tc_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandNewTxn::clear_tc_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tc_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandNewTxn::tc_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandNewTxn.tc_id)
  return _internal_tc_id();
}
inline void CommandNewTxn::set_tc_id(::uint64_t value) {
  _internal_set_tc_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandNewTxn.tc_id)
}
inline ::uint64_t CommandNewTxn::_internal_tc_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tc_id_;
}
inline void CommandNewTxn::_internal_set_tc_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.tc_id_ = value;
}

// -------------------------------------------------------------------

// CommandNewTxnResponse

// required uint64 request_id = 1;
inline bool CommandNewTxnResponse::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandNewTxnResponse::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandNewTxnResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandNewTxnResponse.request_id)
  return _internal_request_id();
}
inline void CommandNewTxnResponse::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandNewTxnResponse.request_id)
}
inline ::uint64_t CommandNewTxnResponse::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandNewTxnResponse::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandNewTxnResponse::has_txnid_least_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandNewTxnResponse::clear_txnid_least_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_least_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandNewTxnResponse::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandNewTxnResponse.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandNewTxnResponse::set_txnid_least_bits(::uint64_t value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandNewTxnResponse.txnid_least_bits)
}
inline ::uint64_t CommandNewTxnResponse::_internal_txnid_least_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_least_bits_;
}
inline void CommandNewTxnResponse::_internal_set_txnid_least_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.txnid_least_bits_ = value;
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandNewTxnResponse::has_txnid_most_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandNewTxnResponse::clear_txnid_most_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_most_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandNewTxnResponse::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandNewTxnResponse.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandNewTxnResponse::set_txnid_most_bits(::uint64_t value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandNewTxnResponse.txnid_most_bits)
}
inline ::uint64_t CommandNewTxnResponse::_internal_txnid_most_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_most_bits_;
}
inline void CommandNewTxnResponse::_internal_set_txnid_most_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.txnid_most_bits_ = value;
}

// optional .pulsar.proto.ServerError error = 4;
inline bool CommandNewTxnResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandNewTxnResponse::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::ServerError CommandNewTxnResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandNewTxnResponse.error)
  return _internal_error();
}
inline void CommandNewTxnResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandNewTxnResponse.error)
}
inline ::pulsar::proto::ServerError CommandNewTxnResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::ServerError>(_impl_.error_);
}
inline void CommandNewTxnResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::ServerError_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.error_ = value;
}

// optional string message = 5;
inline bool CommandNewTxnResponse::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandNewTxnResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandNewTxnResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandNewTxnResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandNewTxnResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandNewTxnResponse.message)
}
inline std::string* CommandNewTxnResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandNewTxnResponse.message)
  return _s;
}
inline const std::string& CommandNewTxnResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void CommandNewTxnResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* CommandNewTxnResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* CommandNewTxnResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandNewTxnResponse.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandNewTxnResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandNewTxnResponse.message)
}

// -------------------------------------------------------------------

// CommandAddPartitionToTxn

// required uint64 request_id = 1;
inline bool CommandAddPartitionToTxn::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandAddPartitionToTxn::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CommandAddPartitionToTxn::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxn.request_id)
  return _internal_request_id();
}
inline void CommandAddPartitionToTxn::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxn.request_id)
}
inline ::uint64_t CommandAddPartitionToTxn::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandAddPartitionToTxn::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.request_id_ = value;
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandAddPartitionToTxn::has_txnid_least_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandAddPartitionToTxn::clear_txnid_least_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_least_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandAddPartitionToTxn::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxn.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandAddPartitionToTxn::set_txnid_least_bits(::uint64_t value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxn.txnid_least_bits)
}
inline ::uint64_t CommandAddPartitionToTxn::_internal_txnid_least_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_least_bits_;
}
inline void CommandAddPartitionToTxn::_internal_set_txnid_least_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.txnid_least_bits_ = value;
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandAddPartitionToTxn::has_txnid_most_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandAddPartitionToTxn::clear_txnid_most_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_most_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandAddPartitionToTxn::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxn.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandAddPartitionToTxn::set_txnid_most_bits(::uint64_t value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxn.txnid_most_bits)
}
inline ::uint64_t CommandAddPartitionToTxn::_internal_txnid_most_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_most_bits_;
}
inline void CommandAddPartitionToTxn::_internal_set_txnid_most_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.txnid_most_bits_ = value;
}

// repeated string partitions = 4;
inline int CommandAddPartitionToTxn::_internal_partitions_size() const {
  return _internal_partitions().size();
}
inline int CommandAddPartitionToTxn::partitions_size() const {
  return _internal_partitions_size();
}
inline void CommandAddPartitionToTxn::clear_partitions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.partitions_.Clear();
}
inline std::string* CommandAddPartitionToTxn::add_partitions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_partitions()->Add();
  // @@protoc_insertion_point(field_add_mutable:pulsar.proto.CommandAddPartitionToTxn.partitions)
  return _s;
}
inline const std::string& CommandAddPartitionToTxn::partitions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxn.partitions)
  return _internal_partitions().Get(index);
}
inline std::string* CommandAddPartitionToTxn::mutable_partitions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAddPartitionToTxn.partitions)
  return _internal_mutable_partitions()->Mutable(index);
}
inline void CommandAddPartitionToTxn::set_partitions(int index, const std::string& value) {
  _internal_mutable_partitions()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline void CommandAddPartitionToTxn::set_partitions(int index, std::string&& value) {
  _internal_mutable_partitions()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline void CommandAddPartitionToTxn::set_partitions(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_partitions()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline void CommandAddPartitionToTxn::set_partitions(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_partitions()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline void CommandAddPartitionToTxn::set_partitions(int index, absl::string_view value) {
  _internal_mutable_partitions()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline void CommandAddPartitionToTxn::add_partitions(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_partitions()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline void CommandAddPartitionToTxn::add_partitions(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_partitions()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline void CommandAddPartitionToTxn::add_partitions(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_partitions()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline void CommandAddPartitionToTxn::add_partitions(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_partitions()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline void CommandAddPartitionToTxn::add_partitions(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_partitions()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:pulsar.proto.CommandAddPartitionToTxn.partitions)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CommandAddPartitionToTxn::partitions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandAddPartitionToTxn.partitions)
  return _internal_partitions();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CommandAddPartitionToTxn::mutable_partitions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandAddPartitionToTxn.partitions)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_partitions();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CommandAddPartitionToTxn::_internal_partitions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.partitions_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CommandAddPartitionToTxn::_internal_mutable_partitions() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.partitions_;
}

// -------------------------------------------------------------------

// CommandAddPartitionToTxnResponse

// required uint64 request_id = 1;
inline bool CommandAddPartitionToTxnResponse::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandAddPartitionToTxnResponse::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandAddPartitionToTxnResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxnResponse.request_id)
  return _internal_request_id();
}
inline void CommandAddPartitionToTxnResponse::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxnResponse.request_id)
}
inline ::uint64_t CommandAddPartitionToTxnResponse::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandAddPartitionToTxnResponse::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandAddPartitionToTxnResponse::has_txnid_least_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandAddPartitionToTxnResponse::clear_txnid_least_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_least_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandAddPartitionToTxnResponse::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxnResponse.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandAddPartitionToTxnResponse::set_txnid_least_bits(::uint64_t value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxnResponse.txnid_least_bits)
}
inline ::uint64_t CommandAddPartitionToTxnResponse::_internal_txnid_least_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_least_bits_;
}
inline void CommandAddPartitionToTxnResponse::_internal_set_txnid_least_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.txnid_least_bits_ = value;
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandAddPartitionToTxnResponse::has_txnid_most_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandAddPartitionToTxnResponse::clear_txnid_most_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_most_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandAddPartitionToTxnResponse::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxnResponse.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandAddPartitionToTxnResponse::set_txnid_most_bits(::uint64_t value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxnResponse.txnid_most_bits)
}
inline ::uint64_t CommandAddPartitionToTxnResponse::_internal_txnid_most_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_most_bits_;
}
inline void CommandAddPartitionToTxnResponse::_internal_set_txnid_most_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.txnid_most_bits_ = value;
}

// optional .pulsar.proto.ServerError error = 4;
inline bool CommandAddPartitionToTxnResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandAddPartitionToTxnResponse::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::ServerError CommandAddPartitionToTxnResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxnResponse.error)
  return _internal_error();
}
inline void CommandAddPartitionToTxnResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxnResponse.error)
}
inline ::pulsar::proto::ServerError CommandAddPartitionToTxnResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::ServerError>(_impl_.error_);
}
inline void CommandAddPartitionToTxnResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::ServerError_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.error_ = value;
}

// optional string message = 5;
inline bool CommandAddPartitionToTxnResponse::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandAddPartitionToTxnResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandAddPartitionToTxnResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddPartitionToTxnResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandAddPartitionToTxnResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddPartitionToTxnResponse.message)
}
inline std::string* CommandAddPartitionToTxnResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAddPartitionToTxnResponse.message)
  return _s;
}
inline const std::string& CommandAddPartitionToTxnResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void CommandAddPartitionToTxnResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* CommandAddPartitionToTxnResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* CommandAddPartitionToTxnResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandAddPartitionToTxnResponse.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandAddPartitionToTxnResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAddPartitionToTxnResponse.message)
}

// -------------------------------------------------------------------

// Subscription

// required string topic = 1;
inline bool Subscription::has_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Subscription::clear_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Subscription::topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.Subscription.topic)
  return _internal_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Subscription::set_topic(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.Subscription.topic)
}
inline std::string* Subscription::mutable_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.Subscription.topic)
  return _s;
}
inline const std::string& Subscription::_internal_topic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_.Get();
}
inline void Subscription::_internal_set_topic(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(value, GetArena());
}
inline std::string* Subscription::_internal_mutable_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.topic_.Mutable( GetArena());
}
inline std::string* Subscription::release_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.Subscription.topic)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.topic_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topic_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Subscription::set_allocated_topic(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.topic_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topic_.IsDefault()) {
          _impl_.topic_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.Subscription.topic)
}

// required string subscription = 2;
inline bool Subscription::has_subscription() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Subscription::clear_subscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subscription_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Subscription::subscription() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.Subscription.subscription)
  return _internal_subscription();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Subscription::set_subscription(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subscription_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.Subscription.subscription)
}
inline std::string* Subscription::mutable_subscription() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.Subscription.subscription)
  return _s;
}
inline const std::string& Subscription::_internal_subscription() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subscription_.Get();
}
inline void Subscription::_internal_set_subscription(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subscription_.Set(value, GetArena());
}
inline std::string* Subscription::_internal_mutable_subscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.subscription_.Mutable( GetArena());
}
inline std::string* Subscription::release_subscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.Subscription.subscription)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.subscription_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.subscription_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Subscription::set_allocated_subscription(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.subscription_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subscription_.IsDefault()) {
          _impl_.subscription_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.Subscription.subscription)
}

// -------------------------------------------------------------------

// CommandAddSubscriptionToTxn

// required uint64 request_id = 1;
inline bool CommandAddSubscriptionToTxn::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandAddSubscriptionToTxn::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CommandAddSubscriptionToTxn::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxn.request_id)
  return _internal_request_id();
}
inline void CommandAddSubscriptionToTxn::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddSubscriptionToTxn.request_id)
}
inline ::uint64_t CommandAddSubscriptionToTxn::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandAddSubscriptionToTxn::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.request_id_ = value;
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandAddSubscriptionToTxn::has_txnid_least_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandAddSubscriptionToTxn::clear_txnid_least_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_least_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandAddSubscriptionToTxn::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxn.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandAddSubscriptionToTxn::set_txnid_least_bits(::uint64_t value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddSubscriptionToTxn.txnid_least_bits)
}
inline ::uint64_t CommandAddSubscriptionToTxn::_internal_txnid_least_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_least_bits_;
}
inline void CommandAddSubscriptionToTxn::_internal_set_txnid_least_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.txnid_least_bits_ = value;
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandAddSubscriptionToTxn::has_txnid_most_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandAddSubscriptionToTxn::clear_txnid_most_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_most_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandAddSubscriptionToTxn::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxn.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandAddSubscriptionToTxn::set_txnid_most_bits(::uint64_t value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddSubscriptionToTxn.txnid_most_bits)
}
inline ::uint64_t CommandAddSubscriptionToTxn::_internal_txnid_most_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_most_bits_;
}
inline void CommandAddSubscriptionToTxn::_internal_set_txnid_most_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.txnid_most_bits_ = value;
}

// repeated .pulsar.proto.Subscription subscription = 4;
inline int CommandAddSubscriptionToTxn::_internal_subscription_size() const {
  return _internal_subscription().size();
}
inline int CommandAddSubscriptionToTxn::subscription_size() const {
  return _internal_subscription_size();
}
inline void CommandAddSubscriptionToTxn::clear_subscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subscription_.Clear();
}
inline ::pulsar::proto::Subscription* CommandAddSubscriptionToTxn::mutable_subscription(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAddSubscriptionToTxn.subscription)
  return _internal_mutable_subscription()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::Subscription>* CommandAddSubscriptionToTxn::mutable_subscription()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:pulsar.proto.CommandAddSubscriptionToTxn.subscription)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_subscription();
}
inline const ::pulsar::proto::Subscription& CommandAddSubscriptionToTxn::subscription(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxn.subscription)
  return _internal_subscription().Get(index);
}
inline ::pulsar::proto::Subscription* CommandAddSubscriptionToTxn::add_subscription() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pulsar::proto::Subscription* _add = _internal_mutable_subscription()->Add();
  // @@protoc_insertion_point(field_add:pulsar.proto.CommandAddSubscriptionToTxn.subscription)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::Subscription>& CommandAddSubscriptionToTxn::subscription() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:pulsar.proto.CommandAddSubscriptionToTxn.subscription)
  return _internal_subscription();
}
inline const ::google::protobuf::RepeatedPtrField<::pulsar::proto::Subscription>&
CommandAddSubscriptionToTxn::_internal_subscription() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subscription_;
}
inline ::google::protobuf::RepeatedPtrField<::pulsar::proto::Subscription>*
CommandAddSubscriptionToTxn::_internal_mutable_subscription() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.subscription_;
}

// -------------------------------------------------------------------

// CommandAddSubscriptionToTxnResponse

// required uint64 request_id = 1;
inline bool CommandAddSubscriptionToTxnResponse::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandAddSubscriptionToTxnResponse::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandAddSubscriptionToTxnResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxnResponse.request_id)
  return _internal_request_id();
}
inline void CommandAddSubscriptionToTxnResponse::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddSubscriptionToTxnResponse.request_id)
}
inline ::uint64_t CommandAddSubscriptionToTxnResponse::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandAddSubscriptionToTxnResponse::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandAddSubscriptionToTxnResponse::has_txnid_least_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandAddSubscriptionToTxnResponse::clear_txnid_least_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_least_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandAddSubscriptionToTxnResponse::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxnResponse.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandAddSubscriptionToTxnResponse::set_txnid_least_bits(::uint64_t value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddSubscriptionToTxnResponse.txnid_least_bits)
}
inline ::uint64_t CommandAddSubscriptionToTxnResponse::_internal_txnid_least_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_least_bits_;
}
inline void CommandAddSubscriptionToTxnResponse::_internal_set_txnid_least_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.txnid_least_bits_ = value;
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandAddSubscriptionToTxnResponse::has_txnid_most_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandAddSubscriptionToTxnResponse::clear_txnid_most_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_most_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandAddSubscriptionToTxnResponse::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxnResponse.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandAddSubscriptionToTxnResponse::set_txnid_most_bits(::uint64_t value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddSubscriptionToTxnResponse.txnid_most_bits)
}
inline ::uint64_t CommandAddSubscriptionToTxnResponse::_internal_txnid_most_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_most_bits_;
}
inline void CommandAddSubscriptionToTxnResponse::_internal_set_txnid_most_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.txnid_most_bits_ = value;
}

// optional .pulsar.proto.ServerError error = 4;
inline bool CommandAddSubscriptionToTxnResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandAddSubscriptionToTxnResponse::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::ServerError CommandAddSubscriptionToTxnResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxnResponse.error)
  return _internal_error();
}
inline void CommandAddSubscriptionToTxnResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddSubscriptionToTxnResponse.error)
}
inline ::pulsar::proto::ServerError CommandAddSubscriptionToTxnResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::ServerError>(_impl_.error_);
}
inline void CommandAddSubscriptionToTxnResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::ServerError_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.error_ = value;
}

// optional string message = 5;
inline bool CommandAddSubscriptionToTxnResponse::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandAddSubscriptionToTxnResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandAddSubscriptionToTxnResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandAddSubscriptionToTxnResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandAddSubscriptionToTxnResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandAddSubscriptionToTxnResponse.message)
}
inline std::string* CommandAddSubscriptionToTxnResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandAddSubscriptionToTxnResponse.message)
  return _s;
}
inline const std::string& CommandAddSubscriptionToTxnResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void CommandAddSubscriptionToTxnResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* CommandAddSubscriptionToTxnResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* CommandAddSubscriptionToTxnResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandAddSubscriptionToTxnResponse.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandAddSubscriptionToTxnResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandAddSubscriptionToTxnResponse.message)
}

// -------------------------------------------------------------------

// CommandEndTxn

// required uint64 request_id = 1;
inline bool CommandEndTxn::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandEndTxn::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CommandEndTxn::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxn.request_id)
  return _internal_request_id();
}
inline void CommandEndTxn::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxn.request_id)
}
inline ::uint64_t CommandEndTxn::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandEndTxn::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.request_id_ = value;
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandEndTxn::has_txnid_least_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandEndTxn::clear_txnid_least_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_least_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandEndTxn::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxn.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandEndTxn::set_txnid_least_bits(::uint64_t value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxn.txnid_least_bits)
}
inline ::uint64_t CommandEndTxn::_internal_txnid_least_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_least_bits_;
}
inline void CommandEndTxn::_internal_set_txnid_least_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.txnid_least_bits_ = value;
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandEndTxn::has_txnid_most_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandEndTxn::clear_txnid_most_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_most_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandEndTxn::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxn.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandEndTxn::set_txnid_most_bits(::uint64_t value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxn.txnid_most_bits)
}
inline ::uint64_t CommandEndTxn::_internal_txnid_most_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_most_bits_;
}
inline void CommandEndTxn::_internal_set_txnid_most_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.txnid_most_bits_ = value;
}

// optional .pulsar.proto.TxnAction txn_action = 4;
inline bool CommandEndTxn::has_txn_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandEndTxn::clear_txn_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txn_action_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::pulsar::proto::TxnAction CommandEndTxn::txn_action() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxn.txn_action)
  return _internal_txn_action();
}
inline void CommandEndTxn::set_txn_action(::pulsar::proto::TxnAction value) {
  _internal_set_txn_action(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxn.txn_action)
}
inline ::pulsar::proto::TxnAction CommandEndTxn::_internal_txn_action() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::TxnAction>(_impl_.txn_action_);
}
inline void CommandEndTxn::_internal_set_txn_action(::pulsar::proto::TxnAction value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::TxnAction_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.txn_action_ = value;
}

// -------------------------------------------------------------------

// CommandEndTxnResponse

// required uint64 request_id = 1;
inline bool CommandEndTxnResponse::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandEndTxnResponse::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandEndTxnResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnResponse.request_id)
  return _internal_request_id();
}
inline void CommandEndTxnResponse::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnResponse.request_id)
}
inline ::uint64_t CommandEndTxnResponse::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandEndTxnResponse::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandEndTxnResponse::has_txnid_least_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandEndTxnResponse::clear_txnid_least_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_least_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandEndTxnResponse::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnResponse.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandEndTxnResponse::set_txnid_least_bits(::uint64_t value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnResponse.txnid_least_bits)
}
inline ::uint64_t CommandEndTxnResponse::_internal_txnid_least_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_least_bits_;
}
inline void CommandEndTxnResponse::_internal_set_txnid_least_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.txnid_least_bits_ = value;
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandEndTxnResponse::has_txnid_most_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandEndTxnResponse::clear_txnid_most_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_most_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandEndTxnResponse::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnResponse.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandEndTxnResponse::set_txnid_most_bits(::uint64_t value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnResponse.txnid_most_bits)
}
inline ::uint64_t CommandEndTxnResponse::_internal_txnid_most_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_most_bits_;
}
inline void CommandEndTxnResponse::_internal_set_txnid_most_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.txnid_most_bits_ = value;
}

// optional .pulsar.proto.ServerError error = 4;
inline bool CommandEndTxnResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandEndTxnResponse::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::ServerError CommandEndTxnResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnResponse.error)
  return _internal_error();
}
inline void CommandEndTxnResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnResponse.error)
}
inline ::pulsar::proto::ServerError CommandEndTxnResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::ServerError>(_impl_.error_);
}
inline void CommandEndTxnResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::ServerError_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.error_ = value;
}

// optional string message = 5;
inline bool CommandEndTxnResponse::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandEndTxnResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandEndTxnResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandEndTxnResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnResponse.message)
}
inline std::string* CommandEndTxnResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandEndTxnResponse.message)
  return _s;
}
inline const std::string& CommandEndTxnResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void CommandEndTxnResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* CommandEndTxnResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* CommandEndTxnResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandEndTxnResponse.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandEndTxnResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandEndTxnResponse.message)
}

// -------------------------------------------------------------------

// CommandEndTxnOnPartition

// required uint64 request_id = 1;
inline bool CommandEndTxnOnPartition::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandEndTxnOnPartition::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandEndTxnOnPartition::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartition.request_id)
  return _internal_request_id();
}
inline void CommandEndTxnOnPartition::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartition.request_id)
}
inline ::uint64_t CommandEndTxnOnPartition::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandEndTxnOnPartition::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandEndTxnOnPartition::has_txnid_least_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandEndTxnOnPartition::clear_txnid_least_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_least_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandEndTxnOnPartition::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartition.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandEndTxnOnPartition::set_txnid_least_bits(::uint64_t value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartition.txnid_least_bits)
}
inline ::uint64_t CommandEndTxnOnPartition::_internal_txnid_least_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_least_bits_;
}
inline void CommandEndTxnOnPartition::_internal_set_txnid_least_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.txnid_least_bits_ = value;
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandEndTxnOnPartition::has_txnid_most_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandEndTxnOnPartition::clear_txnid_most_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_most_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandEndTxnOnPartition::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartition.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandEndTxnOnPartition::set_txnid_most_bits(::uint64_t value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartition.txnid_most_bits)
}
inline ::uint64_t CommandEndTxnOnPartition::_internal_txnid_most_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_most_bits_;
}
inline void CommandEndTxnOnPartition::_internal_set_txnid_most_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.txnid_most_bits_ = value;
}

// optional string topic = 4;
inline bool CommandEndTxnOnPartition::has_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandEndTxnOnPartition::clear_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandEndTxnOnPartition::topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartition.topic)
  return _internal_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandEndTxnOnPartition::set_topic(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartition.topic)
}
inline std::string* CommandEndTxnOnPartition::mutable_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandEndTxnOnPartition.topic)
  return _s;
}
inline const std::string& CommandEndTxnOnPartition::_internal_topic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topic_.Get();
}
inline void CommandEndTxnOnPartition::_internal_set_topic(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(value, GetArena());
}
inline std::string* CommandEndTxnOnPartition::_internal_mutable_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.topic_.Mutable( GetArena());
}
inline std::string* CommandEndTxnOnPartition::release_topic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandEndTxnOnPartition.topic)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.topic_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topic_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandEndTxnOnPartition::set_allocated_topic(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.topic_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.topic_.IsDefault()) {
          _impl_.topic_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandEndTxnOnPartition.topic)
}

// optional .pulsar.proto.TxnAction txn_action = 5;
inline bool CommandEndTxnOnPartition::has_txn_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CommandEndTxnOnPartition::clear_txn_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txn_action_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::pulsar::proto::TxnAction CommandEndTxnOnPartition::txn_action() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartition.txn_action)
  return _internal_txn_action();
}
inline void CommandEndTxnOnPartition::set_txn_action(::pulsar::proto::TxnAction value) {
  _internal_set_txn_action(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartition.txn_action)
}
inline ::pulsar::proto::TxnAction CommandEndTxnOnPartition::_internal_txn_action() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::TxnAction>(_impl_.txn_action_);
}
inline void CommandEndTxnOnPartition::_internal_set_txn_action(::pulsar::proto::TxnAction value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::TxnAction_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.txn_action_ = value;
}

// optional uint64 txnid_least_bits_of_low_watermark = 6;
inline bool CommandEndTxnOnPartition::has_txnid_least_bits_of_low_watermark() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandEndTxnOnPartition::clear_txnid_least_bits_of_low_watermark() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_least_bits_of_low_watermark_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t CommandEndTxnOnPartition::txnid_least_bits_of_low_watermark() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartition.txnid_least_bits_of_low_watermark)
  return _internal_txnid_least_bits_of_low_watermark();
}
inline void CommandEndTxnOnPartition::set_txnid_least_bits_of_low_watermark(::uint64_t value) {
  _internal_set_txnid_least_bits_of_low_watermark(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartition.txnid_least_bits_of_low_watermark)
}
inline ::uint64_t CommandEndTxnOnPartition::_internal_txnid_least_bits_of_low_watermark() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_least_bits_of_low_watermark_;
}
inline void CommandEndTxnOnPartition::_internal_set_txnid_least_bits_of_low_watermark(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.txnid_least_bits_of_low_watermark_ = value;
}

// -------------------------------------------------------------------

// CommandEndTxnOnPartitionResponse

// required uint64 request_id = 1;
inline bool CommandEndTxnOnPartitionResponse::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandEndTxnOnPartitionResponse::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandEndTxnOnPartitionResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartitionResponse.request_id)
  return _internal_request_id();
}
inline void CommandEndTxnOnPartitionResponse::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartitionResponse.request_id)
}
inline ::uint64_t CommandEndTxnOnPartitionResponse::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandEndTxnOnPartitionResponse::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandEndTxnOnPartitionResponse::has_txnid_least_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandEndTxnOnPartitionResponse::clear_txnid_least_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_least_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandEndTxnOnPartitionResponse::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartitionResponse.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandEndTxnOnPartitionResponse::set_txnid_least_bits(::uint64_t value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartitionResponse.txnid_least_bits)
}
inline ::uint64_t CommandEndTxnOnPartitionResponse::_internal_txnid_least_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_least_bits_;
}
inline void CommandEndTxnOnPartitionResponse::_internal_set_txnid_least_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.txnid_least_bits_ = value;
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandEndTxnOnPartitionResponse::has_txnid_most_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandEndTxnOnPartitionResponse::clear_txnid_most_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_most_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandEndTxnOnPartitionResponse::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartitionResponse.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandEndTxnOnPartitionResponse::set_txnid_most_bits(::uint64_t value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartitionResponse.txnid_most_bits)
}
inline ::uint64_t CommandEndTxnOnPartitionResponse::_internal_txnid_most_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_most_bits_;
}
inline void CommandEndTxnOnPartitionResponse::_internal_set_txnid_most_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.txnid_most_bits_ = value;
}

// optional .pulsar.proto.ServerError error = 4;
inline bool CommandEndTxnOnPartitionResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandEndTxnOnPartitionResponse::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::ServerError CommandEndTxnOnPartitionResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartitionResponse.error)
  return _internal_error();
}
inline void CommandEndTxnOnPartitionResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartitionResponse.error)
}
inline ::pulsar::proto::ServerError CommandEndTxnOnPartitionResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::ServerError>(_impl_.error_);
}
inline void CommandEndTxnOnPartitionResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::ServerError_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.error_ = value;
}

// optional string message = 5;
inline bool CommandEndTxnOnPartitionResponse::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandEndTxnOnPartitionResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandEndTxnOnPartitionResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnPartitionResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandEndTxnOnPartitionResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnPartitionResponse.message)
}
inline std::string* CommandEndTxnOnPartitionResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandEndTxnOnPartitionResponse.message)
  return _s;
}
inline const std::string& CommandEndTxnOnPartitionResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void CommandEndTxnOnPartitionResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* CommandEndTxnOnPartitionResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* CommandEndTxnOnPartitionResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandEndTxnOnPartitionResponse.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandEndTxnOnPartitionResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandEndTxnOnPartitionResponse.message)
}

// -------------------------------------------------------------------

// CommandEndTxnOnSubscription

// required uint64 request_id = 1;
inline bool CommandEndTxnOnSubscription::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandEndTxnOnSubscription::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandEndTxnOnSubscription::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscription.request_id)
  return _internal_request_id();
}
inline void CommandEndTxnOnSubscription::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscription.request_id)
}
inline ::uint64_t CommandEndTxnOnSubscription::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandEndTxnOnSubscription::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandEndTxnOnSubscription::has_txnid_least_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandEndTxnOnSubscription::clear_txnid_least_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_least_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandEndTxnOnSubscription::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscription.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandEndTxnOnSubscription::set_txnid_least_bits(::uint64_t value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscription.txnid_least_bits)
}
inline ::uint64_t CommandEndTxnOnSubscription::_internal_txnid_least_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_least_bits_;
}
inline void CommandEndTxnOnSubscription::_internal_set_txnid_least_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.txnid_least_bits_ = value;
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandEndTxnOnSubscription::has_txnid_most_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandEndTxnOnSubscription::clear_txnid_most_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_most_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandEndTxnOnSubscription::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscription.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandEndTxnOnSubscription::set_txnid_most_bits(::uint64_t value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscription.txnid_most_bits)
}
inline ::uint64_t CommandEndTxnOnSubscription::_internal_txnid_most_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_most_bits_;
}
inline void CommandEndTxnOnSubscription::_internal_set_txnid_most_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.txnid_most_bits_ = value;
}

// optional .pulsar.proto.Subscription subscription = 4;
inline bool CommandEndTxnOnSubscription::has_subscription() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.subscription_ != nullptr);
  return value;
}
inline void CommandEndTxnOnSubscription::clear_subscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.subscription_ != nullptr) _impl_.subscription_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::Subscription& CommandEndTxnOnSubscription::_internal_subscription() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::Subscription* p = _impl_.subscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::Subscription&>(::pulsar::proto::_Subscription_default_instance_);
}
inline const ::pulsar::proto::Subscription& CommandEndTxnOnSubscription::subscription() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscription.subscription)
  return _internal_subscription();
}
inline void CommandEndTxnOnSubscription::unsafe_arena_set_allocated_subscription(::pulsar::proto::Subscription* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.subscription_);
  }
  _impl_.subscription_ = reinterpret_cast<::pulsar::proto::Subscription*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.CommandEndTxnOnSubscription.subscription)
}
inline ::pulsar::proto::Subscription* CommandEndTxnOnSubscription::release_subscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::Subscription* released = _impl_.subscription_;
  _impl_.subscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::Subscription* CommandEndTxnOnSubscription::unsafe_arena_release_subscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandEndTxnOnSubscription.subscription)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::Subscription* temp = _impl_.subscription_;
  _impl_.subscription_ = nullptr;
  return temp;
}
inline ::pulsar::proto::Subscription* CommandEndTxnOnSubscription::_internal_mutable_subscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.subscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::Subscription>(GetArena());
    _impl_.subscription_ = reinterpret_cast<::pulsar::proto::Subscription*>(p);
  }
  return _impl_.subscription_;
}
inline ::pulsar::proto::Subscription* CommandEndTxnOnSubscription::mutable_subscription() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::Subscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandEndTxnOnSubscription.subscription)
  return _msg;
}
inline void CommandEndTxnOnSubscription::set_allocated_subscription(::pulsar::proto::Subscription* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::Subscription*>(_impl_.subscription_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::Subscription*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.subscription_ = reinterpret_cast<::pulsar::proto::Subscription*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandEndTxnOnSubscription.subscription)
}

// optional .pulsar.proto.TxnAction txn_action = 5;
inline bool CommandEndTxnOnSubscription::has_txn_action() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CommandEndTxnOnSubscription::clear_txn_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txn_action_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::pulsar::proto::TxnAction CommandEndTxnOnSubscription::txn_action() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscription.txn_action)
  return _internal_txn_action();
}
inline void CommandEndTxnOnSubscription::set_txn_action(::pulsar::proto::TxnAction value) {
  _internal_set_txn_action(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscription.txn_action)
}
inline ::pulsar::proto::TxnAction CommandEndTxnOnSubscription::_internal_txn_action() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::TxnAction>(_impl_.txn_action_);
}
inline void CommandEndTxnOnSubscription::_internal_set_txn_action(::pulsar::proto::TxnAction value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::TxnAction_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.txn_action_ = value;
}

// optional uint64 txnid_least_bits_of_low_watermark = 6;
inline bool CommandEndTxnOnSubscription::has_txnid_least_bits_of_low_watermark() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandEndTxnOnSubscription::clear_txnid_least_bits_of_low_watermark() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_least_bits_of_low_watermark_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t CommandEndTxnOnSubscription::txnid_least_bits_of_low_watermark() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscription.txnid_least_bits_of_low_watermark)
  return _internal_txnid_least_bits_of_low_watermark();
}
inline void CommandEndTxnOnSubscription::set_txnid_least_bits_of_low_watermark(::uint64_t value) {
  _internal_set_txnid_least_bits_of_low_watermark(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscription.txnid_least_bits_of_low_watermark)
}
inline ::uint64_t CommandEndTxnOnSubscription::_internal_txnid_least_bits_of_low_watermark() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_least_bits_of_low_watermark_;
}
inline void CommandEndTxnOnSubscription::_internal_set_txnid_least_bits_of_low_watermark(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.txnid_least_bits_of_low_watermark_ = value;
}

// -------------------------------------------------------------------

// CommandEndTxnOnSubscriptionResponse

// required uint64 request_id = 1;
inline bool CommandEndTxnOnSubscriptionResponse::has_request_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandEndTxnOnSubscriptionResponse::clear_request_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CommandEndTxnOnSubscriptionResponse::request_id() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscriptionResponse.request_id)
  return _internal_request_id();
}
inline void CommandEndTxnOnSubscriptionResponse::set_request_id(::uint64_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscriptionResponse.request_id)
}
inline ::uint64_t CommandEndTxnOnSubscriptionResponse::_internal_request_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.request_id_;
}
inline void CommandEndTxnOnSubscriptionResponse::_internal_set_request_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.request_id_ = value;
}

// optional uint64 txnid_least_bits = 2 [default = 0];
inline bool CommandEndTxnOnSubscriptionResponse::has_txnid_least_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandEndTxnOnSubscriptionResponse::clear_txnid_least_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_least_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CommandEndTxnOnSubscriptionResponse::txnid_least_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscriptionResponse.txnid_least_bits)
  return _internal_txnid_least_bits();
}
inline void CommandEndTxnOnSubscriptionResponse::set_txnid_least_bits(::uint64_t value) {
  _internal_set_txnid_least_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscriptionResponse.txnid_least_bits)
}
inline ::uint64_t CommandEndTxnOnSubscriptionResponse::_internal_txnid_least_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_least_bits_;
}
inline void CommandEndTxnOnSubscriptionResponse::_internal_set_txnid_least_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.txnid_least_bits_ = value;
}

// optional uint64 txnid_most_bits = 3 [default = 0];
inline bool CommandEndTxnOnSubscriptionResponse::has_txnid_most_bits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandEndTxnOnSubscriptionResponse::clear_txnid_most_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.txnid_most_bits_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CommandEndTxnOnSubscriptionResponse::txnid_most_bits() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscriptionResponse.txnid_most_bits)
  return _internal_txnid_most_bits();
}
inline void CommandEndTxnOnSubscriptionResponse::set_txnid_most_bits(::uint64_t value) {
  _internal_set_txnid_most_bits(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscriptionResponse.txnid_most_bits)
}
inline ::uint64_t CommandEndTxnOnSubscriptionResponse::_internal_txnid_most_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.txnid_most_bits_;
}
inline void CommandEndTxnOnSubscriptionResponse::_internal_set_txnid_most_bits(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.txnid_most_bits_ = value;
}

// optional .pulsar.proto.ServerError error = 4;
inline bool CommandEndTxnOnSubscriptionResponse::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandEndTxnOnSubscriptionResponse::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::pulsar::proto::ServerError CommandEndTxnOnSubscriptionResponse::error() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscriptionResponse.error)
  return _internal_error();
}
inline void CommandEndTxnOnSubscriptionResponse::set_error(::pulsar::proto::ServerError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscriptionResponse.error)
}
inline ::pulsar::proto::ServerError CommandEndTxnOnSubscriptionResponse::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::ServerError>(_impl_.error_);
}
inline void CommandEndTxnOnSubscriptionResponse::_internal_set_error(::pulsar::proto::ServerError value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::ServerError_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.error_ = value;
}

// optional string message = 5;
inline bool CommandEndTxnOnSubscriptionResponse::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandEndTxnOnSubscriptionResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandEndTxnOnSubscriptionResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.CommandEndTxnOnSubscriptionResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CommandEndTxnOnSubscriptionResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:pulsar.proto.CommandEndTxnOnSubscriptionResponse.message)
}
inline std::string* CommandEndTxnOnSubscriptionResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.CommandEndTxnOnSubscriptionResponse.message)
  return _s;
}
inline const std::string& CommandEndTxnOnSubscriptionResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void CommandEndTxnOnSubscriptionResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* CommandEndTxnOnSubscriptionResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* CommandEndTxnOnSubscriptionResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.CommandEndTxnOnSubscriptionResponse.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CommandEndTxnOnSubscriptionResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.CommandEndTxnOnSubscriptionResponse.message)
}

// -------------------------------------------------------------------

// BaseCommand

// required .pulsar.proto.BaseCommand.Type type = 1;
inline bool BaseCommand::has_type() const {
  bool value = (_impl_._has_bits_[1] & 0x04000000u) != 0;
  return value;
}
inline void BaseCommand::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 2;
  _impl_._has_bits_[1] &= ~0x04000000u;
}
inline ::pulsar::proto::BaseCommand_Type BaseCommand::type() const {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.type)
  return _internal_type();
}
inline void BaseCommand::set_type(::pulsar::proto::BaseCommand_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pulsar.proto.BaseCommand.type)
}
inline ::pulsar::proto::BaseCommand_Type BaseCommand::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::pulsar::proto::BaseCommand_Type>(_impl_.type_);
}
inline void BaseCommand::_internal_set_type(::pulsar::proto::BaseCommand_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::pulsar::proto::BaseCommand_Type_IsValid(value));
  _impl_._has_bits_[1] |= 0x04000000u;
  _impl_.type_ = value;
}

// optional .pulsar.proto.CommandConnect connect = 2;
inline bool BaseCommand::has_connect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.connect_ != nullptr);
  return value;
}
inline void BaseCommand::clear_connect() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.connect_ != nullptr) _impl_.connect_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pulsar::proto::CommandConnect& BaseCommand::_internal_connect() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandConnect* p = _impl_.connect_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandConnect&>(::pulsar::proto::_CommandConnect_default_instance_);
}
inline const ::pulsar::proto::CommandConnect& BaseCommand::connect() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.connect)
  return _internal_connect();
}
inline void BaseCommand::unsafe_arena_set_allocated_connect(::pulsar::proto::CommandConnect* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.connect_);
  }
  _impl_.connect_ = reinterpret_cast<::pulsar::proto::CommandConnect*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.connect)
}
inline ::pulsar::proto::CommandConnect* BaseCommand::release_connect() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::CommandConnect* released = _impl_.connect_;
  _impl_.connect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandConnect* BaseCommand::unsafe_arena_release_connect() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.connect)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pulsar::proto::CommandConnect* temp = _impl_.connect_;
  _impl_.connect_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandConnect* BaseCommand::_internal_mutable_connect() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.connect_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandConnect>(GetArena());
    _impl_.connect_ = reinterpret_cast<::pulsar::proto::CommandConnect*>(p);
  }
  return _impl_.connect_;
}
inline ::pulsar::proto::CommandConnect* BaseCommand::mutable_connect() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandConnect* _msg = _internal_mutable_connect();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.connect)
  return _msg;
}
inline void BaseCommand::set_allocated_connect(::pulsar::proto::CommandConnect* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandConnect*>(_impl_.connect_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandConnect*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.connect_ = reinterpret_cast<::pulsar::proto::CommandConnect*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.connect)
}

// optional .pulsar.proto.CommandConnected connected = 3;
inline bool BaseCommand::has_connected() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.connected_ != nullptr);
  return value;
}
inline void BaseCommand::clear_connected() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.connected_ != nullptr) _impl_.connected_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::pulsar::proto::CommandConnected& BaseCommand::_internal_connected() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandConnected* p = _impl_.connected_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandConnected&>(::pulsar::proto::_CommandConnected_default_instance_);
}
inline const ::pulsar::proto::CommandConnected& BaseCommand::connected() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.connected)
  return _internal_connected();
}
inline void BaseCommand::unsafe_arena_set_allocated_connected(::pulsar::proto::CommandConnected* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.connected_);
  }
  _impl_.connected_ = reinterpret_cast<::pulsar::proto::CommandConnected*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.connected)
}
inline ::pulsar::proto::CommandConnected* BaseCommand::release_connected() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::CommandConnected* released = _impl_.connected_;
  _impl_.connected_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandConnected* BaseCommand::unsafe_arena_release_connected() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.connected)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pulsar::proto::CommandConnected* temp = _impl_.connected_;
  _impl_.connected_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandConnected* BaseCommand::_internal_mutable_connected() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.connected_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandConnected>(GetArena());
    _impl_.connected_ = reinterpret_cast<::pulsar::proto::CommandConnected*>(p);
  }
  return _impl_.connected_;
}
inline ::pulsar::proto::CommandConnected* BaseCommand::mutable_connected() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandConnected* _msg = _internal_mutable_connected();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.connected)
  return _msg;
}
inline void BaseCommand::set_allocated_connected(::pulsar::proto::CommandConnected* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandConnected*>(_impl_.connected_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandConnected*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.connected_ = reinterpret_cast<::pulsar::proto::CommandConnected*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.connected)
}

// optional .pulsar.proto.CommandSubscribe subscribe = 4;
inline bool BaseCommand::has_subscribe() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.subscribe_ != nullptr);
  return value;
}
inline void BaseCommand::clear_subscribe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.subscribe_ != nullptr) _impl_.subscribe_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::pulsar::proto::CommandSubscribe& BaseCommand::_internal_subscribe() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandSubscribe* p = _impl_.subscribe_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandSubscribe&>(::pulsar::proto::_CommandSubscribe_default_instance_);
}
inline const ::pulsar::proto::CommandSubscribe& BaseCommand::subscribe() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.subscribe)
  return _internal_subscribe();
}
inline void BaseCommand::unsafe_arena_set_allocated_subscribe(::pulsar::proto::CommandSubscribe* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.subscribe_);
  }
  _impl_.subscribe_ = reinterpret_cast<::pulsar::proto::CommandSubscribe*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.subscribe)
}
inline ::pulsar::proto::CommandSubscribe* BaseCommand::release_subscribe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::pulsar::proto::CommandSubscribe* released = _impl_.subscribe_;
  _impl_.subscribe_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandSubscribe* BaseCommand::unsafe_arena_release_subscribe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.subscribe)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::pulsar::proto::CommandSubscribe* temp = _impl_.subscribe_;
  _impl_.subscribe_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandSubscribe* BaseCommand::_internal_mutable_subscribe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.subscribe_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandSubscribe>(GetArena());
    _impl_.subscribe_ = reinterpret_cast<::pulsar::proto::CommandSubscribe*>(p);
  }
  return _impl_.subscribe_;
}
inline ::pulsar::proto::CommandSubscribe* BaseCommand::mutable_subscribe() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandSubscribe* _msg = _internal_mutable_subscribe();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.subscribe)
  return _msg;
}
inline void BaseCommand::set_allocated_subscribe(::pulsar::proto::CommandSubscribe* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandSubscribe*>(_impl_.subscribe_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandSubscribe*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.subscribe_ = reinterpret_cast<::pulsar::proto::CommandSubscribe*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.subscribe)
}

// optional .pulsar.proto.CommandProducer producer = 5;
inline bool BaseCommand::has_producer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.producer_ != nullptr);
  return value;
}
inline void BaseCommand::clear_producer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.producer_ != nullptr) _impl_.producer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::pulsar::proto::CommandProducer& BaseCommand::_internal_producer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandProducer* p = _impl_.producer_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandProducer&>(::pulsar::proto::_CommandProducer_default_instance_);
}
inline const ::pulsar::proto::CommandProducer& BaseCommand::producer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.producer)
  return _internal_producer();
}
inline void BaseCommand::unsafe_arena_set_allocated_producer(::pulsar::proto::CommandProducer* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.producer_);
  }
  _impl_.producer_ = reinterpret_cast<::pulsar::proto::CommandProducer*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.producer)
}
inline ::pulsar::proto::CommandProducer* BaseCommand::release_producer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::pulsar::proto::CommandProducer* released = _impl_.producer_;
  _impl_.producer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandProducer* BaseCommand::unsafe_arena_release_producer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.producer)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::pulsar::proto::CommandProducer* temp = _impl_.producer_;
  _impl_.producer_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandProducer* BaseCommand::_internal_mutable_producer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.producer_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandProducer>(GetArena());
    _impl_.producer_ = reinterpret_cast<::pulsar::proto::CommandProducer*>(p);
  }
  return _impl_.producer_;
}
inline ::pulsar::proto::CommandProducer* BaseCommand::mutable_producer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandProducer* _msg = _internal_mutable_producer();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.producer)
  return _msg;
}
inline void BaseCommand::set_allocated_producer(::pulsar::proto::CommandProducer* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandProducer*>(_impl_.producer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandProducer*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.producer_ = reinterpret_cast<::pulsar::proto::CommandProducer*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.producer)
}

// optional .pulsar.proto.CommandSend send = 6;
inline bool BaseCommand::has_send() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.send_ != nullptr);
  return value;
}
inline void BaseCommand::clear_send() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.send_ != nullptr) _impl_.send_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::pulsar::proto::CommandSend& BaseCommand::_internal_send() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandSend* p = _impl_.send_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandSend&>(::pulsar::proto::_CommandSend_default_instance_);
}
inline const ::pulsar::proto::CommandSend& BaseCommand::send() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.send)
  return _internal_send();
}
inline void BaseCommand::unsafe_arena_set_allocated_send(::pulsar::proto::CommandSend* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.send_);
  }
  _impl_.send_ = reinterpret_cast<::pulsar::proto::CommandSend*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.send)
}
inline ::pulsar::proto::CommandSend* BaseCommand::release_send() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::pulsar::proto::CommandSend* released = _impl_.send_;
  _impl_.send_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandSend* BaseCommand::unsafe_arena_release_send() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.send)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::pulsar::proto::CommandSend* temp = _impl_.send_;
  _impl_.send_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandSend* BaseCommand::_internal_mutable_send() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.send_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandSend>(GetArena());
    _impl_.send_ = reinterpret_cast<::pulsar::proto::CommandSend*>(p);
  }
  return _impl_.send_;
}
inline ::pulsar::proto::CommandSend* BaseCommand::mutable_send() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandSend* _msg = _internal_mutable_send();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.send)
  return _msg;
}
inline void BaseCommand::set_allocated_send(::pulsar::proto::CommandSend* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandSend*>(_impl_.send_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandSend*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.send_ = reinterpret_cast<::pulsar::proto::CommandSend*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.send)
}

// optional .pulsar.proto.CommandSendReceipt send_receipt = 7;
inline bool BaseCommand::has_send_receipt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.send_receipt_ != nullptr);
  return value;
}
inline void BaseCommand::clear_send_receipt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.send_receipt_ != nullptr) _impl_.send_receipt_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::pulsar::proto::CommandSendReceipt& BaseCommand::_internal_send_receipt() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandSendReceipt* p = _impl_.send_receipt_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandSendReceipt&>(::pulsar::proto::_CommandSendReceipt_default_instance_);
}
inline const ::pulsar::proto::CommandSendReceipt& BaseCommand::send_receipt() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.send_receipt)
  return _internal_send_receipt();
}
inline void BaseCommand::unsafe_arena_set_allocated_send_receipt(::pulsar::proto::CommandSendReceipt* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.send_receipt_);
  }
  _impl_.send_receipt_ = reinterpret_cast<::pulsar::proto::CommandSendReceipt*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.send_receipt)
}
inline ::pulsar::proto::CommandSendReceipt* BaseCommand::release_send_receipt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::pulsar::proto::CommandSendReceipt* released = _impl_.send_receipt_;
  _impl_.send_receipt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandSendReceipt* BaseCommand::unsafe_arena_release_send_receipt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.send_receipt)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::pulsar::proto::CommandSendReceipt* temp = _impl_.send_receipt_;
  _impl_.send_receipt_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandSendReceipt* BaseCommand::_internal_mutable_send_receipt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.send_receipt_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandSendReceipt>(GetArena());
    _impl_.send_receipt_ = reinterpret_cast<::pulsar::proto::CommandSendReceipt*>(p);
  }
  return _impl_.send_receipt_;
}
inline ::pulsar::proto::CommandSendReceipt* BaseCommand::mutable_send_receipt() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandSendReceipt* _msg = _internal_mutable_send_receipt();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.send_receipt)
  return _msg;
}
inline void BaseCommand::set_allocated_send_receipt(::pulsar::proto::CommandSendReceipt* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandSendReceipt*>(_impl_.send_receipt_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandSendReceipt*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.send_receipt_ = reinterpret_cast<::pulsar::proto::CommandSendReceipt*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.send_receipt)
}

// optional .pulsar.proto.CommandSendError send_error = 8;
inline bool BaseCommand::has_send_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.send_error_ != nullptr);
  return value;
}
inline void BaseCommand::clear_send_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.send_error_ != nullptr) _impl_.send_error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::pulsar::proto::CommandSendError& BaseCommand::_internal_send_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandSendError* p = _impl_.send_error_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandSendError&>(::pulsar::proto::_CommandSendError_default_instance_);
}
inline const ::pulsar::proto::CommandSendError& BaseCommand::send_error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.send_error)
  return _internal_send_error();
}
inline void BaseCommand::unsafe_arena_set_allocated_send_error(::pulsar::proto::CommandSendError* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.send_error_);
  }
  _impl_.send_error_ = reinterpret_cast<::pulsar::proto::CommandSendError*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.send_error)
}
inline ::pulsar::proto::CommandSendError* BaseCommand::release_send_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::pulsar::proto::CommandSendError* released = _impl_.send_error_;
  _impl_.send_error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandSendError* BaseCommand::unsafe_arena_release_send_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.send_error)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::pulsar::proto::CommandSendError* temp = _impl_.send_error_;
  _impl_.send_error_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandSendError* BaseCommand::_internal_mutable_send_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.send_error_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandSendError>(GetArena());
    _impl_.send_error_ = reinterpret_cast<::pulsar::proto::CommandSendError*>(p);
  }
  return _impl_.send_error_;
}
inline ::pulsar::proto::CommandSendError* BaseCommand::mutable_send_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandSendError* _msg = _internal_mutable_send_error();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.send_error)
  return _msg;
}
inline void BaseCommand::set_allocated_send_error(::pulsar::proto::CommandSendError* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandSendError*>(_impl_.send_error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandSendError*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.send_error_ = reinterpret_cast<::pulsar::proto::CommandSendError*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.send_error)
}

// optional .pulsar.proto.CommandMessage message = 9;
inline bool BaseCommand::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.message_ != nullptr);
  return value;
}
inline void BaseCommand::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.message_ != nullptr) _impl_.message_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::pulsar::proto::CommandMessage& BaseCommand::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandMessage* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandMessage&>(::pulsar::proto::_CommandMessage_default_instance_);
}
inline const ::pulsar::proto::CommandMessage& BaseCommand::message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.message)
  return _internal_message();
}
inline void BaseCommand::unsafe_arena_set_allocated_message(::pulsar::proto::CommandMessage* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = reinterpret_cast<::pulsar::proto::CommandMessage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.message)
}
inline ::pulsar::proto::CommandMessage* BaseCommand::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::pulsar::proto::CommandMessage* released = _impl_.message_;
  _impl_.message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandMessage* BaseCommand::unsafe_arena_release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.message)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::pulsar::proto::CommandMessage* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandMessage* BaseCommand::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.message_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandMessage>(GetArena());
    _impl_.message_ = reinterpret_cast<::pulsar::proto::CommandMessage*>(p);
  }
  return _impl_.message_;
}
inline ::pulsar::proto::CommandMessage* BaseCommand::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandMessage* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.message)
  return _msg;
}
inline void BaseCommand::set_allocated_message(::pulsar::proto::CommandMessage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandMessage*>(_impl_.message_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandMessage*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.message_ = reinterpret_cast<::pulsar::proto::CommandMessage*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.message)
}

// optional .pulsar.proto.CommandAck ack = 10;
inline bool BaseCommand::has_ack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ack_ != nullptr);
  return value;
}
inline void BaseCommand::clear_ack() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ack_ != nullptr) _impl_.ack_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::pulsar::proto::CommandAck& BaseCommand::_internal_ack() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandAck* p = _impl_.ack_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandAck&>(::pulsar::proto::_CommandAck_default_instance_);
}
inline const ::pulsar::proto::CommandAck& BaseCommand::ack() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.ack)
  return _internal_ack();
}
inline void BaseCommand::unsafe_arena_set_allocated_ack(::pulsar::proto::CommandAck* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ack_);
  }
  _impl_.ack_ = reinterpret_cast<::pulsar::proto::CommandAck*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.ack)
}
inline ::pulsar::proto::CommandAck* BaseCommand::release_ack() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::pulsar::proto::CommandAck* released = _impl_.ack_;
  _impl_.ack_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandAck* BaseCommand::unsafe_arena_release_ack() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.ack)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::pulsar::proto::CommandAck* temp = _impl_.ack_;
  _impl_.ack_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandAck* BaseCommand::_internal_mutable_ack() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.ack_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandAck>(GetArena());
    _impl_.ack_ = reinterpret_cast<::pulsar::proto::CommandAck*>(p);
  }
  return _impl_.ack_;
}
inline ::pulsar::proto::CommandAck* BaseCommand::mutable_ack() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandAck* _msg = _internal_mutable_ack();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.ack)
  return _msg;
}
inline void BaseCommand::set_allocated_ack(::pulsar::proto::CommandAck* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandAck*>(_impl_.ack_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandAck*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.ack_ = reinterpret_cast<::pulsar::proto::CommandAck*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.ack)
}

// optional .pulsar.proto.CommandFlow flow = 11;
inline bool BaseCommand::has_flow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.flow_ != nullptr);
  return value;
}
inline void BaseCommand::clear_flow() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.flow_ != nullptr) _impl_.flow_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::pulsar::proto::CommandFlow& BaseCommand::_internal_flow() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandFlow* p = _impl_.flow_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandFlow&>(::pulsar::proto::_CommandFlow_default_instance_);
}
inline const ::pulsar::proto::CommandFlow& BaseCommand::flow() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.flow)
  return _internal_flow();
}
inline void BaseCommand::unsafe_arena_set_allocated_flow(::pulsar::proto::CommandFlow* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.flow_);
  }
  _impl_.flow_ = reinterpret_cast<::pulsar::proto::CommandFlow*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.flow)
}
inline ::pulsar::proto::CommandFlow* BaseCommand::release_flow() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::pulsar::proto::CommandFlow* released = _impl_.flow_;
  _impl_.flow_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandFlow* BaseCommand::unsafe_arena_release_flow() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.flow)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::pulsar::proto::CommandFlow* temp = _impl_.flow_;
  _impl_.flow_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandFlow* BaseCommand::_internal_mutable_flow() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.flow_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandFlow>(GetArena());
    _impl_.flow_ = reinterpret_cast<::pulsar::proto::CommandFlow*>(p);
  }
  return _impl_.flow_;
}
inline ::pulsar::proto::CommandFlow* BaseCommand::mutable_flow() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandFlow* _msg = _internal_mutable_flow();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.flow)
  return _msg;
}
inline void BaseCommand::set_allocated_flow(::pulsar::proto::CommandFlow* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandFlow*>(_impl_.flow_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandFlow*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.flow_ = reinterpret_cast<::pulsar::proto::CommandFlow*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.flow)
}

// optional .pulsar.proto.CommandUnsubscribe unsubscribe = 12;
inline bool BaseCommand::has_unsubscribe() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unsubscribe_ != nullptr);
  return value;
}
inline void BaseCommand::clear_unsubscribe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.unsubscribe_ != nullptr) _impl_.unsubscribe_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::pulsar::proto::CommandUnsubscribe& BaseCommand::_internal_unsubscribe() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandUnsubscribe* p = _impl_.unsubscribe_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandUnsubscribe&>(::pulsar::proto::_CommandUnsubscribe_default_instance_);
}
inline const ::pulsar::proto::CommandUnsubscribe& BaseCommand::unsubscribe() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.unsubscribe)
  return _internal_unsubscribe();
}
inline void BaseCommand::unsafe_arena_set_allocated_unsubscribe(::pulsar::proto::CommandUnsubscribe* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.unsubscribe_);
  }
  _impl_.unsubscribe_ = reinterpret_cast<::pulsar::proto::CommandUnsubscribe*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.unsubscribe)
}
inline ::pulsar::proto::CommandUnsubscribe* BaseCommand::release_unsubscribe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::pulsar::proto::CommandUnsubscribe* released = _impl_.unsubscribe_;
  _impl_.unsubscribe_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandUnsubscribe* BaseCommand::unsafe_arena_release_unsubscribe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.unsubscribe)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::pulsar::proto::CommandUnsubscribe* temp = _impl_.unsubscribe_;
  _impl_.unsubscribe_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandUnsubscribe* BaseCommand::_internal_mutable_unsubscribe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.unsubscribe_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandUnsubscribe>(GetArena());
    _impl_.unsubscribe_ = reinterpret_cast<::pulsar::proto::CommandUnsubscribe*>(p);
  }
  return _impl_.unsubscribe_;
}
inline ::pulsar::proto::CommandUnsubscribe* BaseCommand::mutable_unsubscribe() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandUnsubscribe* _msg = _internal_mutable_unsubscribe();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.unsubscribe)
  return _msg;
}
inline void BaseCommand::set_allocated_unsubscribe(::pulsar::proto::CommandUnsubscribe* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandUnsubscribe*>(_impl_.unsubscribe_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandUnsubscribe*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.unsubscribe_ = reinterpret_cast<::pulsar::proto::CommandUnsubscribe*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.unsubscribe)
}

// optional .pulsar.proto.CommandSuccess success = 13;
inline bool BaseCommand::has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.success_ != nullptr);
  return value;
}
inline void BaseCommand::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.success_ != nullptr) _impl_.success_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::pulsar::proto::CommandSuccess& BaseCommand::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandSuccess* p = _impl_.success_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandSuccess&>(::pulsar::proto::_CommandSuccess_default_instance_);
}
inline const ::pulsar::proto::CommandSuccess& BaseCommand::success() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.success)
  return _internal_success();
}
inline void BaseCommand::unsafe_arena_set_allocated_success(::pulsar::proto::CommandSuccess* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.success_);
  }
  _impl_.success_ = reinterpret_cast<::pulsar::proto::CommandSuccess*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.success)
}
inline ::pulsar::proto::CommandSuccess* BaseCommand::release_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::pulsar::proto::CommandSuccess* released = _impl_.success_;
  _impl_.success_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandSuccess* BaseCommand::unsafe_arena_release_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.success)

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::pulsar::proto::CommandSuccess* temp = _impl_.success_;
  _impl_.success_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandSuccess* BaseCommand::_internal_mutable_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.success_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandSuccess>(GetArena());
    _impl_.success_ = reinterpret_cast<::pulsar::proto::CommandSuccess*>(p);
  }
  return _impl_.success_;
}
inline ::pulsar::proto::CommandSuccess* BaseCommand::mutable_success() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandSuccess* _msg = _internal_mutable_success();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.success)
  return _msg;
}
inline void BaseCommand::set_allocated_success(::pulsar::proto::CommandSuccess* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandSuccess*>(_impl_.success_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandSuccess*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }

  _impl_.success_ = reinterpret_cast<::pulsar::proto::CommandSuccess*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.success)
}

// optional .pulsar.proto.CommandError error = 14;
inline bool BaseCommand::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline void BaseCommand::clear_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::pulsar::proto::CommandError& BaseCommand::_internal_error() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandError&>(::pulsar::proto::_CommandError_default_instance_);
}
inline const ::pulsar::proto::CommandError& BaseCommand::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.error)
  return _internal_error();
}
inline void BaseCommand::unsafe_arena_set_allocated_error(::pulsar::proto::CommandError* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = reinterpret_cast<::pulsar::proto::CommandError*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.error)
}
inline ::pulsar::proto::CommandError* BaseCommand::release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::pulsar::proto::CommandError* released = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandError* BaseCommand::unsafe_arena_release_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.error)

  _impl_._has_bits_[0] &= ~0x00001000u;
  ::pulsar::proto::CommandError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandError* BaseCommand::_internal_mutable_error() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandError>(GetArena());
    _impl_.error_ = reinterpret_cast<::pulsar::proto::CommandError*>(p);
  }
  return _impl_.error_;
}
inline ::pulsar::proto::CommandError* BaseCommand::mutable_error() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.error)
  return _msg;
}
inline void BaseCommand::set_allocated_error(::pulsar::proto::CommandError* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandError*>(_impl_.error_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandError*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }

  _impl_.error_ = reinterpret_cast<::pulsar::proto::CommandError*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.error)
}

// optional .pulsar.proto.CommandCloseProducer close_producer = 15;
inline bool BaseCommand::has_close_producer() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.close_producer_ != nullptr);
  return value;
}
inline void BaseCommand::clear_close_producer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.close_producer_ != nullptr) _impl_.close_producer_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const ::pulsar::proto::CommandCloseProducer& BaseCommand::_internal_close_producer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandCloseProducer* p = _impl_.close_producer_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandCloseProducer&>(::pulsar::proto::_CommandCloseProducer_default_instance_);
}
inline const ::pulsar::proto::CommandCloseProducer& BaseCommand::close_producer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.close_producer)
  return _internal_close_producer();
}
inline void BaseCommand::unsafe_arena_set_allocated_close_producer(::pulsar::proto::CommandCloseProducer* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.close_producer_);
  }
  _impl_.close_producer_ = reinterpret_cast<::pulsar::proto::CommandCloseProducer*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.close_producer)
}
inline ::pulsar::proto::CommandCloseProducer* BaseCommand::release_close_producer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00002000u;
  ::pulsar::proto::CommandCloseProducer* released = _impl_.close_producer_;
  _impl_.close_producer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandCloseProducer* BaseCommand::unsafe_arena_release_close_producer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.close_producer)

  _impl_._has_bits_[0] &= ~0x00002000u;
  ::pulsar::proto::CommandCloseProducer* temp = _impl_.close_producer_;
  _impl_.close_producer_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandCloseProducer* BaseCommand::_internal_mutable_close_producer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.close_producer_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandCloseProducer>(GetArena());
    _impl_.close_producer_ = reinterpret_cast<::pulsar::proto::CommandCloseProducer*>(p);
  }
  return _impl_.close_producer_;
}
inline ::pulsar::proto::CommandCloseProducer* BaseCommand::mutable_close_producer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandCloseProducer* _msg = _internal_mutable_close_producer();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.close_producer)
  return _msg;
}
inline void BaseCommand::set_allocated_close_producer(::pulsar::proto::CommandCloseProducer* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandCloseProducer*>(_impl_.close_producer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandCloseProducer*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }

  _impl_.close_producer_ = reinterpret_cast<::pulsar::proto::CommandCloseProducer*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.close_producer)
}

// optional .pulsar.proto.CommandCloseConsumer close_consumer = 16;
inline bool BaseCommand::has_close_consumer() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.close_consumer_ != nullptr);
  return value;
}
inline void BaseCommand::clear_close_consumer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.close_consumer_ != nullptr) _impl_.close_consumer_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const ::pulsar::proto::CommandCloseConsumer& BaseCommand::_internal_close_consumer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandCloseConsumer* p = _impl_.close_consumer_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandCloseConsumer&>(::pulsar::proto::_CommandCloseConsumer_default_instance_);
}
inline const ::pulsar::proto::CommandCloseConsumer& BaseCommand::close_consumer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.close_consumer)
  return _internal_close_consumer();
}
inline void BaseCommand::unsafe_arena_set_allocated_close_consumer(::pulsar::proto::CommandCloseConsumer* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.close_consumer_);
  }
  _impl_.close_consumer_ = reinterpret_cast<::pulsar::proto::CommandCloseConsumer*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.close_consumer)
}
inline ::pulsar::proto::CommandCloseConsumer* BaseCommand::release_close_consumer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00004000u;
  ::pulsar::proto::CommandCloseConsumer* released = _impl_.close_consumer_;
  _impl_.close_consumer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandCloseConsumer* BaseCommand::unsafe_arena_release_close_consumer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.close_consumer)

  _impl_._has_bits_[0] &= ~0x00004000u;
  ::pulsar::proto::CommandCloseConsumer* temp = _impl_.close_consumer_;
  _impl_.close_consumer_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandCloseConsumer* BaseCommand::_internal_mutable_close_consumer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.close_consumer_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandCloseConsumer>(GetArena());
    _impl_.close_consumer_ = reinterpret_cast<::pulsar::proto::CommandCloseConsumer*>(p);
  }
  return _impl_.close_consumer_;
}
inline ::pulsar::proto::CommandCloseConsumer* BaseCommand::mutable_close_consumer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandCloseConsumer* _msg = _internal_mutable_close_consumer();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.close_consumer)
  return _msg;
}
inline void BaseCommand::set_allocated_close_consumer(::pulsar::proto::CommandCloseConsumer* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandCloseConsumer*>(_impl_.close_consumer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandCloseConsumer*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }

  _impl_.close_consumer_ = reinterpret_cast<::pulsar::proto::CommandCloseConsumer*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.close_consumer)
}

// optional .pulsar.proto.CommandProducerSuccess producer_success = 17;
inline bool BaseCommand::has_producer_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.producer_success_ != nullptr);
  return value;
}
inline void BaseCommand::clear_producer_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.producer_success_ != nullptr) _impl_.producer_success_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const ::pulsar::proto::CommandProducerSuccess& BaseCommand::_internal_producer_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandProducerSuccess* p = _impl_.producer_success_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandProducerSuccess&>(::pulsar::proto::_CommandProducerSuccess_default_instance_);
}
inline const ::pulsar::proto::CommandProducerSuccess& BaseCommand::producer_success() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.producer_success)
  return _internal_producer_success();
}
inline void BaseCommand::unsafe_arena_set_allocated_producer_success(::pulsar::proto::CommandProducerSuccess* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.producer_success_);
  }
  _impl_.producer_success_ = reinterpret_cast<::pulsar::proto::CommandProducerSuccess*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.producer_success)
}
inline ::pulsar::proto::CommandProducerSuccess* BaseCommand::release_producer_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00008000u;
  ::pulsar::proto::CommandProducerSuccess* released = _impl_.producer_success_;
  _impl_.producer_success_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandProducerSuccess* BaseCommand::unsafe_arena_release_producer_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.producer_success)

  _impl_._has_bits_[0] &= ~0x00008000u;
  ::pulsar::proto::CommandProducerSuccess* temp = _impl_.producer_success_;
  _impl_.producer_success_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandProducerSuccess* BaseCommand::_internal_mutable_producer_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.producer_success_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandProducerSuccess>(GetArena());
    _impl_.producer_success_ = reinterpret_cast<::pulsar::proto::CommandProducerSuccess*>(p);
  }
  return _impl_.producer_success_;
}
inline ::pulsar::proto::CommandProducerSuccess* BaseCommand::mutable_producer_success() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandProducerSuccess* _msg = _internal_mutable_producer_success();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.producer_success)
  return _msg;
}
inline void BaseCommand::set_allocated_producer_success(::pulsar::proto::CommandProducerSuccess* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandProducerSuccess*>(_impl_.producer_success_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandProducerSuccess*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }

  _impl_.producer_success_ = reinterpret_cast<::pulsar::proto::CommandProducerSuccess*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.producer_success)
}

// optional .pulsar.proto.CommandPing ping = 18;
inline bool BaseCommand::has_ping() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ping_ != nullptr);
  return value;
}
inline void BaseCommand::clear_ping() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ping_ != nullptr) _impl_.ping_->Clear();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const ::pulsar::proto::CommandPing& BaseCommand::_internal_ping() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandPing* p = _impl_.ping_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandPing&>(::pulsar::proto::_CommandPing_default_instance_);
}
inline const ::pulsar::proto::CommandPing& BaseCommand::ping() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.ping)
  return _internal_ping();
}
inline void BaseCommand::unsafe_arena_set_allocated_ping(::pulsar::proto::CommandPing* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ping_);
  }
  _impl_.ping_ = reinterpret_cast<::pulsar::proto::CommandPing*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.ping)
}
inline ::pulsar::proto::CommandPing* BaseCommand::release_ping() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00010000u;
  ::pulsar::proto::CommandPing* released = _impl_.ping_;
  _impl_.ping_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandPing* BaseCommand::unsafe_arena_release_ping() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.ping)

  _impl_._has_bits_[0] &= ~0x00010000u;
  ::pulsar::proto::CommandPing* temp = _impl_.ping_;
  _impl_.ping_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandPing* BaseCommand::_internal_mutable_ping() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00010000u;
  if (_impl_.ping_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandPing>(GetArena());
    _impl_.ping_ = reinterpret_cast<::pulsar::proto::CommandPing*>(p);
  }
  return _impl_.ping_;
}
inline ::pulsar::proto::CommandPing* BaseCommand::mutable_ping() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandPing* _msg = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.ping)
  return _msg;
}
inline void BaseCommand::set_allocated_ping(::pulsar::proto::CommandPing* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandPing*>(_impl_.ping_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandPing*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }

  _impl_.ping_ = reinterpret_cast<::pulsar::proto::CommandPing*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.ping)
}

// optional .pulsar.proto.CommandPong pong = 19;
inline bool BaseCommand::has_pong() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pong_ != nullptr);
  return value;
}
inline void BaseCommand::clear_pong() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pong_ != nullptr) _impl_.pong_->Clear();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const ::pulsar::proto::CommandPong& BaseCommand::_internal_pong() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandPong* p = _impl_.pong_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandPong&>(::pulsar::proto::_CommandPong_default_instance_);
}
inline const ::pulsar::proto::CommandPong& BaseCommand::pong() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.pong)
  return _internal_pong();
}
inline void BaseCommand::unsafe_arena_set_allocated_pong(::pulsar::proto::CommandPong* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pong_);
  }
  _impl_.pong_ = reinterpret_cast<::pulsar::proto::CommandPong*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.pong)
}
inline ::pulsar::proto::CommandPong* BaseCommand::release_pong() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00020000u;
  ::pulsar::proto::CommandPong* released = _impl_.pong_;
  _impl_.pong_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandPong* BaseCommand::unsafe_arena_release_pong() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.pong)

  _impl_._has_bits_[0] &= ~0x00020000u;
  ::pulsar::proto::CommandPong* temp = _impl_.pong_;
  _impl_.pong_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandPong* BaseCommand::_internal_mutable_pong() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00020000u;
  if (_impl_.pong_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandPong>(GetArena());
    _impl_.pong_ = reinterpret_cast<::pulsar::proto::CommandPong*>(p);
  }
  return _impl_.pong_;
}
inline ::pulsar::proto::CommandPong* BaseCommand::mutable_pong() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandPong* _msg = _internal_mutable_pong();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.pong)
  return _msg;
}
inline void BaseCommand::set_allocated_pong(::pulsar::proto::CommandPong* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandPong*>(_impl_.pong_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandPong*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }

  _impl_.pong_ = reinterpret_cast<::pulsar::proto::CommandPong*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.pong)
}

// optional .pulsar.proto.CommandRedeliverUnacknowledgedMessages redeliverUnacknowledgedMessages = 20;
inline bool BaseCommand::has_redeliverunacknowledgedmessages() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.redeliverunacknowledgedmessages_ != nullptr);
  return value;
}
inline void BaseCommand::clear_redeliverunacknowledgedmessages() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.redeliverunacknowledgedmessages_ != nullptr) _impl_.redeliverunacknowledgedmessages_->Clear();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages& BaseCommand::_internal_redeliverunacknowledgedmessages() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* p = _impl_.redeliverunacknowledgedmessages_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages&>(::pulsar::proto::_CommandRedeliverUnacknowledgedMessages_default_instance_);
}
inline const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages& BaseCommand::redeliverunacknowledgedmessages() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.redeliverUnacknowledgedMessages)
  return _internal_redeliverunacknowledgedmessages();
}
inline void BaseCommand::unsafe_arena_set_allocated_redeliverunacknowledgedmessages(::pulsar::proto::CommandRedeliverUnacknowledgedMessages* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.redeliverunacknowledgedmessages_);
  }
  _impl_.redeliverunacknowledgedmessages_ = reinterpret_cast<::pulsar::proto::CommandRedeliverUnacknowledgedMessages*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.redeliverUnacknowledgedMessages)
}
inline ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* BaseCommand::release_redeliverunacknowledgedmessages() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00040000u;
  ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* released = _impl_.redeliverunacknowledgedmessages_;
  _impl_.redeliverunacknowledgedmessages_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* BaseCommand::unsafe_arena_release_redeliverunacknowledgedmessages() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.redeliverUnacknowledgedMessages)

  _impl_._has_bits_[0] &= ~0x00040000u;
  ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* temp = _impl_.redeliverunacknowledgedmessages_;
  _impl_.redeliverunacknowledgedmessages_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* BaseCommand::_internal_mutable_redeliverunacknowledgedmessages() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00040000u;
  if (_impl_.redeliverunacknowledgedmessages_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandRedeliverUnacknowledgedMessages>(GetArena());
    _impl_.redeliverunacknowledgedmessages_ = reinterpret_cast<::pulsar::proto::CommandRedeliverUnacknowledgedMessages*>(p);
  }
  return _impl_.redeliverunacknowledgedmessages_;
}
inline ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* BaseCommand::mutable_redeliverunacknowledgedmessages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandRedeliverUnacknowledgedMessages* _msg = _internal_mutable_redeliverunacknowledgedmessages();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.redeliverUnacknowledgedMessages)
  return _msg;
}
inline void BaseCommand::set_allocated_redeliverunacknowledgedmessages(::pulsar::proto::CommandRedeliverUnacknowledgedMessages* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandRedeliverUnacknowledgedMessages*>(_impl_.redeliverunacknowledgedmessages_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandRedeliverUnacknowledgedMessages*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }

  _impl_.redeliverunacknowledgedmessages_ = reinterpret_cast<::pulsar::proto::CommandRedeliverUnacknowledgedMessages*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.redeliverUnacknowledgedMessages)
}

// optional .pulsar.proto.CommandPartitionedTopicMetadata partitionMetadata = 21;
inline bool BaseCommand::has_partitionmetadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.partitionmetadata_ != nullptr);
  return value;
}
inline void BaseCommand::clear_partitionmetadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.partitionmetadata_ != nullptr) _impl_.partitionmetadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline const ::pulsar::proto::CommandPartitionedTopicMetadata& BaseCommand::_internal_partitionmetadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandPartitionedTopicMetadata* p = _impl_.partitionmetadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandPartitionedTopicMetadata&>(::pulsar::proto::_CommandPartitionedTopicMetadata_default_instance_);
}
inline const ::pulsar::proto::CommandPartitionedTopicMetadata& BaseCommand::partitionmetadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.partitionMetadata)
  return _internal_partitionmetadata();
}
inline void BaseCommand::unsafe_arena_set_allocated_partitionmetadata(::pulsar::proto::CommandPartitionedTopicMetadata* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.partitionmetadata_);
  }
  _impl_.partitionmetadata_ = reinterpret_cast<::pulsar::proto::CommandPartitionedTopicMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.partitionMetadata)
}
inline ::pulsar::proto::CommandPartitionedTopicMetadata* BaseCommand::release_partitionmetadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00080000u;
  ::pulsar::proto::CommandPartitionedTopicMetadata* released = _impl_.partitionmetadata_;
  _impl_.partitionmetadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandPartitionedTopicMetadata* BaseCommand::unsafe_arena_release_partitionmetadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.partitionMetadata)

  _impl_._has_bits_[0] &= ~0x00080000u;
  ::pulsar::proto::CommandPartitionedTopicMetadata* temp = _impl_.partitionmetadata_;
  _impl_.partitionmetadata_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandPartitionedTopicMetadata* BaseCommand::_internal_mutable_partitionmetadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00080000u;
  if (_impl_.partitionmetadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandPartitionedTopicMetadata>(GetArena());
    _impl_.partitionmetadata_ = reinterpret_cast<::pulsar::proto::CommandPartitionedTopicMetadata*>(p);
  }
  return _impl_.partitionmetadata_;
}
inline ::pulsar::proto::CommandPartitionedTopicMetadata* BaseCommand::mutable_partitionmetadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandPartitionedTopicMetadata* _msg = _internal_mutable_partitionmetadata();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.partitionMetadata)
  return _msg;
}
inline void BaseCommand::set_allocated_partitionmetadata(::pulsar::proto::CommandPartitionedTopicMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandPartitionedTopicMetadata*>(_impl_.partitionmetadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandPartitionedTopicMetadata*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }

  _impl_.partitionmetadata_ = reinterpret_cast<::pulsar::proto::CommandPartitionedTopicMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.partitionMetadata)
}

// optional .pulsar.proto.CommandPartitionedTopicMetadataResponse partitionMetadataResponse = 22;
inline bool BaseCommand::has_partitionmetadataresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.partitionmetadataresponse_ != nullptr);
  return value;
}
inline void BaseCommand::clear_partitionmetadataresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.partitionmetadataresponse_ != nullptr) _impl_.partitionmetadataresponse_->Clear();
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline const ::pulsar::proto::CommandPartitionedTopicMetadataResponse& BaseCommand::_internal_partitionmetadataresponse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandPartitionedTopicMetadataResponse* p = _impl_.partitionmetadataresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandPartitionedTopicMetadataResponse&>(::pulsar::proto::_CommandPartitionedTopicMetadataResponse_default_instance_);
}
inline const ::pulsar::proto::CommandPartitionedTopicMetadataResponse& BaseCommand::partitionmetadataresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.partitionMetadataResponse)
  return _internal_partitionmetadataresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_partitionmetadataresponse(::pulsar::proto::CommandPartitionedTopicMetadataResponse* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.partitionmetadataresponse_);
  }
  _impl_.partitionmetadataresponse_ = reinterpret_cast<::pulsar::proto::CommandPartitionedTopicMetadataResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.partitionMetadataResponse)
}
inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse* BaseCommand::release_partitionmetadataresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00100000u;
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse* released = _impl_.partitionmetadataresponse_;
  _impl_.partitionmetadataresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse* BaseCommand::unsafe_arena_release_partitionmetadataresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.partitionMetadataResponse)

  _impl_._has_bits_[0] &= ~0x00100000u;
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse* temp = _impl_.partitionmetadataresponse_;
  _impl_.partitionmetadataresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse* BaseCommand::_internal_mutable_partitionmetadataresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00100000u;
  if (_impl_.partitionmetadataresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandPartitionedTopicMetadataResponse>(GetArena());
    _impl_.partitionmetadataresponse_ = reinterpret_cast<::pulsar::proto::CommandPartitionedTopicMetadataResponse*>(p);
  }
  return _impl_.partitionmetadataresponse_;
}
inline ::pulsar::proto::CommandPartitionedTopicMetadataResponse* BaseCommand::mutable_partitionmetadataresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandPartitionedTopicMetadataResponse* _msg = _internal_mutable_partitionmetadataresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.partitionMetadataResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_partitionmetadataresponse(::pulsar::proto::CommandPartitionedTopicMetadataResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandPartitionedTopicMetadataResponse*>(_impl_.partitionmetadataresponse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandPartitionedTopicMetadataResponse*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }

  _impl_.partitionmetadataresponse_ = reinterpret_cast<::pulsar::proto::CommandPartitionedTopicMetadataResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.partitionMetadataResponse)
}

// optional .pulsar.proto.CommandLookupTopic lookupTopic = 23;
inline bool BaseCommand::has_lookuptopic() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lookuptopic_ != nullptr);
  return value;
}
inline void BaseCommand::clear_lookuptopic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.lookuptopic_ != nullptr) _impl_.lookuptopic_->Clear();
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline const ::pulsar::proto::CommandLookupTopic& BaseCommand::_internal_lookuptopic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandLookupTopic* p = _impl_.lookuptopic_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandLookupTopic&>(::pulsar::proto::_CommandLookupTopic_default_instance_);
}
inline const ::pulsar::proto::CommandLookupTopic& BaseCommand::lookuptopic() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.lookupTopic)
  return _internal_lookuptopic();
}
inline void BaseCommand::unsafe_arena_set_allocated_lookuptopic(::pulsar::proto::CommandLookupTopic* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lookuptopic_);
  }
  _impl_.lookuptopic_ = reinterpret_cast<::pulsar::proto::CommandLookupTopic*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.lookupTopic)
}
inline ::pulsar::proto::CommandLookupTopic* BaseCommand::release_lookuptopic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00200000u;
  ::pulsar::proto::CommandLookupTopic* released = _impl_.lookuptopic_;
  _impl_.lookuptopic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandLookupTopic* BaseCommand::unsafe_arena_release_lookuptopic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.lookupTopic)

  _impl_._has_bits_[0] &= ~0x00200000u;
  ::pulsar::proto::CommandLookupTopic* temp = _impl_.lookuptopic_;
  _impl_.lookuptopic_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandLookupTopic* BaseCommand::_internal_mutable_lookuptopic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00200000u;
  if (_impl_.lookuptopic_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandLookupTopic>(GetArena());
    _impl_.lookuptopic_ = reinterpret_cast<::pulsar::proto::CommandLookupTopic*>(p);
  }
  return _impl_.lookuptopic_;
}
inline ::pulsar::proto::CommandLookupTopic* BaseCommand::mutable_lookuptopic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandLookupTopic* _msg = _internal_mutable_lookuptopic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.lookupTopic)
  return _msg;
}
inline void BaseCommand::set_allocated_lookuptopic(::pulsar::proto::CommandLookupTopic* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandLookupTopic*>(_impl_.lookuptopic_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandLookupTopic*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }

  _impl_.lookuptopic_ = reinterpret_cast<::pulsar::proto::CommandLookupTopic*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.lookupTopic)
}

// optional .pulsar.proto.CommandLookupTopicResponse lookupTopicResponse = 24;
inline bool BaseCommand::has_lookuptopicresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lookuptopicresponse_ != nullptr);
  return value;
}
inline void BaseCommand::clear_lookuptopicresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.lookuptopicresponse_ != nullptr) _impl_.lookuptopicresponse_->Clear();
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline const ::pulsar::proto::CommandLookupTopicResponse& BaseCommand::_internal_lookuptopicresponse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandLookupTopicResponse* p = _impl_.lookuptopicresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandLookupTopicResponse&>(::pulsar::proto::_CommandLookupTopicResponse_default_instance_);
}
inline const ::pulsar::proto::CommandLookupTopicResponse& BaseCommand::lookuptopicresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.lookupTopicResponse)
  return _internal_lookuptopicresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_lookuptopicresponse(::pulsar::proto::CommandLookupTopicResponse* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lookuptopicresponse_);
  }
  _impl_.lookuptopicresponse_ = reinterpret_cast<::pulsar::proto::CommandLookupTopicResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.lookupTopicResponse)
}
inline ::pulsar::proto::CommandLookupTopicResponse* BaseCommand::release_lookuptopicresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00400000u;
  ::pulsar::proto::CommandLookupTopicResponse* released = _impl_.lookuptopicresponse_;
  _impl_.lookuptopicresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandLookupTopicResponse* BaseCommand::unsafe_arena_release_lookuptopicresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.lookupTopicResponse)

  _impl_._has_bits_[0] &= ~0x00400000u;
  ::pulsar::proto::CommandLookupTopicResponse* temp = _impl_.lookuptopicresponse_;
  _impl_.lookuptopicresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandLookupTopicResponse* BaseCommand::_internal_mutable_lookuptopicresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00400000u;
  if (_impl_.lookuptopicresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandLookupTopicResponse>(GetArena());
    _impl_.lookuptopicresponse_ = reinterpret_cast<::pulsar::proto::CommandLookupTopicResponse*>(p);
  }
  return _impl_.lookuptopicresponse_;
}
inline ::pulsar::proto::CommandLookupTopicResponse* BaseCommand::mutable_lookuptopicresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandLookupTopicResponse* _msg = _internal_mutable_lookuptopicresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.lookupTopicResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_lookuptopicresponse(::pulsar::proto::CommandLookupTopicResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandLookupTopicResponse*>(_impl_.lookuptopicresponse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandLookupTopicResponse*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }

  _impl_.lookuptopicresponse_ = reinterpret_cast<::pulsar::proto::CommandLookupTopicResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.lookupTopicResponse)
}

// optional .pulsar.proto.CommandConsumerStats consumerStats = 25;
inline bool BaseCommand::has_consumerstats() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.consumerstats_ != nullptr);
  return value;
}
inline void BaseCommand::clear_consumerstats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.consumerstats_ != nullptr) _impl_.consumerstats_->Clear();
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline const ::pulsar::proto::CommandConsumerStats& BaseCommand::_internal_consumerstats() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandConsumerStats* p = _impl_.consumerstats_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandConsumerStats&>(::pulsar::proto::_CommandConsumerStats_default_instance_);
}
inline const ::pulsar::proto::CommandConsumerStats& BaseCommand::consumerstats() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.consumerStats)
  return _internal_consumerstats();
}
inline void BaseCommand::unsafe_arena_set_allocated_consumerstats(::pulsar::proto::CommandConsumerStats* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.consumerstats_);
  }
  _impl_.consumerstats_ = reinterpret_cast<::pulsar::proto::CommandConsumerStats*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.consumerStats)
}
inline ::pulsar::proto::CommandConsumerStats* BaseCommand::release_consumerstats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00800000u;
  ::pulsar::proto::CommandConsumerStats* released = _impl_.consumerstats_;
  _impl_.consumerstats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandConsumerStats* BaseCommand::unsafe_arena_release_consumerstats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.consumerStats)

  _impl_._has_bits_[0] &= ~0x00800000u;
  ::pulsar::proto::CommandConsumerStats* temp = _impl_.consumerstats_;
  _impl_.consumerstats_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandConsumerStats* BaseCommand::_internal_mutable_consumerstats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00800000u;
  if (_impl_.consumerstats_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandConsumerStats>(GetArena());
    _impl_.consumerstats_ = reinterpret_cast<::pulsar::proto::CommandConsumerStats*>(p);
  }
  return _impl_.consumerstats_;
}
inline ::pulsar::proto::CommandConsumerStats* BaseCommand::mutable_consumerstats() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandConsumerStats* _msg = _internal_mutable_consumerstats();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.consumerStats)
  return _msg;
}
inline void BaseCommand::set_allocated_consumerstats(::pulsar::proto::CommandConsumerStats* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandConsumerStats*>(_impl_.consumerstats_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandConsumerStats*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }

  _impl_.consumerstats_ = reinterpret_cast<::pulsar::proto::CommandConsumerStats*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.consumerStats)
}

// optional .pulsar.proto.CommandConsumerStatsResponse consumerStatsResponse = 26;
inline bool BaseCommand::has_consumerstatsresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.consumerstatsresponse_ != nullptr);
  return value;
}
inline void BaseCommand::clear_consumerstatsresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.consumerstatsresponse_ != nullptr) _impl_.consumerstatsresponse_->Clear();
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline const ::pulsar::proto::CommandConsumerStatsResponse& BaseCommand::_internal_consumerstatsresponse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandConsumerStatsResponse* p = _impl_.consumerstatsresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandConsumerStatsResponse&>(::pulsar::proto::_CommandConsumerStatsResponse_default_instance_);
}
inline const ::pulsar::proto::CommandConsumerStatsResponse& BaseCommand::consumerstatsresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.consumerStatsResponse)
  return _internal_consumerstatsresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_consumerstatsresponse(::pulsar::proto::CommandConsumerStatsResponse* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.consumerstatsresponse_);
  }
  _impl_.consumerstatsresponse_ = reinterpret_cast<::pulsar::proto::CommandConsumerStatsResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.consumerStatsResponse)
}
inline ::pulsar::proto::CommandConsumerStatsResponse* BaseCommand::release_consumerstatsresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x01000000u;
  ::pulsar::proto::CommandConsumerStatsResponse* released = _impl_.consumerstatsresponse_;
  _impl_.consumerstatsresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandConsumerStatsResponse* BaseCommand::unsafe_arena_release_consumerstatsresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.consumerStatsResponse)

  _impl_._has_bits_[0] &= ~0x01000000u;
  ::pulsar::proto::CommandConsumerStatsResponse* temp = _impl_.consumerstatsresponse_;
  _impl_.consumerstatsresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandConsumerStatsResponse* BaseCommand::_internal_mutable_consumerstatsresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x01000000u;
  if (_impl_.consumerstatsresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandConsumerStatsResponse>(GetArena());
    _impl_.consumerstatsresponse_ = reinterpret_cast<::pulsar::proto::CommandConsumerStatsResponse*>(p);
  }
  return _impl_.consumerstatsresponse_;
}
inline ::pulsar::proto::CommandConsumerStatsResponse* BaseCommand::mutable_consumerstatsresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandConsumerStatsResponse* _msg = _internal_mutable_consumerstatsresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.consumerStatsResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_consumerstatsresponse(::pulsar::proto::CommandConsumerStatsResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandConsumerStatsResponse*>(_impl_.consumerstatsresponse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandConsumerStatsResponse*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }

  _impl_.consumerstatsresponse_ = reinterpret_cast<::pulsar::proto::CommandConsumerStatsResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.consumerStatsResponse)
}

// optional .pulsar.proto.CommandReachedEndOfTopic reachedEndOfTopic = 27;
inline bool BaseCommand::has_reachedendoftopic() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reachedendoftopic_ != nullptr);
  return value;
}
inline void BaseCommand::clear_reachedendoftopic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.reachedendoftopic_ != nullptr) _impl_.reachedendoftopic_->Clear();
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline const ::pulsar::proto::CommandReachedEndOfTopic& BaseCommand::_internal_reachedendoftopic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandReachedEndOfTopic* p = _impl_.reachedendoftopic_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandReachedEndOfTopic&>(::pulsar::proto::_CommandReachedEndOfTopic_default_instance_);
}
inline const ::pulsar::proto::CommandReachedEndOfTopic& BaseCommand::reachedendoftopic() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.reachedEndOfTopic)
  return _internal_reachedendoftopic();
}
inline void BaseCommand::unsafe_arena_set_allocated_reachedendoftopic(::pulsar::proto::CommandReachedEndOfTopic* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reachedendoftopic_);
  }
  _impl_.reachedendoftopic_ = reinterpret_cast<::pulsar::proto::CommandReachedEndOfTopic*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.reachedEndOfTopic)
}
inline ::pulsar::proto::CommandReachedEndOfTopic* BaseCommand::release_reachedendoftopic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x02000000u;
  ::pulsar::proto::CommandReachedEndOfTopic* released = _impl_.reachedendoftopic_;
  _impl_.reachedendoftopic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandReachedEndOfTopic* BaseCommand::unsafe_arena_release_reachedendoftopic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.reachedEndOfTopic)

  _impl_._has_bits_[0] &= ~0x02000000u;
  ::pulsar::proto::CommandReachedEndOfTopic* temp = _impl_.reachedendoftopic_;
  _impl_.reachedendoftopic_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandReachedEndOfTopic* BaseCommand::_internal_mutable_reachedendoftopic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x02000000u;
  if (_impl_.reachedendoftopic_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandReachedEndOfTopic>(GetArena());
    _impl_.reachedendoftopic_ = reinterpret_cast<::pulsar::proto::CommandReachedEndOfTopic*>(p);
  }
  return _impl_.reachedendoftopic_;
}
inline ::pulsar::proto::CommandReachedEndOfTopic* BaseCommand::mutable_reachedendoftopic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandReachedEndOfTopic* _msg = _internal_mutable_reachedendoftopic();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.reachedEndOfTopic)
  return _msg;
}
inline void BaseCommand::set_allocated_reachedendoftopic(::pulsar::proto::CommandReachedEndOfTopic* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandReachedEndOfTopic*>(_impl_.reachedendoftopic_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandReachedEndOfTopic*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }

  _impl_.reachedendoftopic_ = reinterpret_cast<::pulsar::proto::CommandReachedEndOfTopic*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.reachedEndOfTopic)
}

// optional .pulsar.proto.CommandSeek seek = 28;
inline bool BaseCommand::has_seek() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seek_ != nullptr);
  return value;
}
inline void BaseCommand::clear_seek() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.seek_ != nullptr) _impl_.seek_->Clear();
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline const ::pulsar::proto::CommandSeek& BaseCommand::_internal_seek() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandSeek* p = _impl_.seek_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandSeek&>(::pulsar::proto::_CommandSeek_default_instance_);
}
inline const ::pulsar::proto::CommandSeek& BaseCommand::seek() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.seek)
  return _internal_seek();
}
inline void BaseCommand::unsafe_arena_set_allocated_seek(::pulsar::proto::CommandSeek* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.seek_);
  }
  _impl_.seek_ = reinterpret_cast<::pulsar::proto::CommandSeek*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.seek)
}
inline ::pulsar::proto::CommandSeek* BaseCommand::release_seek() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x04000000u;
  ::pulsar::proto::CommandSeek* released = _impl_.seek_;
  _impl_.seek_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandSeek* BaseCommand::unsafe_arena_release_seek() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.seek)

  _impl_._has_bits_[0] &= ~0x04000000u;
  ::pulsar::proto::CommandSeek* temp = _impl_.seek_;
  _impl_.seek_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandSeek* BaseCommand::_internal_mutable_seek() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x04000000u;
  if (_impl_.seek_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandSeek>(GetArena());
    _impl_.seek_ = reinterpret_cast<::pulsar::proto::CommandSeek*>(p);
  }
  return _impl_.seek_;
}
inline ::pulsar::proto::CommandSeek* BaseCommand::mutable_seek() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandSeek* _msg = _internal_mutable_seek();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.seek)
  return _msg;
}
inline void BaseCommand::set_allocated_seek(::pulsar::proto::CommandSeek* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandSeek*>(_impl_.seek_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandSeek*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }

  _impl_.seek_ = reinterpret_cast<::pulsar::proto::CommandSeek*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.seek)
}

// optional .pulsar.proto.CommandGetLastMessageId getLastMessageId = 29;
inline bool BaseCommand::has_getlastmessageid() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.getlastmessageid_ != nullptr);
  return value;
}
inline void BaseCommand::clear_getlastmessageid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.getlastmessageid_ != nullptr) _impl_.getlastmessageid_->Clear();
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline const ::pulsar::proto::CommandGetLastMessageId& BaseCommand::_internal_getlastmessageid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandGetLastMessageId* p = _impl_.getlastmessageid_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandGetLastMessageId&>(::pulsar::proto::_CommandGetLastMessageId_default_instance_);
}
inline const ::pulsar::proto::CommandGetLastMessageId& BaseCommand::getlastmessageid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getLastMessageId)
  return _internal_getlastmessageid();
}
inline void BaseCommand::unsafe_arena_set_allocated_getlastmessageid(::pulsar::proto::CommandGetLastMessageId* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.getlastmessageid_);
  }
  _impl_.getlastmessageid_ = reinterpret_cast<::pulsar::proto::CommandGetLastMessageId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.getLastMessageId)
}
inline ::pulsar::proto::CommandGetLastMessageId* BaseCommand::release_getlastmessageid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x08000000u;
  ::pulsar::proto::CommandGetLastMessageId* released = _impl_.getlastmessageid_;
  _impl_.getlastmessageid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandGetLastMessageId* BaseCommand::unsafe_arena_release_getlastmessageid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.getLastMessageId)

  _impl_._has_bits_[0] &= ~0x08000000u;
  ::pulsar::proto::CommandGetLastMessageId* temp = _impl_.getlastmessageid_;
  _impl_.getlastmessageid_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandGetLastMessageId* BaseCommand::_internal_mutable_getlastmessageid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x08000000u;
  if (_impl_.getlastmessageid_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandGetLastMessageId>(GetArena());
    _impl_.getlastmessageid_ = reinterpret_cast<::pulsar::proto::CommandGetLastMessageId*>(p);
  }
  return _impl_.getlastmessageid_;
}
inline ::pulsar::proto::CommandGetLastMessageId* BaseCommand::mutable_getlastmessageid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandGetLastMessageId* _msg = _internal_mutable_getlastmessageid();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getLastMessageId)
  return _msg;
}
inline void BaseCommand::set_allocated_getlastmessageid(::pulsar::proto::CommandGetLastMessageId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandGetLastMessageId*>(_impl_.getlastmessageid_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandGetLastMessageId*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x08000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x08000000u;
  }

  _impl_.getlastmessageid_ = reinterpret_cast<::pulsar::proto::CommandGetLastMessageId*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getLastMessageId)
}

// optional .pulsar.proto.CommandGetLastMessageIdResponse getLastMessageIdResponse = 30;
inline bool BaseCommand::has_getlastmessageidresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.getlastmessageidresponse_ != nullptr);
  return value;
}
inline void BaseCommand::clear_getlastmessageidresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.getlastmessageidresponse_ != nullptr) _impl_.getlastmessageidresponse_->Clear();
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline const ::pulsar::proto::CommandGetLastMessageIdResponse& BaseCommand::_internal_getlastmessageidresponse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandGetLastMessageIdResponse* p = _impl_.getlastmessageidresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandGetLastMessageIdResponse&>(::pulsar::proto::_CommandGetLastMessageIdResponse_default_instance_);
}
inline const ::pulsar::proto::CommandGetLastMessageIdResponse& BaseCommand::getlastmessageidresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getLastMessageIdResponse)
  return _internal_getlastmessageidresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_getlastmessageidresponse(::pulsar::proto::CommandGetLastMessageIdResponse* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.getlastmessageidresponse_);
  }
  _impl_.getlastmessageidresponse_ = reinterpret_cast<::pulsar::proto::CommandGetLastMessageIdResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.getLastMessageIdResponse)
}
inline ::pulsar::proto::CommandGetLastMessageIdResponse* BaseCommand::release_getlastmessageidresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x10000000u;
  ::pulsar::proto::CommandGetLastMessageIdResponse* released = _impl_.getlastmessageidresponse_;
  _impl_.getlastmessageidresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandGetLastMessageIdResponse* BaseCommand::unsafe_arena_release_getlastmessageidresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.getLastMessageIdResponse)

  _impl_._has_bits_[0] &= ~0x10000000u;
  ::pulsar::proto::CommandGetLastMessageIdResponse* temp = _impl_.getlastmessageidresponse_;
  _impl_.getlastmessageidresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandGetLastMessageIdResponse* BaseCommand::_internal_mutable_getlastmessageidresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x10000000u;
  if (_impl_.getlastmessageidresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandGetLastMessageIdResponse>(GetArena());
    _impl_.getlastmessageidresponse_ = reinterpret_cast<::pulsar::proto::CommandGetLastMessageIdResponse*>(p);
  }
  return _impl_.getlastmessageidresponse_;
}
inline ::pulsar::proto::CommandGetLastMessageIdResponse* BaseCommand::mutable_getlastmessageidresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandGetLastMessageIdResponse* _msg = _internal_mutable_getlastmessageidresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getLastMessageIdResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_getlastmessageidresponse(::pulsar::proto::CommandGetLastMessageIdResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandGetLastMessageIdResponse*>(_impl_.getlastmessageidresponse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandGetLastMessageIdResponse*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x10000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x10000000u;
  }

  _impl_.getlastmessageidresponse_ = reinterpret_cast<::pulsar::proto::CommandGetLastMessageIdResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getLastMessageIdResponse)
}

// optional .pulsar.proto.CommandActiveConsumerChange active_consumer_change = 31;
inline bool BaseCommand::has_active_consumer_change() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.active_consumer_change_ != nullptr);
  return value;
}
inline void BaseCommand::clear_active_consumer_change() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.active_consumer_change_ != nullptr) _impl_.active_consumer_change_->Clear();
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline const ::pulsar::proto::CommandActiveConsumerChange& BaseCommand::_internal_active_consumer_change() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandActiveConsumerChange* p = _impl_.active_consumer_change_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandActiveConsumerChange&>(::pulsar::proto::_CommandActiveConsumerChange_default_instance_);
}
inline const ::pulsar::proto::CommandActiveConsumerChange& BaseCommand::active_consumer_change() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.active_consumer_change)
  return _internal_active_consumer_change();
}
inline void BaseCommand::unsafe_arena_set_allocated_active_consumer_change(::pulsar::proto::CommandActiveConsumerChange* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.active_consumer_change_);
  }
  _impl_.active_consumer_change_ = reinterpret_cast<::pulsar::proto::CommandActiveConsumerChange*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.active_consumer_change)
}
inline ::pulsar::proto::CommandActiveConsumerChange* BaseCommand::release_active_consumer_change() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x20000000u;
  ::pulsar::proto::CommandActiveConsumerChange* released = _impl_.active_consumer_change_;
  _impl_.active_consumer_change_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandActiveConsumerChange* BaseCommand::unsafe_arena_release_active_consumer_change() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.active_consumer_change)

  _impl_._has_bits_[0] &= ~0x20000000u;
  ::pulsar::proto::CommandActiveConsumerChange* temp = _impl_.active_consumer_change_;
  _impl_.active_consumer_change_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandActiveConsumerChange* BaseCommand::_internal_mutable_active_consumer_change() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x20000000u;
  if (_impl_.active_consumer_change_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandActiveConsumerChange>(GetArena());
    _impl_.active_consumer_change_ = reinterpret_cast<::pulsar::proto::CommandActiveConsumerChange*>(p);
  }
  return _impl_.active_consumer_change_;
}
inline ::pulsar::proto::CommandActiveConsumerChange* BaseCommand::mutable_active_consumer_change() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandActiveConsumerChange* _msg = _internal_mutable_active_consumer_change();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.active_consumer_change)
  return _msg;
}
inline void BaseCommand::set_allocated_active_consumer_change(::pulsar::proto::CommandActiveConsumerChange* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandActiveConsumerChange*>(_impl_.active_consumer_change_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandActiveConsumerChange*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x20000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x20000000u;
  }

  _impl_.active_consumer_change_ = reinterpret_cast<::pulsar::proto::CommandActiveConsumerChange*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.active_consumer_change)
}

// optional .pulsar.proto.CommandGetTopicsOfNamespace getTopicsOfNamespace = 32;
inline bool BaseCommand::has_gettopicsofnamespace() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gettopicsofnamespace_ != nullptr);
  return value;
}
inline void BaseCommand::clear_gettopicsofnamespace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.gettopicsofnamespace_ != nullptr) _impl_.gettopicsofnamespace_->Clear();
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline const ::pulsar::proto::CommandGetTopicsOfNamespace& BaseCommand::_internal_gettopicsofnamespace() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandGetTopicsOfNamespace* p = _impl_.gettopicsofnamespace_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandGetTopicsOfNamespace&>(::pulsar::proto::_CommandGetTopicsOfNamespace_default_instance_);
}
inline const ::pulsar::proto::CommandGetTopicsOfNamespace& BaseCommand::gettopicsofnamespace() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getTopicsOfNamespace)
  return _internal_gettopicsofnamespace();
}
inline void BaseCommand::unsafe_arena_set_allocated_gettopicsofnamespace(::pulsar::proto::CommandGetTopicsOfNamespace* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gettopicsofnamespace_);
  }
  _impl_.gettopicsofnamespace_ = reinterpret_cast<::pulsar::proto::CommandGetTopicsOfNamespace*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.getTopicsOfNamespace)
}
inline ::pulsar::proto::CommandGetTopicsOfNamespace* BaseCommand::release_gettopicsofnamespace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x40000000u;
  ::pulsar::proto::CommandGetTopicsOfNamespace* released = _impl_.gettopicsofnamespace_;
  _impl_.gettopicsofnamespace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandGetTopicsOfNamespace* BaseCommand::unsafe_arena_release_gettopicsofnamespace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.getTopicsOfNamespace)

  _impl_._has_bits_[0] &= ~0x40000000u;
  ::pulsar::proto::CommandGetTopicsOfNamespace* temp = _impl_.gettopicsofnamespace_;
  _impl_.gettopicsofnamespace_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandGetTopicsOfNamespace* BaseCommand::_internal_mutable_gettopicsofnamespace() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x40000000u;
  if (_impl_.gettopicsofnamespace_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandGetTopicsOfNamespace>(GetArena());
    _impl_.gettopicsofnamespace_ = reinterpret_cast<::pulsar::proto::CommandGetTopicsOfNamespace*>(p);
  }
  return _impl_.gettopicsofnamespace_;
}
inline ::pulsar::proto::CommandGetTopicsOfNamespace* BaseCommand::mutable_gettopicsofnamespace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandGetTopicsOfNamespace* _msg = _internal_mutable_gettopicsofnamespace();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getTopicsOfNamespace)
  return _msg;
}
inline void BaseCommand::set_allocated_gettopicsofnamespace(::pulsar::proto::CommandGetTopicsOfNamespace* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandGetTopicsOfNamespace*>(_impl_.gettopicsofnamespace_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandGetTopicsOfNamespace*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x40000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x40000000u;
  }

  _impl_.gettopicsofnamespace_ = reinterpret_cast<::pulsar::proto::CommandGetTopicsOfNamespace*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getTopicsOfNamespace)
}

// optional .pulsar.proto.CommandGetTopicsOfNamespaceResponse getTopicsOfNamespaceResponse = 33;
inline bool BaseCommand::has_gettopicsofnamespaceresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gettopicsofnamespaceresponse_ != nullptr);
  return value;
}
inline void BaseCommand::clear_gettopicsofnamespaceresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.gettopicsofnamespaceresponse_ != nullptr) _impl_.gettopicsofnamespaceresponse_->Clear();
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse& BaseCommand::_internal_gettopicsofnamespaceresponse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* p = _impl_.gettopicsofnamespaceresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse&>(::pulsar::proto::_CommandGetTopicsOfNamespaceResponse_default_instance_);
}
inline const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse& BaseCommand::gettopicsofnamespaceresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getTopicsOfNamespaceResponse)
  return _internal_gettopicsofnamespaceresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_gettopicsofnamespaceresponse(::pulsar::proto::CommandGetTopicsOfNamespaceResponse* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gettopicsofnamespaceresponse_);
  }
  _impl_.gettopicsofnamespaceresponse_ = reinterpret_cast<::pulsar::proto::CommandGetTopicsOfNamespaceResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.getTopicsOfNamespaceResponse)
}
inline ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* BaseCommand::release_gettopicsofnamespaceresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x80000000u;
  ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* released = _impl_.gettopicsofnamespaceresponse_;
  _impl_.gettopicsofnamespaceresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* BaseCommand::unsafe_arena_release_gettopicsofnamespaceresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.getTopicsOfNamespaceResponse)

  _impl_._has_bits_[0] &= ~0x80000000u;
  ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* temp = _impl_.gettopicsofnamespaceresponse_;
  _impl_.gettopicsofnamespaceresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* BaseCommand::_internal_mutable_gettopicsofnamespaceresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x80000000u;
  if (_impl_.gettopicsofnamespaceresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandGetTopicsOfNamespaceResponse>(GetArena());
    _impl_.gettopicsofnamespaceresponse_ = reinterpret_cast<::pulsar::proto::CommandGetTopicsOfNamespaceResponse*>(p);
  }
  return _impl_.gettopicsofnamespaceresponse_;
}
inline ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* BaseCommand::mutable_gettopicsofnamespaceresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandGetTopicsOfNamespaceResponse* _msg = _internal_mutable_gettopicsofnamespaceresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getTopicsOfNamespaceResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_gettopicsofnamespaceresponse(::pulsar::proto::CommandGetTopicsOfNamespaceResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandGetTopicsOfNamespaceResponse*>(_impl_.gettopicsofnamespaceresponse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandGetTopicsOfNamespaceResponse*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x80000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x80000000u;
  }

  _impl_.gettopicsofnamespaceresponse_ = reinterpret_cast<::pulsar::proto::CommandGetTopicsOfNamespaceResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getTopicsOfNamespaceResponse)
}

// optional .pulsar.proto.CommandGetSchema getSchema = 34;
inline bool BaseCommand::has_getschema() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.getschema_ != nullptr);
  return value;
}
inline void BaseCommand::clear_getschema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.getschema_ != nullptr) _impl_.getschema_->Clear();
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline const ::pulsar::proto::CommandGetSchema& BaseCommand::_internal_getschema() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandGetSchema* p = _impl_.getschema_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandGetSchema&>(::pulsar::proto::_CommandGetSchema_default_instance_);
}
inline const ::pulsar::proto::CommandGetSchema& BaseCommand::getschema() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getSchema)
  return _internal_getschema();
}
inline void BaseCommand::unsafe_arena_set_allocated_getschema(::pulsar::proto::CommandGetSchema* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.getschema_);
  }
  _impl_.getschema_ = reinterpret_cast<::pulsar::proto::CommandGetSchema*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.getSchema)
}
inline ::pulsar::proto::CommandGetSchema* BaseCommand::release_getschema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00000001u;
  ::pulsar::proto::CommandGetSchema* released = _impl_.getschema_;
  _impl_.getschema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandGetSchema* BaseCommand::unsafe_arena_release_getschema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.getSchema)

  _impl_._has_bits_[1] &= ~0x00000001u;
  ::pulsar::proto::CommandGetSchema* temp = _impl_.getschema_;
  _impl_.getschema_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandGetSchema* BaseCommand::_internal_mutable_getschema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000001u;
  if (_impl_.getschema_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandGetSchema>(GetArena());
    _impl_.getschema_ = reinterpret_cast<::pulsar::proto::CommandGetSchema*>(p);
  }
  return _impl_.getschema_;
}
inline ::pulsar::proto::CommandGetSchema* BaseCommand::mutable_getschema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandGetSchema* _msg = _internal_mutable_getschema();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getSchema)
  return _msg;
}
inline void BaseCommand::set_allocated_getschema(::pulsar::proto::CommandGetSchema* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandGetSchema*>(_impl_.getschema_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandGetSchema*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000001u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000001u;
  }

  _impl_.getschema_ = reinterpret_cast<::pulsar::proto::CommandGetSchema*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getSchema)
}

// optional .pulsar.proto.CommandGetSchemaResponse getSchemaResponse = 35;
inline bool BaseCommand::has_getschemaresponse() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.getschemaresponse_ != nullptr);
  return value;
}
inline void BaseCommand::clear_getschemaresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.getschemaresponse_ != nullptr) _impl_.getschemaresponse_->Clear();
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline const ::pulsar::proto::CommandGetSchemaResponse& BaseCommand::_internal_getschemaresponse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandGetSchemaResponse* p = _impl_.getschemaresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandGetSchemaResponse&>(::pulsar::proto::_CommandGetSchemaResponse_default_instance_);
}
inline const ::pulsar::proto::CommandGetSchemaResponse& BaseCommand::getschemaresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getSchemaResponse)
  return _internal_getschemaresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_getschemaresponse(::pulsar::proto::CommandGetSchemaResponse* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.getschemaresponse_);
  }
  _impl_.getschemaresponse_ = reinterpret_cast<::pulsar::proto::CommandGetSchemaResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.getSchemaResponse)
}
inline ::pulsar::proto::CommandGetSchemaResponse* BaseCommand::release_getschemaresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00000002u;
  ::pulsar::proto::CommandGetSchemaResponse* released = _impl_.getschemaresponse_;
  _impl_.getschemaresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandGetSchemaResponse* BaseCommand::unsafe_arena_release_getschemaresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.getSchemaResponse)

  _impl_._has_bits_[1] &= ~0x00000002u;
  ::pulsar::proto::CommandGetSchemaResponse* temp = _impl_.getschemaresponse_;
  _impl_.getschemaresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandGetSchemaResponse* BaseCommand::_internal_mutable_getschemaresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000002u;
  if (_impl_.getschemaresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandGetSchemaResponse>(GetArena());
    _impl_.getschemaresponse_ = reinterpret_cast<::pulsar::proto::CommandGetSchemaResponse*>(p);
  }
  return _impl_.getschemaresponse_;
}
inline ::pulsar::proto::CommandGetSchemaResponse* BaseCommand::mutable_getschemaresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandGetSchemaResponse* _msg = _internal_mutable_getschemaresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getSchemaResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_getschemaresponse(::pulsar::proto::CommandGetSchemaResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandGetSchemaResponse*>(_impl_.getschemaresponse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandGetSchemaResponse*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000002u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000002u;
  }

  _impl_.getschemaresponse_ = reinterpret_cast<::pulsar::proto::CommandGetSchemaResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getSchemaResponse)
}

// optional .pulsar.proto.CommandAuthChallenge authChallenge = 36;
inline bool BaseCommand::has_authchallenge() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.authchallenge_ != nullptr);
  return value;
}
inline void BaseCommand::clear_authchallenge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.authchallenge_ != nullptr) _impl_.authchallenge_->Clear();
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline const ::pulsar::proto::CommandAuthChallenge& BaseCommand::_internal_authchallenge() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandAuthChallenge* p = _impl_.authchallenge_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandAuthChallenge&>(::pulsar::proto::_CommandAuthChallenge_default_instance_);
}
inline const ::pulsar::proto::CommandAuthChallenge& BaseCommand::authchallenge() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.authChallenge)
  return _internal_authchallenge();
}
inline void BaseCommand::unsafe_arena_set_allocated_authchallenge(::pulsar::proto::CommandAuthChallenge* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.authchallenge_);
  }
  _impl_.authchallenge_ = reinterpret_cast<::pulsar::proto::CommandAuthChallenge*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.authChallenge)
}
inline ::pulsar::proto::CommandAuthChallenge* BaseCommand::release_authchallenge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00000004u;
  ::pulsar::proto::CommandAuthChallenge* released = _impl_.authchallenge_;
  _impl_.authchallenge_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandAuthChallenge* BaseCommand::unsafe_arena_release_authchallenge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.authChallenge)

  _impl_._has_bits_[1] &= ~0x00000004u;
  ::pulsar::proto::CommandAuthChallenge* temp = _impl_.authchallenge_;
  _impl_.authchallenge_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandAuthChallenge* BaseCommand::_internal_mutable_authchallenge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000004u;
  if (_impl_.authchallenge_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandAuthChallenge>(GetArena());
    _impl_.authchallenge_ = reinterpret_cast<::pulsar::proto::CommandAuthChallenge*>(p);
  }
  return _impl_.authchallenge_;
}
inline ::pulsar::proto::CommandAuthChallenge* BaseCommand::mutable_authchallenge() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandAuthChallenge* _msg = _internal_mutable_authchallenge();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.authChallenge)
  return _msg;
}
inline void BaseCommand::set_allocated_authchallenge(::pulsar::proto::CommandAuthChallenge* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandAuthChallenge*>(_impl_.authchallenge_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandAuthChallenge*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000004u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000004u;
  }

  _impl_.authchallenge_ = reinterpret_cast<::pulsar::proto::CommandAuthChallenge*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.authChallenge)
}

// optional .pulsar.proto.CommandAuthResponse authResponse = 37;
inline bool BaseCommand::has_authresponse() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.authresponse_ != nullptr);
  return value;
}
inline void BaseCommand::clear_authresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.authresponse_ != nullptr) _impl_.authresponse_->Clear();
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline const ::pulsar::proto::CommandAuthResponse& BaseCommand::_internal_authresponse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandAuthResponse* p = _impl_.authresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandAuthResponse&>(::pulsar::proto::_CommandAuthResponse_default_instance_);
}
inline const ::pulsar::proto::CommandAuthResponse& BaseCommand::authresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.authResponse)
  return _internal_authresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_authresponse(::pulsar::proto::CommandAuthResponse* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.authresponse_);
  }
  _impl_.authresponse_ = reinterpret_cast<::pulsar::proto::CommandAuthResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000008u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.authResponse)
}
inline ::pulsar::proto::CommandAuthResponse* BaseCommand::release_authresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00000008u;
  ::pulsar::proto::CommandAuthResponse* released = _impl_.authresponse_;
  _impl_.authresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandAuthResponse* BaseCommand::unsafe_arena_release_authresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.authResponse)

  _impl_._has_bits_[1] &= ~0x00000008u;
  ::pulsar::proto::CommandAuthResponse* temp = _impl_.authresponse_;
  _impl_.authresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandAuthResponse* BaseCommand::_internal_mutable_authresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000008u;
  if (_impl_.authresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandAuthResponse>(GetArena());
    _impl_.authresponse_ = reinterpret_cast<::pulsar::proto::CommandAuthResponse*>(p);
  }
  return _impl_.authresponse_;
}
inline ::pulsar::proto::CommandAuthResponse* BaseCommand::mutable_authresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandAuthResponse* _msg = _internal_mutable_authresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.authResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_authresponse(::pulsar::proto::CommandAuthResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandAuthResponse*>(_impl_.authresponse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandAuthResponse*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000008u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000008u;
  }

  _impl_.authresponse_ = reinterpret_cast<::pulsar::proto::CommandAuthResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.authResponse)
}

// optional .pulsar.proto.CommandAckResponse ackResponse = 38;
inline bool BaseCommand::has_ackresponse() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ackresponse_ != nullptr);
  return value;
}
inline void BaseCommand::clear_ackresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ackresponse_ != nullptr) _impl_.ackresponse_->Clear();
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline const ::pulsar::proto::CommandAckResponse& BaseCommand::_internal_ackresponse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandAckResponse* p = _impl_.ackresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandAckResponse&>(::pulsar::proto::_CommandAckResponse_default_instance_);
}
inline const ::pulsar::proto::CommandAckResponse& BaseCommand::ackresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.ackResponse)
  return _internal_ackresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_ackresponse(::pulsar::proto::CommandAckResponse* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ackresponse_);
  }
  _impl_.ackresponse_ = reinterpret_cast<::pulsar::proto::CommandAckResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000010u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.ackResponse)
}
inline ::pulsar::proto::CommandAckResponse* BaseCommand::release_ackresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00000010u;
  ::pulsar::proto::CommandAckResponse* released = _impl_.ackresponse_;
  _impl_.ackresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandAckResponse* BaseCommand::unsafe_arena_release_ackresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.ackResponse)

  _impl_._has_bits_[1] &= ~0x00000010u;
  ::pulsar::proto::CommandAckResponse* temp = _impl_.ackresponse_;
  _impl_.ackresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandAckResponse* BaseCommand::_internal_mutable_ackresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000010u;
  if (_impl_.ackresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandAckResponse>(GetArena());
    _impl_.ackresponse_ = reinterpret_cast<::pulsar::proto::CommandAckResponse*>(p);
  }
  return _impl_.ackresponse_;
}
inline ::pulsar::proto::CommandAckResponse* BaseCommand::mutable_ackresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandAckResponse* _msg = _internal_mutable_ackresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.ackResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_ackresponse(::pulsar::proto::CommandAckResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandAckResponse*>(_impl_.ackresponse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandAckResponse*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000010u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000010u;
  }

  _impl_.ackresponse_ = reinterpret_cast<::pulsar::proto::CommandAckResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.ackResponse)
}

// optional .pulsar.proto.CommandGetOrCreateSchema getOrCreateSchema = 39;
inline bool BaseCommand::has_getorcreateschema() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.getorcreateschema_ != nullptr);
  return value;
}
inline void BaseCommand::clear_getorcreateschema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.getorcreateschema_ != nullptr) _impl_.getorcreateschema_->Clear();
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline const ::pulsar::proto::CommandGetOrCreateSchema& BaseCommand::_internal_getorcreateschema() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandGetOrCreateSchema* p = _impl_.getorcreateschema_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandGetOrCreateSchema&>(::pulsar::proto::_CommandGetOrCreateSchema_default_instance_);
}
inline const ::pulsar::proto::CommandGetOrCreateSchema& BaseCommand::getorcreateschema() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getOrCreateSchema)
  return _internal_getorcreateschema();
}
inline void BaseCommand::unsafe_arena_set_allocated_getorcreateschema(::pulsar::proto::CommandGetOrCreateSchema* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.getorcreateschema_);
  }
  _impl_.getorcreateschema_ = reinterpret_cast<::pulsar::proto::CommandGetOrCreateSchema*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000020u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.getOrCreateSchema)
}
inline ::pulsar::proto::CommandGetOrCreateSchema* BaseCommand::release_getorcreateschema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00000020u;
  ::pulsar::proto::CommandGetOrCreateSchema* released = _impl_.getorcreateschema_;
  _impl_.getorcreateschema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandGetOrCreateSchema* BaseCommand::unsafe_arena_release_getorcreateschema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.getOrCreateSchema)

  _impl_._has_bits_[1] &= ~0x00000020u;
  ::pulsar::proto::CommandGetOrCreateSchema* temp = _impl_.getorcreateschema_;
  _impl_.getorcreateschema_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandGetOrCreateSchema* BaseCommand::_internal_mutable_getorcreateschema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000020u;
  if (_impl_.getorcreateschema_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandGetOrCreateSchema>(GetArena());
    _impl_.getorcreateschema_ = reinterpret_cast<::pulsar::proto::CommandGetOrCreateSchema*>(p);
  }
  return _impl_.getorcreateschema_;
}
inline ::pulsar::proto::CommandGetOrCreateSchema* BaseCommand::mutable_getorcreateschema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandGetOrCreateSchema* _msg = _internal_mutable_getorcreateschema();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getOrCreateSchema)
  return _msg;
}
inline void BaseCommand::set_allocated_getorcreateschema(::pulsar::proto::CommandGetOrCreateSchema* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandGetOrCreateSchema*>(_impl_.getorcreateschema_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandGetOrCreateSchema*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000020u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000020u;
  }

  _impl_.getorcreateschema_ = reinterpret_cast<::pulsar::proto::CommandGetOrCreateSchema*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getOrCreateSchema)
}

// optional .pulsar.proto.CommandGetOrCreateSchemaResponse getOrCreateSchemaResponse = 40;
inline bool BaseCommand::has_getorcreateschemaresponse() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.getorcreateschemaresponse_ != nullptr);
  return value;
}
inline void BaseCommand::clear_getorcreateschemaresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.getorcreateschemaresponse_ != nullptr) _impl_.getorcreateschemaresponse_->Clear();
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline const ::pulsar::proto::CommandGetOrCreateSchemaResponse& BaseCommand::_internal_getorcreateschemaresponse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandGetOrCreateSchemaResponse* p = _impl_.getorcreateschemaresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandGetOrCreateSchemaResponse&>(::pulsar::proto::_CommandGetOrCreateSchemaResponse_default_instance_);
}
inline const ::pulsar::proto::CommandGetOrCreateSchemaResponse& BaseCommand::getorcreateschemaresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.getOrCreateSchemaResponse)
  return _internal_getorcreateschemaresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_getorcreateschemaresponse(::pulsar::proto::CommandGetOrCreateSchemaResponse* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.getorcreateschemaresponse_);
  }
  _impl_.getorcreateschemaresponse_ = reinterpret_cast<::pulsar::proto::CommandGetOrCreateSchemaResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000040u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.getOrCreateSchemaResponse)
}
inline ::pulsar::proto::CommandGetOrCreateSchemaResponse* BaseCommand::release_getorcreateschemaresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00000040u;
  ::pulsar::proto::CommandGetOrCreateSchemaResponse* released = _impl_.getorcreateschemaresponse_;
  _impl_.getorcreateschemaresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandGetOrCreateSchemaResponse* BaseCommand::unsafe_arena_release_getorcreateschemaresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.getOrCreateSchemaResponse)

  _impl_._has_bits_[1] &= ~0x00000040u;
  ::pulsar::proto::CommandGetOrCreateSchemaResponse* temp = _impl_.getorcreateschemaresponse_;
  _impl_.getorcreateschemaresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandGetOrCreateSchemaResponse* BaseCommand::_internal_mutable_getorcreateschemaresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000040u;
  if (_impl_.getorcreateschemaresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandGetOrCreateSchemaResponse>(GetArena());
    _impl_.getorcreateschemaresponse_ = reinterpret_cast<::pulsar::proto::CommandGetOrCreateSchemaResponse*>(p);
  }
  return _impl_.getorcreateschemaresponse_;
}
inline ::pulsar::proto::CommandGetOrCreateSchemaResponse* BaseCommand::mutable_getorcreateschemaresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandGetOrCreateSchemaResponse* _msg = _internal_mutable_getorcreateschemaresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.getOrCreateSchemaResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_getorcreateschemaresponse(::pulsar::proto::CommandGetOrCreateSchemaResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandGetOrCreateSchemaResponse*>(_impl_.getorcreateschemaresponse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandGetOrCreateSchemaResponse*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000040u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000040u;
  }

  _impl_.getorcreateschemaresponse_ = reinterpret_cast<::pulsar::proto::CommandGetOrCreateSchemaResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.getOrCreateSchemaResponse)
}

// optional .pulsar.proto.CommandNewTxn newTxn = 50;
inline bool BaseCommand::has_newtxn() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.newtxn_ != nullptr);
  return value;
}
inline void BaseCommand::clear_newtxn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.newtxn_ != nullptr) _impl_.newtxn_->Clear();
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline const ::pulsar::proto::CommandNewTxn& BaseCommand::_internal_newtxn() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandNewTxn* p = _impl_.newtxn_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandNewTxn&>(::pulsar::proto::_CommandNewTxn_default_instance_);
}
inline const ::pulsar::proto::CommandNewTxn& BaseCommand::newtxn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.newTxn)
  return _internal_newtxn();
}
inline void BaseCommand::unsafe_arena_set_allocated_newtxn(::pulsar::proto::CommandNewTxn* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.newtxn_);
  }
  _impl_.newtxn_ = reinterpret_cast<::pulsar::proto::CommandNewTxn*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000080u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.newTxn)
}
inline ::pulsar::proto::CommandNewTxn* BaseCommand::release_newtxn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00000080u;
  ::pulsar::proto::CommandNewTxn* released = _impl_.newtxn_;
  _impl_.newtxn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandNewTxn* BaseCommand::unsafe_arena_release_newtxn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.newTxn)

  _impl_._has_bits_[1] &= ~0x00000080u;
  ::pulsar::proto::CommandNewTxn* temp = _impl_.newtxn_;
  _impl_.newtxn_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandNewTxn* BaseCommand::_internal_mutable_newtxn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000080u;
  if (_impl_.newtxn_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandNewTxn>(GetArena());
    _impl_.newtxn_ = reinterpret_cast<::pulsar::proto::CommandNewTxn*>(p);
  }
  return _impl_.newtxn_;
}
inline ::pulsar::proto::CommandNewTxn* BaseCommand::mutable_newtxn() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandNewTxn* _msg = _internal_mutable_newtxn();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.newTxn)
  return _msg;
}
inline void BaseCommand::set_allocated_newtxn(::pulsar::proto::CommandNewTxn* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandNewTxn*>(_impl_.newtxn_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandNewTxn*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000080u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000080u;
  }

  _impl_.newtxn_ = reinterpret_cast<::pulsar::proto::CommandNewTxn*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.newTxn)
}

// optional .pulsar.proto.CommandNewTxnResponse newTxnResponse = 51;
inline bool BaseCommand::has_newtxnresponse() const {
  bool value = (_impl_._has_bits_[1] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.newtxnresponse_ != nullptr);
  return value;
}
inline void BaseCommand::clear_newtxnresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.newtxnresponse_ != nullptr) _impl_.newtxnresponse_->Clear();
  _impl_._has_bits_[1] &= ~0x00000100u;
}
inline const ::pulsar::proto::CommandNewTxnResponse& BaseCommand::_internal_newtxnresponse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandNewTxnResponse* p = _impl_.newtxnresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandNewTxnResponse&>(::pulsar::proto::_CommandNewTxnResponse_default_instance_);
}
inline const ::pulsar::proto::CommandNewTxnResponse& BaseCommand::newtxnresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.newTxnResponse)
  return _internal_newtxnresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_newtxnresponse(::pulsar::proto::CommandNewTxnResponse* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.newtxnresponse_);
  }
  _impl_.newtxnresponse_ = reinterpret_cast<::pulsar::proto::CommandNewTxnResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000100u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.newTxnResponse)
}
inline ::pulsar::proto::CommandNewTxnResponse* BaseCommand::release_newtxnresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00000100u;
  ::pulsar::proto::CommandNewTxnResponse* released = _impl_.newtxnresponse_;
  _impl_.newtxnresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandNewTxnResponse* BaseCommand::unsafe_arena_release_newtxnresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.newTxnResponse)

  _impl_._has_bits_[1] &= ~0x00000100u;
  ::pulsar::proto::CommandNewTxnResponse* temp = _impl_.newtxnresponse_;
  _impl_.newtxnresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandNewTxnResponse* BaseCommand::_internal_mutable_newtxnresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000100u;
  if (_impl_.newtxnresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandNewTxnResponse>(GetArena());
    _impl_.newtxnresponse_ = reinterpret_cast<::pulsar::proto::CommandNewTxnResponse*>(p);
  }
  return _impl_.newtxnresponse_;
}
inline ::pulsar::proto::CommandNewTxnResponse* BaseCommand::mutable_newtxnresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandNewTxnResponse* _msg = _internal_mutable_newtxnresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.newTxnResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_newtxnresponse(::pulsar::proto::CommandNewTxnResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandNewTxnResponse*>(_impl_.newtxnresponse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandNewTxnResponse*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000100u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000100u;
  }

  _impl_.newtxnresponse_ = reinterpret_cast<::pulsar::proto::CommandNewTxnResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.newTxnResponse)
}

// optional .pulsar.proto.CommandAddPartitionToTxn addPartitionToTxn = 52;
inline bool BaseCommand::has_addpartitiontotxn() const {
  bool value = (_impl_._has_bits_[1] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.addpartitiontotxn_ != nullptr);
  return value;
}
inline void BaseCommand::clear_addpartitiontotxn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.addpartitiontotxn_ != nullptr) _impl_.addpartitiontotxn_->Clear();
  _impl_._has_bits_[1] &= ~0x00000200u;
}
inline const ::pulsar::proto::CommandAddPartitionToTxn& BaseCommand::_internal_addpartitiontotxn() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandAddPartitionToTxn* p = _impl_.addpartitiontotxn_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandAddPartitionToTxn&>(::pulsar::proto::_CommandAddPartitionToTxn_default_instance_);
}
inline const ::pulsar::proto::CommandAddPartitionToTxn& BaseCommand::addpartitiontotxn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.addPartitionToTxn)
  return _internal_addpartitiontotxn();
}
inline void BaseCommand::unsafe_arena_set_allocated_addpartitiontotxn(::pulsar::proto::CommandAddPartitionToTxn* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.addpartitiontotxn_);
  }
  _impl_.addpartitiontotxn_ = reinterpret_cast<::pulsar::proto::CommandAddPartitionToTxn*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000200u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.addPartitionToTxn)
}
inline ::pulsar::proto::CommandAddPartitionToTxn* BaseCommand::release_addpartitiontotxn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00000200u;
  ::pulsar::proto::CommandAddPartitionToTxn* released = _impl_.addpartitiontotxn_;
  _impl_.addpartitiontotxn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandAddPartitionToTxn* BaseCommand::unsafe_arena_release_addpartitiontotxn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.addPartitionToTxn)

  _impl_._has_bits_[1] &= ~0x00000200u;
  ::pulsar::proto::CommandAddPartitionToTxn* temp = _impl_.addpartitiontotxn_;
  _impl_.addpartitiontotxn_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandAddPartitionToTxn* BaseCommand::_internal_mutable_addpartitiontotxn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000200u;
  if (_impl_.addpartitiontotxn_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandAddPartitionToTxn>(GetArena());
    _impl_.addpartitiontotxn_ = reinterpret_cast<::pulsar::proto::CommandAddPartitionToTxn*>(p);
  }
  return _impl_.addpartitiontotxn_;
}
inline ::pulsar::proto::CommandAddPartitionToTxn* BaseCommand::mutable_addpartitiontotxn() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandAddPartitionToTxn* _msg = _internal_mutable_addpartitiontotxn();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.addPartitionToTxn)
  return _msg;
}
inline void BaseCommand::set_allocated_addpartitiontotxn(::pulsar::proto::CommandAddPartitionToTxn* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandAddPartitionToTxn*>(_impl_.addpartitiontotxn_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandAddPartitionToTxn*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000200u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000200u;
  }

  _impl_.addpartitiontotxn_ = reinterpret_cast<::pulsar::proto::CommandAddPartitionToTxn*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.addPartitionToTxn)
}

// optional .pulsar.proto.CommandAddPartitionToTxnResponse addPartitionToTxnResponse = 53;
inline bool BaseCommand::has_addpartitiontotxnresponse() const {
  bool value = (_impl_._has_bits_[1] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.addpartitiontotxnresponse_ != nullptr);
  return value;
}
inline void BaseCommand::clear_addpartitiontotxnresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.addpartitiontotxnresponse_ != nullptr) _impl_.addpartitiontotxnresponse_->Clear();
  _impl_._has_bits_[1] &= ~0x00000400u;
}
inline const ::pulsar::proto::CommandAddPartitionToTxnResponse& BaseCommand::_internal_addpartitiontotxnresponse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandAddPartitionToTxnResponse* p = _impl_.addpartitiontotxnresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandAddPartitionToTxnResponse&>(::pulsar::proto::_CommandAddPartitionToTxnResponse_default_instance_);
}
inline const ::pulsar::proto::CommandAddPartitionToTxnResponse& BaseCommand::addpartitiontotxnresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.addPartitionToTxnResponse)
  return _internal_addpartitiontotxnresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_addpartitiontotxnresponse(::pulsar::proto::CommandAddPartitionToTxnResponse* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.addpartitiontotxnresponse_);
  }
  _impl_.addpartitiontotxnresponse_ = reinterpret_cast<::pulsar::proto::CommandAddPartitionToTxnResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000400u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.addPartitionToTxnResponse)
}
inline ::pulsar::proto::CommandAddPartitionToTxnResponse* BaseCommand::release_addpartitiontotxnresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00000400u;
  ::pulsar::proto::CommandAddPartitionToTxnResponse* released = _impl_.addpartitiontotxnresponse_;
  _impl_.addpartitiontotxnresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandAddPartitionToTxnResponse* BaseCommand::unsafe_arena_release_addpartitiontotxnresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.addPartitionToTxnResponse)

  _impl_._has_bits_[1] &= ~0x00000400u;
  ::pulsar::proto::CommandAddPartitionToTxnResponse* temp = _impl_.addpartitiontotxnresponse_;
  _impl_.addpartitiontotxnresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandAddPartitionToTxnResponse* BaseCommand::_internal_mutable_addpartitiontotxnresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000400u;
  if (_impl_.addpartitiontotxnresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandAddPartitionToTxnResponse>(GetArena());
    _impl_.addpartitiontotxnresponse_ = reinterpret_cast<::pulsar::proto::CommandAddPartitionToTxnResponse*>(p);
  }
  return _impl_.addpartitiontotxnresponse_;
}
inline ::pulsar::proto::CommandAddPartitionToTxnResponse* BaseCommand::mutable_addpartitiontotxnresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandAddPartitionToTxnResponse* _msg = _internal_mutable_addpartitiontotxnresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.addPartitionToTxnResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_addpartitiontotxnresponse(::pulsar::proto::CommandAddPartitionToTxnResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandAddPartitionToTxnResponse*>(_impl_.addpartitiontotxnresponse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandAddPartitionToTxnResponse*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000400u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000400u;
  }

  _impl_.addpartitiontotxnresponse_ = reinterpret_cast<::pulsar::proto::CommandAddPartitionToTxnResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.addPartitionToTxnResponse)
}

// optional .pulsar.proto.CommandAddSubscriptionToTxn addSubscriptionToTxn = 54;
inline bool BaseCommand::has_addsubscriptiontotxn() const {
  bool value = (_impl_._has_bits_[1] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.addsubscriptiontotxn_ != nullptr);
  return value;
}
inline void BaseCommand::clear_addsubscriptiontotxn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.addsubscriptiontotxn_ != nullptr) _impl_.addsubscriptiontotxn_->Clear();
  _impl_._has_bits_[1] &= ~0x00000800u;
}
inline const ::pulsar::proto::CommandAddSubscriptionToTxn& BaseCommand::_internal_addsubscriptiontotxn() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandAddSubscriptionToTxn* p = _impl_.addsubscriptiontotxn_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandAddSubscriptionToTxn&>(::pulsar::proto::_CommandAddSubscriptionToTxn_default_instance_);
}
inline const ::pulsar::proto::CommandAddSubscriptionToTxn& BaseCommand::addsubscriptiontotxn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.addSubscriptionToTxn)
  return _internal_addsubscriptiontotxn();
}
inline void BaseCommand::unsafe_arena_set_allocated_addsubscriptiontotxn(::pulsar::proto::CommandAddSubscriptionToTxn* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.addsubscriptiontotxn_);
  }
  _impl_.addsubscriptiontotxn_ = reinterpret_cast<::pulsar::proto::CommandAddSubscriptionToTxn*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00000800u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.addSubscriptionToTxn)
}
inline ::pulsar::proto::CommandAddSubscriptionToTxn* BaseCommand::release_addsubscriptiontotxn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00000800u;
  ::pulsar::proto::CommandAddSubscriptionToTxn* released = _impl_.addsubscriptiontotxn_;
  _impl_.addsubscriptiontotxn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandAddSubscriptionToTxn* BaseCommand::unsafe_arena_release_addsubscriptiontotxn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.addSubscriptionToTxn)

  _impl_._has_bits_[1] &= ~0x00000800u;
  ::pulsar::proto::CommandAddSubscriptionToTxn* temp = _impl_.addsubscriptiontotxn_;
  _impl_.addsubscriptiontotxn_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandAddSubscriptionToTxn* BaseCommand::_internal_mutable_addsubscriptiontotxn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00000800u;
  if (_impl_.addsubscriptiontotxn_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandAddSubscriptionToTxn>(GetArena());
    _impl_.addsubscriptiontotxn_ = reinterpret_cast<::pulsar::proto::CommandAddSubscriptionToTxn*>(p);
  }
  return _impl_.addsubscriptiontotxn_;
}
inline ::pulsar::proto::CommandAddSubscriptionToTxn* BaseCommand::mutable_addsubscriptiontotxn() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandAddSubscriptionToTxn* _msg = _internal_mutable_addsubscriptiontotxn();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.addSubscriptionToTxn)
  return _msg;
}
inline void BaseCommand::set_allocated_addsubscriptiontotxn(::pulsar::proto::CommandAddSubscriptionToTxn* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandAddSubscriptionToTxn*>(_impl_.addsubscriptiontotxn_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandAddSubscriptionToTxn*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00000800u;
  } else {
    _impl_._has_bits_[1] &= ~0x00000800u;
  }

  _impl_.addsubscriptiontotxn_ = reinterpret_cast<::pulsar::proto::CommandAddSubscriptionToTxn*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.addSubscriptionToTxn)
}

// optional .pulsar.proto.CommandAddSubscriptionToTxnResponse addSubscriptionToTxnResponse = 55;
inline bool BaseCommand::has_addsubscriptiontotxnresponse() const {
  bool value = (_impl_._has_bits_[1] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.addsubscriptiontotxnresponse_ != nullptr);
  return value;
}
inline void BaseCommand::clear_addsubscriptiontotxnresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.addsubscriptiontotxnresponse_ != nullptr) _impl_.addsubscriptiontotxnresponse_->Clear();
  _impl_._has_bits_[1] &= ~0x00001000u;
}
inline const ::pulsar::proto::CommandAddSubscriptionToTxnResponse& BaseCommand::_internal_addsubscriptiontotxnresponse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandAddSubscriptionToTxnResponse* p = _impl_.addsubscriptiontotxnresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandAddSubscriptionToTxnResponse&>(::pulsar::proto::_CommandAddSubscriptionToTxnResponse_default_instance_);
}
inline const ::pulsar::proto::CommandAddSubscriptionToTxnResponse& BaseCommand::addsubscriptiontotxnresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.addSubscriptionToTxnResponse)
  return _internal_addsubscriptiontotxnresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_addsubscriptiontotxnresponse(::pulsar::proto::CommandAddSubscriptionToTxnResponse* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.addsubscriptiontotxnresponse_);
  }
  _impl_.addsubscriptiontotxnresponse_ = reinterpret_cast<::pulsar::proto::CommandAddSubscriptionToTxnResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00001000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.addSubscriptionToTxnResponse)
}
inline ::pulsar::proto::CommandAddSubscriptionToTxnResponse* BaseCommand::release_addsubscriptiontotxnresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00001000u;
  ::pulsar::proto::CommandAddSubscriptionToTxnResponse* released = _impl_.addsubscriptiontotxnresponse_;
  _impl_.addsubscriptiontotxnresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandAddSubscriptionToTxnResponse* BaseCommand::unsafe_arena_release_addsubscriptiontotxnresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.addSubscriptionToTxnResponse)

  _impl_._has_bits_[1] &= ~0x00001000u;
  ::pulsar::proto::CommandAddSubscriptionToTxnResponse* temp = _impl_.addsubscriptiontotxnresponse_;
  _impl_.addsubscriptiontotxnresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandAddSubscriptionToTxnResponse* BaseCommand::_internal_mutable_addsubscriptiontotxnresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00001000u;
  if (_impl_.addsubscriptiontotxnresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandAddSubscriptionToTxnResponse>(GetArena());
    _impl_.addsubscriptiontotxnresponse_ = reinterpret_cast<::pulsar::proto::CommandAddSubscriptionToTxnResponse*>(p);
  }
  return _impl_.addsubscriptiontotxnresponse_;
}
inline ::pulsar::proto::CommandAddSubscriptionToTxnResponse* BaseCommand::mutable_addsubscriptiontotxnresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandAddSubscriptionToTxnResponse* _msg = _internal_mutable_addsubscriptiontotxnresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.addSubscriptionToTxnResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_addsubscriptiontotxnresponse(::pulsar::proto::CommandAddSubscriptionToTxnResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandAddSubscriptionToTxnResponse*>(_impl_.addsubscriptiontotxnresponse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandAddSubscriptionToTxnResponse*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00001000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00001000u;
  }

  _impl_.addsubscriptiontotxnresponse_ = reinterpret_cast<::pulsar::proto::CommandAddSubscriptionToTxnResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.addSubscriptionToTxnResponse)
}

// optional .pulsar.proto.CommandEndTxn endTxn = 56;
inline bool BaseCommand::has_endtxn() const {
  bool value = (_impl_._has_bits_[1] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endtxn_ != nullptr);
  return value;
}
inline void BaseCommand::clear_endtxn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.endtxn_ != nullptr) _impl_.endtxn_->Clear();
  _impl_._has_bits_[1] &= ~0x00002000u;
}
inline const ::pulsar::proto::CommandEndTxn& BaseCommand::_internal_endtxn() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandEndTxn* p = _impl_.endtxn_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandEndTxn&>(::pulsar::proto::_CommandEndTxn_default_instance_);
}
inline const ::pulsar::proto::CommandEndTxn& BaseCommand::endtxn() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.endTxn)
  return _internal_endtxn();
}
inline void BaseCommand::unsafe_arena_set_allocated_endtxn(::pulsar::proto::CommandEndTxn* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.endtxn_);
  }
  _impl_.endtxn_ = reinterpret_cast<::pulsar::proto::CommandEndTxn*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00002000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.endTxn)
}
inline ::pulsar::proto::CommandEndTxn* BaseCommand::release_endtxn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00002000u;
  ::pulsar::proto::CommandEndTxn* released = _impl_.endtxn_;
  _impl_.endtxn_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandEndTxn* BaseCommand::unsafe_arena_release_endtxn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.endTxn)

  _impl_._has_bits_[1] &= ~0x00002000u;
  ::pulsar::proto::CommandEndTxn* temp = _impl_.endtxn_;
  _impl_.endtxn_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandEndTxn* BaseCommand::_internal_mutable_endtxn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00002000u;
  if (_impl_.endtxn_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandEndTxn>(GetArena());
    _impl_.endtxn_ = reinterpret_cast<::pulsar::proto::CommandEndTxn*>(p);
  }
  return _impl_.endtxn_;
}
inline ::pulsar::proto::CommandEndTxn* BaseCommand::mutable_endtxn() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandEndTxn* _msg = _internal_mutable_endtxn();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.endTxn)
  return _msg;
}
inline void BaseCommand::set_allocated_endtxn(::pulsar::proto::CommandEndTxn* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandEndTxn*>(_impl_.endtxn_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandEndTxn*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00002000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00002000u;
  }

  _impl_.endtxn_ = reinterpret_cast<::pulsar::proto::CommandEndTxn*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.endTxn)
}

// optional .pulsar.proto.CommandEndTxnResponse endTxnResponse = 57;
inline bool BaseCommand::has_endtxnresponse() const {
  bool value = (_impl_._has_bits_[1] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endtxnresponse_ != nullptr);
  return value;
}
inline void BaseCommand::clear_endtxnresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.endtxnresponse_ != nullptr) _impl_.endtxnresponse_->Clear();
  _impl_._has_bits_[1] &= ~0x00004000u;
}
inline const ::pulsar::proto::CommandEndTxnResponse& BaseCommand::_internal_endtxnresponse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandEndTxnResponse* p = _impl_.endtxnresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandEndTxnResponse&>(::pulsar::proto::_CommandEndTxnResponse_default_instance_);
}
inline const ::pulsar::proto::CommandEndTxnResponse& BaseCommand::endtxnresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.endTxnResponse)
  return _internal_endtxnresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_endtxnresponse(::pulsar::proto::CommandEndTxnResponse* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.endtxnresponse_);
  }
  _impl_.endtxnresponse_ = reinterpret_cast<::pulsar::proto::CommandEndTxnResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00004000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.endTxnResponse)
}
inline ::pulsar::proto::CommandEndTxnResponse* BaseCommand::release_endtxnresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00004000u;
  ::pulsar::proto::CommandEndTxnResponse* released = _impl_.endtxnresponse_;
  _impl_.endtxnresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandEndTxnResponse* BaseCommand::unsafe_arena_release_endtxnresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.endTxnResponse)

  _impl_._has_bits_[1] &= ~0x00004000u;
  ::pulsar::proto::CommandEndTxnResponse* temp = _impl_.endtxnresponse_;
  _impl_.endtxnresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandEndTxnResponse* BaseCommand::_internal_mutable_endtxnresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00004000u;
  if (_impl_.endtxnresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandEndTxnResponse>(GetArena());
    _impl_.endtxnresponse_ = reinterpret_cast<::pulsar::proto::CommandEndTxnResponse*>(p);
  }
  return _impl_.endtxnresponse_;
}
inline ::pulsar::proto::CommandEndTxnResponse* BaseCommand::mutable_endtxnresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandEndTxnResponse* _msg = _internal_mutable_endtxnresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.endTxnResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_endtxnresponse(::pulsar::proto::CommandEndTxnResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandEndTxnResponse*>(_impl_.endtxnresponse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandEndTxnResponse*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00004000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00004000u;
  }

  _impl_.endtxnresponse_ = reinterpret_cast<::pulsar::proto::CommandEndTxnResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.endTxnResponse)
}

// optional .pulsar.proto.CommandEndTxnOnPartition endTxnOnPartition = 58;
inline bool BaseCommand::has_endtxnonpartition() const {
  bool value = (_impl_._has_bits_[1] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endtxnonpartition_ != nullptr);
  return value;
}
inline void BaseCommand::clear_endtxnonpartition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.endtxnonpartition_ != nullptr) _impl_.endtxnonpartition_->Clear();
  _impl_._has_bits_[1] &= ~0x00008000u;
}
inline const ::pulsar::proto::CommandEndTxnOnPartition& BaseCommand::_internal_endtxnonpartition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandEndTxnOnPartition* p = _impl_.endtxnonpartition_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandEndTxnOnPartition&>(::pulsar::proto::_CommandEndTxnOnPartition_default_instance_);
}
inline const ::pulsar::proto::CommandEndTxnOnPartition& BaseCommand::endtxnonpartition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.endTxnOnPartition)
  return _internal_endtxnonpartition();
}
inline void BaseCommand::unsafe_arena_set_allocated_endtxnonpartition(::pulsar::proto::CommandEndTxnOnPartition* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.endtxnonpartition_);
  }
  _impl_.endtxnonpartition_ = reinterpret_cast<::pulsar::proto::CommandEndTxnOnPartition*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00008000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.endTxnOnPartition)
}
inline ::pulsar::proto::CommandEndTxnOnPartition* BaseCommand::release_endtxnonpartition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00008000u;
  ::pulsar::proto::CommandEndTxnOnPartition* released = _impl_.endtxnonpartition_;
  _impl_.endtxnonpartition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandEndTxnOnPartition* BaseCommand::unsafe_arena_release_endtxnonpartition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.endTxnOnPartition)

  _impl_._has_bits_[1] &= ~0x00008000u;
  ::pulsar::proto::CommandEndTxnOnPartition* temp = _impl_.endtxnonpartition_;
  _impl_.endtxnonpartition_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandEndTxnOnPartition* BaseCommand::_internal_mutable_endtxnonpartition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00008000u;
  if (_impl_.endtxnonpartition_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandEndTxnOnPartition>(GetArena());
    _impl_.endtxnonpartition_ = reinterpret_cast<::pulsar::proto::CommandEndTxnOnPartition*>(p);
  }
  return _impl_.endtxnonpartition_;
}
inline ::pulsar::proto::CommandEndTxnOnPartition* BaseCommand::mutable_endtxnonpartition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandEndTxnOnPartition* _msg = _internal_mutable_endtxnonpartition();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.endTxnOnPartition)
  return _msg;
}
inline void BaseCommand::set_allocated_endtxnonpartition(::pulsar::proto::CommandEndTxnOnPartition* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandEndTxnOnPartition*>(_impl_.endtxnonpartition_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandEndTxnOnPartition*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00008000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00008000u;
  }

  _impl_.endtxnonpartition_ = reinterpret_cast<::pulsar::proto::CommandEndTxnOnPartition*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.endTxnOnPartition)
}

// optional .pulsar.proto.CommandEndTxnOnPartitionResponse endTxnOnPartitionResponse = 59;
inline bool BaseCommand::has_endtxnonpartitionresponse() const {
  bool value = (_impl_._has_bits_[1] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endtxnonpartitionresponse_ != nullptr);
  return value;
}
inline void BaseCommand::clear_endtxnonpartitionresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.endtxnonpartitionresponse_ != nullptr) _impl_.endtxnonpartitionresponse_->Clear();
  _impl_._has_bits_[1] &= ~0x00010000u;
}
inline const ::pulsar::proto::CommandEndTxnOnPartitionResponse& BaseCommand::_internal_endtxnonpartitionresponse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandEndTxnOnPartitionResponse* p = _impl_.endtxnonpartitionresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandEndTxnOnPartitionResponse&>(::pulsar::proto::_CommandEndTxnOnPartitionResponse_default_instance_);
}
inline const ::pulsar::proto::CommandEndTxnOnPartitionResponse& BaseCommand::endtxnonpartitionresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.endTxnOnPartitionResponse)
  return _internal_endtxnonpartitionresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_endtxnonpartitionresponse(::pulsar::proto::CommandEndTxnOnPartitionResponse* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.endtxnonpartitionresponse_);
  }
  _impl_.endtxnonpartitionresponse_ = reinterpret_cast<::pulsar::proto::CommandEndTxnOnPartitionResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00010000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.endTxnOnPartitionResponse)
}
inline ::pulsar::proto::CommandEndTxnOnPartitionResponse* BaseCommand::release_endtxnonpartitionresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00010000u;
  ::pulsar::proto::CommandEndTxnOnPartitionResponse* released = _impl_.endtxnonpartitionresponse_;
  _impl_.endtxnonpartitionresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandEndTxnOnPartitionResponse* BaseCommand::unsafe_arena_release_endtxnonpartitionresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.endTxnOnPartitionResponse)

  _impl_._has_bits_[1] &= ~0x00010000u;
  ::pulsar::proto::CommandEndTxnOnPartitionResponse* temp = _impl_.endtxnonpartitionresponse_;
  _impl_.endtxnonpartitionresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandEndTxnOnPartitionResponse* BaseCommand::_internal_mutable_endtxnonpartitionresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00010000u;
  if (_impl_.endtxnonpartitionresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandEndTxnOnPartitionResponse>(GetArena());
    _impl_.endtxnonpartitionresponse_ = reinterpret_cast<::pulsar::proto::CommandEndTxnOnPartitionResponse*>(p);
  }
  return _impl_.endtxnonpartitionresponse_;
}
inline ::pulsar::proto::CommandEndTxnOnPartitionResponse* BaseCommand::mutable_endtxnonpartitionresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandEndTxnOnPartitionResponse* _msg = _internal_mutable_endtxnonpartitionresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.endTxnOnPartitionResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_endtxnonpartitionresponse(::pulsar::proto::CommandEndTxnOnPartitionResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandEndTxnOnPartitionResponse*>(_impl_.endtxnonpartitionresponse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandEndTxnOnPartitionResponse*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00010000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00010000u;
  }

  _impl_.endtxnonpartitionresponse_ = reinterpret_cast<::pulsar::proto::CommandEndTxnOnPartitionResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.endTxnOnPartitionResponse)
}

// optional .pulsar.proto.CommandEndTxnOnSubscription endTxnOnSubscription = 60;
inline bool BaseCommand::has_endtxnonsubscription() const {
  bool value = (_impl_._has_bits_[1] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endtxnonsubscription_ != nullptr);
  return value;
}
inline void BaseCommand::clear_endtxnonsubscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.endtxnonsubscription_ != nullptr) _impl_.endtxnonsubscription_->Clear();
  _impl_._has_bits_[1] &= ~0x00020000u;
}
inline const ::pulsar::proto::CommandEndTxnOnSubscription& BaseCommand::_internal_endtxnonsubscription() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandEndTxnOnSubscription* p = _impl_.endtxnonsubscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandEndTxnOnSubscription&>(::pulsar::proto::_CommandEndTxnOnSubscription_default_instance_);
}
inline const ::pulsar::proto::CommandEndTxnOnSubscription& BaseCommand::endtxnonsubscription() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.endTxnOnSubscription)
  return _internal_endtxnonsubscription();
}
inline void BaseCommand::unsafe_arena_set_allocated_endtxnonsubscription(::pulsar::proto::CommandEndTxnOnSubscription* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.endtxnonsubscription_);
  }
  _impl_.endtxnonsubscription_ = reinterpret_cast<::pulsar::proto::CommandEndTxnOnSubscription*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00020000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.endTxnOnSubscription)
}
inline ::pulsar::proto::CommandEndTxnOnSubscription* BaseCommand::release_endtxnonsubscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00020000u;
  ::pulsar::proto::CommandEndTxnOnSubscription* released = _impl_.endtxnonsubscription_;
  _impl_.endtxnonsubscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandEndTxnOnSubscription* BaseCommand::unsafe_arena_release_endtxnonsubscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.endTxnOnSubscription)

  _impl_._has_bits_[1] &= ~0x00020000u;
  ::pulsar::proto::CommandEndTxnOnSubscription* temp = _impl_.endtxnonsubscription_;
  _impl_.endtxnonsubscription_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandEndTxnOnSubscription* BaseCommand::_internal_mutable_endtxnonsubscription() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00020000u;
  if (_impl_.endtxnonsubscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandEndTxnOnSubscription>(GetArena());
    _impl_.endtxnonsubscription_ = reinterpret_cast<::pulsar::proto::CommandEndTxnOnSubscription*>(p);
  }
  return _impl_.endtxnonsubscription_;
}
inline ::pulsar::proto::CommandEndTxnOnSubscription* BaseCommand::mutable_endtxnonsubscription() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandEndTxnOnSubscription* _msg = _internal_mutable_endtxnonsubscription();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.endTxnOnSubscription)
  return _msg;
}
inline void BaseCommand::set_allocated_endtxnonsubscription(::pulsar::proto::CommandEndTxnOnSubscription* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandEndTxnOnSubscription*>(_impl_.endtxnonsubscription_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandEndTxnOnSubscription*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00020000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00020000u;
  }

  _impl_.endtxnonsubscription_ = reinterpret_cast<::pulsar::proto::CommandEndTxnOnSubscription*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.endTxnOnSubscription)
}

// optional .pulsar.proto.CommandEndTxnOnSubscriptionResponse endTxnOnSubscriptionResponse = 61;
inline bool BaseCommand::has_endtxnonsubscriptionresponse() const {
  bool value = (_impl_._has_bits_[1] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endtxnonsubscriptionresponse_ != nullptr);
  return value;
}
inline void BaseCommand::clear_endtxnonsubscriptionresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.endtxnonsubscriptionresponse_ != nullptr) _impl_.endtxnonsubscriptionresponse_->Clear();
  _impl_._has_bits_[1] &= ~0x00040000u;
}
inline const ::pulsar::proto::CommandEndTxnOnSubscriptionResponse& BaseCommand::_internal_endtxnonsubscriptionresponse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* p = _impl_.endtxnonsubscriptionresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandEndTxnOnSubscriptionResponse&>(::pulsar::proto::_CommandEndTxnOnSubscriptionResponse_default_instance_);
}
inline const ::pulsar::proto::CommandEndTxnOnSubscriptionResponse& BaseCommand::endtxnonsubscriptionresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.endTxnOnSubscriptionResponse)
  return _internal_endtxnonsubscriptionresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_endtxnonsubscriptionresponse(::pulsar::proto::CommandEndTxnOnSubscriptionResponse* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.endtxnonsubscriptionresponse_);
  }
  _impl_.endtxnonsubscriptionresponse_ = reinterpret_cast<::pulsar::proto::CommandEndTxnOnSubscriptionResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00040000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.endTxnOnSubscriptionResponse)
}
inline ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* BaseCommand::release_endtxnonsubscriptionresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00040000u;
  ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* released = _impl_.endtxnonsubscriptionresponse_;
  _impl_.endtxnonsubscriptionresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* BaseCommand::unsafe_arena_release_endtxnonsubscriptionresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.endTxnOnSubscriptionResponse)

  _impl_._has_bits_[1] &= ~0x00040000u;
  ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* temp = _impl_.endtxnonsubscriptionresponse_;
  _impl_.endtxnonsubscriptionresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* BaseCommand::_internal_mutable_endtxnonsubscriptionresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00040000u;
  if (_impl_.endtxnonsubscriptionresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandEndTxnOnSubscriptionResponse>(GetArena());
    _impl_.endtxnonsubscriptionresponse_ = reinterpret_cast<::pulsar::proto::CommandEndTxnOnSubscriptionResponse*>(p);
  }
  return _impl_.endtxnonsubscriptionresponse_;
}
inline ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* BaseCommand::mutable_endtxnonsubscriptionresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandEndTxnOnSubscriptionResponse* _msg = _internal_mutable_endtxnonsubscriptionresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.endTxnOnSubscriptionResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_endtxnonsubscriptionresponse(::pulsar::proto::CommandEndTxnOnSubscriptionResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandEndTxnOnSubscriptionResponse*>(_impl_.endtxnonsubscriptionresponse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandEndTxnOnSubscriptionResponse*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00040000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00040000u;
  }

  _impl_.endtxnonsubscriptionresponse_ = reinterpret_cast<::pulsar::proto::CommandEndTxnOnSubscriptionResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.endTxnOnSubscriptionResponse)
}

// optional .pulsar.proto.CommandTcClientConnectRequest tcClientConnectRequest = 62;
inline bool BaseCommand::has_tcclientconnectrequest() const {
  bool value = (_impl_._has_bits_[1] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tcclientconnectrequest_ != nullptr);
  return value;
}
inline void BaseCommand::clear_tcclientconnectrequest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tcclientconnectrequest_ != nullptr) _impl_.tcclientconnectrequest_->Clear();
  _impl_._has_bits_[1] &= ~0x00080000u;
}
inline const ::pulsar::proto::CommandTcClientConnectRequest& BaseCommand::_internal_tcclientconnectrequest() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandTcClientConnectRequest* p = _impl_.tcclientconnectrequest_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandTcClientConnectRequest&>(::pulsar::proto::_CommandTcClientConnectRequest_default_instance_);
}
inline const ::pulsar::proto::CommandTcClientConnectRequest& BaseCommand::tcclientconnectrequest() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.tcClientConnectRequest)
  return _internal_tcclientconnectrequest();
}
inline void BaseCommand::unsafe_arena_set_allocated_tcclientconnectrequest(::pulsar::proto::CommandTcClientConnectRequest* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tcclientconnectrequest_);
  }
  _impl_.tcclientconnectrequest_ = reinterpret_cast<::pulsar::proto::CommandTcClientConnectRequest*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00080000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.tcClientConnectRequest)
}
inline ::pulsar::proto::CommandTcClientConnectRequest* BaseCommand::release_tcclientconnectrequest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00080000u;
  ::pulsar::proto::CommandTcClientConnectRequest* released = _impl_.tcclientconnectrequest_;
  _impl_.tcclientconnectrequest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandTcClientConnectRequest* BaseCommand::unsafe_arena_release_tcclientconnectrequest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.tcClientConnectRequest)

  _impl_._has_bits_[1] &= ~0x00080000u;
  ::pulsar::proto::CommandTcClientConnectRequest* temp = _impl_.tcclientconnectrequest_;
  _impl_.tcclientconnectrequest_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandTcClientConnectRequest* BaseCommand::_internal_mutable_tcclientconnectrequest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00080000u;
  if (_impl_.tcclientconnectrequest_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandTcClientConnectRequest>(GetArena());
    _impl_.tcclientconnectrequest_ = reinterpret_cast<::pulsar::proto::CommandTcClientConnectRequest*>(p);
  }
  return _impl_.tcclientconnectrequest_;
}
inline ::pulsar::proto::CommandTcClientConnectRequest* BaseCommand::mutable_tcclientconnectrequest() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandTcClientConnectRequest* _msg = _internal_mutable_tcclientconnectrequest();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.tcClientConnectRequest)
  return _msg;
}
inline void BaseCommand::set_allocated_tcclientconnectrequest(::pulsar::proto::CommandTcClientConnectRequest* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandTcClientConnectRequest*>(_impl_.tcclientconnectrequest_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandTcClientConnectRequest*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00080000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00080000u;
  }

  _impl_.tcclientconnectrequest_ = reinterpret_cast<::pulsar::proto::CommandTcClientConnectRequest*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.tcClientConnectRequest)
}

// optional .pulsar.proto.CommandTcClientConnectResponse tcClientConnectResponse = 63;
inline bool BaseCommand::has_tcclientconnectresponse() const {
  bool value = (_impl_._has_bits_[1] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tcclientconnectresponse_ != nullptr);
  return value;
}
inline void BaseCommand::clear_tcclientconnectresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tcclientconnectresponse_ != nullptr) _impl_.tcclientconnectresponse_->Clear();
  _impl_._has_bits_[1] &= ~0x00100000u;
}
inline const ::pulsar::proto::CommandTcClientConnectResponse& BaseCommand::_internal_tcclientconnectresponse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandTcClientConnectResponse* p = _impl_.tcclientconnectresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandTcClientConnectResponse&>(::pulsar::proto::_CommandTcClientConnectResponse_default_instance_);
}
inline const ::pulsar::proto::CommandTcClientConnectResponse& BaseCommand::tcclientconnectresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.tcClientConnectResponse)
  return _internal_tcclientconnectresponse();
}
inline void BaseCommand::unsafe_arena_set_allocated_tcclientconnectresponse(::pulsar::proto::CommandTcClientConnectResponse* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tcclientconnectresponse_);
  }
  _impl_.tcclientconnectresponse_ = reinterpret_cast<::pulsar::proto::CommandTcClientConnectResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00100000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.tcClientConnectResponse)
}
inline ::pulsar::proto::CommandTcClientConnectResponse* BaseCommand::release_tcclientconnectresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00100000u;
  ::pulsar::proto::CommandTcClientConnectResponse* released = _impl_.tcclientconnectresponse_;
  _impl_.tcclientconnectresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandTcClientConnectResponse* BaseCommand::unsafe_arena_release_tcclientconnectresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.tcClientConnectResponse)

  _impl_._has_bits_[1] &= ~0x00100000u;
  ::pulsar::proto::CommandTcClientConnectResponse* temp = _impl_.tcclientconnectresponse_;
  _impl_.tcclientconnectresponse_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandTcClientConnectResponse* BaseCommand::_internal_mutable_tcclientconnectresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00100000u;
  if (_impl_.tcclientconnectresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandTcClientConnectResponse>(GetArena());
    _impl_.tcclientconnectresponse_ = reinterpret_cast<::pulsar::proto::CommandTcClientConnectResponse*>(p);
  }
  return _impl_.tcclientconnectresponse_;
}
inline ::pulsar::proto::CommandTcClientConnectResponse* BaseCommand::mutable_tcclientconnectresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandTcClientConnectResponse* _msg = _internal_mutable_tcclientconnectresponse();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.tcClientConnectResponse)
  return _msg;
}
inline void BaseCommand::set_allocated_tcclientconnectresponse(::pulsar::proto::CommandTcClientConnectResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandTcClientConnectResponse*>(_impl_.tcclientconnectresponse_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandTcClientConnectResponse*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00100000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00100000u;
  }

  _impl_.tcclientconnectresponse_ = reinterpret_cast<::pulsar::proto::CommandTcClientConnectResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.tcClientConnectResponse)
}

// optional .pulsar.proto.CommandWatchTopicList watchTopicList = 64;
inline bool BaseCommand::has_watchtopiclist() const {
  bool value = (_impl_._has_bits_[1] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.watchtopiclist_ != nullptr);
  return value;
}
inline void BaseCommand::clear_watchtopiclist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.watchtopiclist_ != nullptr) _impl_.watchtopiclist_->Clear();
  _impl_._has_bits_[1] &= ~0x00200000u;
}
inline const ::pulsar::proto::CommandWatchTopicList& BaseCommand::_internal_watchtopiclist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandWatchTopicList* p = _impl_.watchtopiclist_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandWatchTopicList&>(::pulsar::proto::_CommandWatchTopicList_default_instance_);
}
inline const ::pulsar::proto::CommandWatchTopicList& BaseCommand::watchtopiclist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.watchTopicList)
  return _internal_watchtopiclist();
}
inline void BaseCommand::unsafe_arena_set_allocated_watchtopiclist(::pulsar::proto::CommandWatchTopicList* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.watchtopiclist_);
  }
  _impl_.watchtopiclist_ = reinterpret_cast<::pulsar::proto::CommandWatchTopicList*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00200000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.watchTopicList)
}
inline ::pulsar::proto::CommandWatchTopicList* BaseCommand::release_watchtopiclist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00200000u;
  ::pulsar::proto::CommandWatchTopicList* released = _impl_.watchtopiclist_;
  _impl_.watchtopiclist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandWatchTopicList* BaseCommand::unsafe_arena_release_watchtopiclist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.watchTopicList)

  _impl_._has_bits_[1] &= ~0x00200000u;
  ::pulsar::proto::CommandWatchTopicList* temp = _impl_.watchtopiclist_;
  _impl_.watchtopiclist_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandWatchTopicList* BaseCommand::_internal_mutable_watchtopiclist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00200000u;
  if (_impl_.watchtopiclist_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandWatchTopicList>(GetArena());
    _impl_.watchtopiclist_ = reinterpret_cast<::pulsar::proto::CommandWatchTopicList*>(p);
  }
  return _impl_.watchtopiclist_;
}
inline ::pulsar::proto::CommandWatchTopicList* BaseCommand::mutable_watchtopiclist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandWatchTopicList* _msg = _internal_mutable_watchtopiclist();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.watchTopicList)
  return _msg;
}
inline void BaseCommand::set_allocated_watchtopiclist(::pulsar::proto::CommandWatchTopicList* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandWatchTopicList*>(_impl_.watchtopiclist_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandWatchTopicList*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00200000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00200000u;
  }

  _impl_.watchtopiclist_ = reinterpret_cast<::pulsar::proto::CommandWatchTopicList*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.watchTopicList)
}

// optional .pulsar.proto.CommandWatchTopicListSuccess watchTopicListSuccess = 65;
inline bool BaseCommand::has_watchtopiclistsuccess() const {
  bool value = (_impl_._has_bits_[1] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.watchtopiclistsuccess_ != nullptr);
  return value;
}
inline void BaseCommand::clear_watchtopiclistsuccess() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.watchtopiclistsuccess_ != nullptr) _impl_.watchtopiclistsuccess_->Clear();
  _impl_._has_bits_[1] &= ~0x00400000u;
}
inline const ::pulsar::proto::CommandWatchTopicListSuccess& BaseCommand::_internal_watchtopiclistsuccess() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandWatchTopicListSuccess* p = _impl_.watchtopiclistsuccess_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandWatchTopicListSuccess&>(::pulsar::proto::_CommandWatchTopicListSuccess_default_instance_);
}
inline const ::pulsar::proto::CommandWatchTopicListSuccess& BaseCommand::watchtopiclistsuccess() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.watchTopicListSuccess)
  return _internal_watchtopiclistsuccess();
}
inline void BaseCommand::unsafe_arena_set_allocated_watchtopiclistsuccess(::pulsar::proto::CommandWatchTopicListSuccess* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.watchtopiclistsuccess_);
  }
  _impl_.watchtopiclistsuccess_ = reinterpret_cast<::pulsar::proto::CommandWatchTopicListSuccess*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00400000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.watchTopicListSuccess)
}
inline ::pulsar::proto::CommandWatchTopicListSuccess* BaseCommand::release_watchtopiclistsuccess() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00400000u;
  ::pulsar::proto::CommandWatchTopicListSuccess* released = _impl_.watchtopiclistsuccess_;
  _impl_.watchtopiclistsuccess_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandWatchTopicListSuccess* BaseCommand::unsafe_arena_release_watchtopiclistsuccess() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.watchTopicListSuccess)

  _impl_._has_bits_[1] &= ~0x00400000u;
  ::pulsar::proto::CommandWatchTopicListSuccess* temp = _impl_.watchtopiclistsuccess_;
  _impl_.watchtopiclistsuccess_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandWatchTopicListSuccess* BaseCommand::_internal_mutable_watchtopiclistsuccess() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00400000u;
  if (_impl_.watchtopiclistsuccess_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandWatchTopicListSuccess>(GetArena());
    _impl_.watchtopiclistsuccess_ = reinterpret_cast<::pulsar::proto::CommandWatchTopicListSuccess*>(p);
  }
  return _impl_.watchtopiclistsuccess_;
}
inline ::pulsar::proto::CommandWatchTopicListSuccess* BaseCommand::mutable_watchtopiclistsuccess() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandWatchTopicListSuccess* _msg = _internal_mutable_watchtopiclistsuccess();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.watchTopicListSuccess)
  return _msg;
}
inline void BaseCommand::set_allocated_watchtopiclistsuccess(::pulsar::proto::CommandWatchTopicListSuccess* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandWatchTopicListSuccess*>(_impl_.watchtopiclistsuccess_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandWatchTopicListSuccess*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00400000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00400000u;
  }

  _impl_.watchtopiclistsuccess_ = reinterpret_cast<::pulsar::proto::CommandWatchTopicListSuccess*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.watchTopicListSuccess)
}

// optional .pulsar.proto.CommandWatchTopicUpdate watchTopicUpdate = 66;
inline bool BaseCommand::has_watchtopicupdate() const {
  bool value = (_impl_._has_bits_[1] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.watchtopicupdate_ != nullptr);
  return value;
}
inline void BaseCommand::clear_watchtopicupdate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.watchtopicupdate_ != nullptr) _impl_.watchtopicupdate_->Clear();
  _impl_._has_bits_[1] &= ~0x00800000u;
}
inline const ::pulsar::proto::CommandWatchTopicUpdate& BaseCommand::_internal_watchtopicupdate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandWatchTopicUpdate* p = _impl_.watchtopicupdate_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandWatchTopicUpdate&>(::pulsar::proto::_CommandWatchTopicUpdate_default_instance_);
}
inline const ::pulsar::proto::CommandWatchTopicUpdate& BaseCommand::watchtopicupdate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.watchTopicUpdate)
  return _internal_watchtopicupdate();
}
inline void BaseCommand::unsafe_arena_set_allocated_watchtopicupdate(::pulsar::proto::CommandWatchTopicUpdate* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.watchtopicupdate_);
  }
  _impl_.watchtopicupdate_ = reinterpret_cast<::pulsar::proto::CommandWatchTopicUpdate*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x00800000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.watchTopicUpdate)
}
inline ::pulsar::proto::CommandWatchTopicUpdate* BaseCommand::release_watchtopicupdate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x00800000u;
  ::pulsar::proto::CommandWatchTopicUpdate* released = _impl_.watchtopicupdate_;
  _impl_.watchtopicupdate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandWatchTopicUpdate* BaseCommand::unsafe_arena_release_watchtopicupdate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.watchTopicUpdate)

  _impl_._has_bits_[1] &= ~0x00800000u;
  ::pulsar::proto::CommandWatchTopicUpdate* temp = _impl_.watchtopicupdate_;
  _impl_.watchtopicupdate_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandWatchTopicUpdate* BaseCommand::_internal_mutable_watchtopicupdate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x00800000u;
  if (_impl_.watchtopicupdate_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandWatchTopicUpdate>(GetArena());
    _impl_.watchtopicupdate_ = reinterpret_cast<::pulsar::proto::CommandWatchTopicUpdate*>(p);
  }
  return _impl_.watchtopicupdate_;
}
inline ::pulsar::proto::CommandWatchTopicUpdate* BaseCommand::mutable_watchtopicupdate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandWatchTopicUpdate* _msg = _internal_mutable_watchtopicupdate();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.watchTopicUpdate)
  return _msg;
}
inline void BaseCommand::set_allocated_watchtopicupdate(::pulsar::proto::CommandWatchTopicUpdate* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandWatchTopicUpdate*>(_impl_.watchtopicupdate_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandWatchTopicUpdate*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x00800000u;
  } else {
    _impl_._has_bits_[1] &= ~0x00800000u;
  }

  _impl_.watchtopicupdate_ = reinterpret_cast<::pulsar::proto::CommandWatchTopicUpdate*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.watchTopicUpdate)
}

// optional .pulsar.proto.CommandWatchTopicListClose watchTopicListClose = 67;
inline bool BaseCommand::has_watchtopiclistclose() const {
  bool value = (_impl_._has_bits_[1] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.watchtopiclistclose_ != nullptr);
  return value;
}
inline void BaseCommand::clear_watchtopiclistclose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.watchtopiclistclose_ != nullptr) _impl_.watchtopiclistclose_->Clear();
  _impl_._has_bits_[1] &= ~0x01000000u;
}
inline const ::pulsar::proto::CommandWatchTopicListClose& BaseCommand::_internal_watchtopiclistclose() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandWatchTopicListClose* p = _impl_.watchtopiclistclose_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandWatchTopicListClose&>(::pulsar::proto::_CommandWatchTopicListClose_default_instance_);
}
inline const ::pulsar::proto::CommandWatchTopicListClose& BaseCommand::watchtopiclistclose() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.watchTopicListClose)
  return _internal_watchtopiclistclose();
}
inline void BaseCommand::unsafe_arena_set_allocated_watchtopiclistclose(::pulsar::proto::CommandWatchTopicListClose* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.watchtopiclistclose_);
  }
  _impl_.watchtopiclistclose_ = reinterpret_cast<::pulsar::proto::CommandWatchTopicListClose*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x01000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.watchTopicListClose)
}
inline ::pulsar::proto::CommandWatchTopicListClose* BaseCommand::release_watchtopiclistclose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x01000000u;
  ::pulsar::proto::CommandWatchTopicListClose* released = _impl_.watchtopiclistclose_;
  _impl_.watchtopiclistclose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandWatchTopicListClose* BaseCommand::unsafe_arena_release_watchtopiclistclose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.watchTopicListClose)

  _impl_._has_bits_[1] &= ~0x01000000u;
  ::pulsar::proto::CommandWatchTopicListClose* temp = _impl_.watchtopiclistclose_;
  _impl_.watchtopiclistclose_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandWatchTopicListClose* BaseCommand::_internal_mutable_watchtopiclistclose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x01000000u;
  if (_impl_.watchtopiclistclose_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandWatchTopicListClose>(GetArena());
    _impl_.watchtopiclistclose_ = reinterpret_cast<::pulsar::proto::CommandWatchTopicListClose*>(p);
  }
  return _impl_.watchtopiclistclose_;
}
inline ::pulsar::proto::CommandWatchTopicListClose* BaseCommand::mutable_watchtopiclistclose() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandWatchTopicListClose* _msg = _internal_mutable_watchtopiclistclose();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.watchTopicListClose)
  return _msg;
}
inline void BaseCommand::set_allocated_watchtopiclistclose(::pulsar::proto::CommandWatchTopicListClose* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandWatchTopicListClose*>(_impl_.watchtopiclistclose_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandWatchTopicListClose*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x01000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x01000000u;
  }

  _impl_.watchtopiclistclose_ = reinterpret_cast<::pulsar::proto::CommandWatchTopicListClose*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.watchTopicListClose)
}

// optional .pulsar.proto.CommandTopicMigrated topicMigrated = 68;
inline bool BaseCommand::has_topicmigrated() const {
  bool value = (_impl_._has_bits_[1] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.topicmigrated_ != nullptr);
  return value;
}
inline void BaseCommand::clear_topicmigrated() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.topicmigrated_ != nullptr) _impl_.topicmigrated_->Clear();
  _impl_._has_bits_[1] &= ~0x02000000u;
}
inline const ::pulsar::proto::CommandTopicMigrated& BaseCommand::_internal_topicmigrated() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pulsar::proto::CommandTopicMigrated* p = _impl_.topicmigrated_;
  return p != nullptr ? *p : reinterpret_cast<const ::pulsar::proto::CommandTopicMigrated&>(::pulsar::proto::_CommandTopicMigrated_default_instance_);
}
inline const ::pulsar::proto::CommandTopicMigrated& BaseCommand::topicmigrated() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:pulsar.proto.BaseCommand.topicMigrated)
  return _internal_topicmigrated();
}
inline void BaseCommand::unsafe_arena_set_allocated_topicmigrated(::pulsar::proto::CommandTopicMigrated* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.topicmigrated_);
  }
  _impl_.topicmigrated_ = reinterpret_cast<::pulsar::proto::CommandTopicMigrated*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[1] |= 0x02000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pulsar.proto.BaseCommand.topicMigrated)
}
inline ::pulsar::proto::CommandTopicMigrated* BaseCommand::release_topicmigrated() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[1] &= ~0x02000000u;
  ::pulsar::proto::CommandTopicMigrated* released = _impl_.topicmigrated_;
  _impl_.topicmigrated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pulsar::proto::CommandTopicMigrated* BaseCommand::unsafe_arena_release_topicmigrated() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pulsar.proto.BaseCommand.topicMigrated)

  _impl_._has_bits_[1] &= ~0x02000000u;
  ::pulsar::proto::CommandTopicMigrated* temp = _impl_.topicmigrated_;
  _impl_.topicmigrated_ = nullptr;
  return temp;
}
inline ::pulsar::proto::CommandTopicMigrated* BaseCommand::_internal_mutable_topicmigrated() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[1] |= 0x02000000u;
  if (_impl_.topicmigrated_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulsar::proto::CommandTopicMigrated>(GetArena());
    _impl_.topicmigrated_ = reinterpret_cast<::pulsar::proto::CommandTopicMigrated*>(p);
  }
  return _impl_.topicmigrated_;
}
inline ::pulsar::proto::CommandTopicMigrated* BaseCommand::mutable_topicmigrated() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::pulsar::proto::CommandTopicMigrated* _msg = _internal_mutable_topicmigrated();
  // @@protoc_insertion_point(field_mutable:pulsar.proto.BaseCommand.topicMigrated)
  return _msg;
}
inline void BaseCommand::set_allocated_topicmigrated(::pulsar::proto::CommandTopicMigrated* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::pulsar::proto::CommandTopicMigrated*>(_impl_.topicmigrated_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::pulsar::proto::CommandTopicMigrated*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[1] |= 0x02000000u;
  } else {
    _impl_._has_bits_[1] &= ~0x02000000u;
  }

  _impl_.topicmigrated_ = reinterpret_cast<::pulsar::proto::CommandTopicMigrated*>(value);
  // @@protoc_insertion_point(field_set_allocated:pulsar.proto.BaseCommand.topicMigrated)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace pulsar


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::pulsar::proto::Schema_Type> : std::true_type {};
template <>
struct is_proto_enum<::pulsar::proto::CommandSubscribe_SubType> : std::true_type {};
template <>
struct is_proto_enum<::pulsar::proto::CommandSubscribe_InitialPosition> : std::true_type {};
template <>
struct is_proto_enum<::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType> : std::true_type {};
template <>
struct is_proto_enum<::pulsar::proto::CommandLookupTopicResponse_LookupType> : std::true_type {};
template <>
struct is_proto_enum<::pulsar::proto::CommandAck_AckType> : std::true_type {};
template <>
struct is_proto_enum<::pulsar::proto::CommandAck_ValidationError> : std::true_type {};
template <>
struct is_proto_enum<::pulsar::proto::CommandTopicMigrated_ResourceType> : std::true_type {};
template <>
struct is_proto_enum<::pulsar::proto::CommandGetTopicsOfNamespace_Mode> : std::true_type {};
template <>
struct is_proto_enum<::pulsar::proto::BaseCommand_Type> : std::true_type {};
template <>
struct is_proto_enum<::pulsar::proto::CompressionType> : std::true_type {};
template <>
struct is_proto_enum<::pulsar::proto::ProducerAccessMode> : std::true_type {};
template <>
struct is_proto_enum<::pulsar::proto::ServerError> : std::true_type {};
template <>
struct is_proto_enum<::pulsar::proto::AuthMethod> : std::true_type {};
template <>
struct is_proto_enum<::pulsar::proto::ProtocolVersion> : std::true_type {};
template <>
struct is_proto_enum<::pulsar::proto::KeySharedMode> : std::true_type {};
template <>
struct is_proto_enum<::pulsar::proto::TxnAction> : std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_PulsarApi_2eproto_2epb_2eh
