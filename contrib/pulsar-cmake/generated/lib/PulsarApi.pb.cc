// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PulsarApi.proto

#include "PulsarApi.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/io/zero_copy_stream_impl_lite.h"
#include "google/protobuf/generated_message_tctable_impl.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace pulsar {
namespace proto {

inline constexpr Subscription::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        topic_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        subscription_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR Subscription::Subscription(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct SubscriptionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubscriptionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubscriptionDefaultTypeInternal() {}
  union {
    Subscription _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubscriptionDefaultTypeInternal _Subscription_default_instance_;

inline constexpr MessageIdData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        ack_set_{},
        first_chunk_message_id_{nullptr},
        ledgerid_{::uint64_t{0u}},
        entryid_{::uint64_t{0u}},
        batch_size_{0},
        partition_{-1},
        batch_index_{-1} {}

template <typename>
PROTOBUF_CONSTEXPR MessageIdData::MessageIdData(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct MessageIdDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageIdDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageIdDataDefaultTypeInternal() {}
  union {
    MessageIdData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageIdDataDefaultTypeInternal _MessageIdData_default_instance_;

inline constexpr KeyValue::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        value_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR KeyValue::KeyValue(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct KeyValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyValueDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyValueDefaultTypeInternal() {}
  union {
    KeyValue _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyValueDefaultTypeInternal _KeyValue_default_instance_;

inline constexpr KeyLongValue::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        value_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR KeyLongValue::KeyLongValue(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct KeyLongValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyLongValueDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyLongValueDefaultTypeInternal() {}
  union {
    KeyLongValue _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyLongValueDefaultTypeInternal _KeyLongValue_default_instance_;

inline constexpr IntRange::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        start_{0},
        end_{0} {}

template <typename>
PROTOBUF_CONSTEXPR IntRange::IntRange(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct IntRangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IntRangeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IntRangeDefaultTypeInternal() {}
  union {
    IntRange _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntRangeDefaultTypeInternal _IntRange_default_instance_;

inline constexpr FeatureFlags::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        supports_auth_refresh_{false},
        supports_broker_entry_metadata_{false},
        supports_partial_producer_{false},
        supports_topic_watchers_{false} {}

template <typename>
PROTOBUF_CONSTEXPR FeatureFlags::FeatureFlags(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct FeatureFlagsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeatureFlagsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeatureFlagsDefaultTypeInternal() {}
  union {
    FeatureFlags _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeatureFlagsDefaultTypeInternal _FeatureFlags_default_instance_;

inline constexpr CommandWatchTopicUpdate::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        new_topics_{},
        deleted_topics_{},
        topics_hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        watcher_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandWatchTopicUpdate::CommandWatchTopicUpdate(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandWatchTopicUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandWatchTopicUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandWatchTopicUpdateDefaultTypeInternal() {}
  union {
    CommandWatchTopicUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandWatchTopicUpdateDefaultTypeInternal _CommandWatchTopicUpdate_default_instance_;

inline constexpr CommandWatchTopicListSuccess::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        topic_{},
        topics_hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        watcher_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandWatchTopicListSuccess::CommandWatchTopicListSuccess(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandWatchTopicListSuccessDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandWatchTopicListSuccessDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandWatchTopicListSuccessDefaultTypeInternal() {}
  union {
    CommandWatchTopicListSuccess _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandWatchTopicListSuccessDefaultTypeInternal _CommandWatchTopicListSuccess_default_instance_;

inline constexpr CommandWatchTopicListClose::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        request_id_{::uint64_t{0u}},
        watcher_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandWatchTopicListClose::CommandWatchTopicListClose(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandWatchTopicListCloseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandWatchTopicListCloseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandWatchTopicListCloseDefaultTypeInternal() {}
  union {
    CommandWatchTopicListClose _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandWatchTopicListCloseDefaultTypeInternal _CommandWatchTopicListClose_default_instance_;

inline constexpr CommandWatchTopicList::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        namespace__(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        topics_pattern_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        topics_hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        watcher_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandWatchTopicList::CommandWatchTopicList(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandWatchTopicListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandWatchTopicListDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandWatchTopicListDefaultTypeInternal() {}
  union {
    CommandWatchTopicList _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandWatchTopicListDefaultTypeInternal _CommandWatchTopicList_default_instance_;

inline constexpr CommandUnsubscribe::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        consumer_id_{::uint64_t{0u}},
        request_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandUnsubscribe::CommandUnsubscribe(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandUnsubscribeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandUnsubscribeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandUnsubscribeDefaultTypeInternal() {}
  union {
    CommandUnsubscribe _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandUnsubscribeDefaultTypeInternal _CommandUnsubscribe_default_instance_;

inline constexpr CommandTopicMigrated::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        brokerserviceurl_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        brokerserviceurltls_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        resource_id_{::uint64_t{0u}},
        resource_type_{static_cast< ::pulsar::proto::CommandTopicMigrated_ResourceType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandTopicMigrated::CommandTopicMigrated(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandTopicMigratedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandTopicMigratedDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandTopicMigratedDefaultTypeInternal() {}
  union {
    CommandTopicMigrated _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandTopicMigratedDefaultTypeInternal _CommandTopicMigrated_default_instance_;

inline constexpr CommandTcClientConnectResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        error_{static_cast< ::pulsar::proto::ServerError >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandTcClientConnectResponse::CommandTcClientConnectResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandTcClientConnectResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandTcClientConnectResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandTcClientConnectResponseDefaultTypeInternal() {}
  union {
    CommandTcClientConnectResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandTcClientConnectResponseDefaultTypeInternal _CommandTcClientConnectResponse_default_instance_;

inline constexpr CommandTcClientConnectRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        request_id_{::uint64_t{0u}},
        tc_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandTcClientConnectRequest::CommandTcClientConnectRequest(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandTcClientConnectRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandTcClientConnectRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandTcClientConnectRequestDefaultTypeInternal() {}
  union {
    CommandTcClientConnectRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandTcClientConnectRequestDefaultTypeInternal _CommandTcClientConnectRequest_default_instance_;

inline constexpr CommandSendError::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        producer_id_{::uint64_t{0u}},
        sequence_id_{::uint64_t{0u}},
        error_{static_cast< ::pulsar::proto::ServerError >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandSendError::CommandSendError(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandSendErrorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSendErrorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSendErrorDefaultTypeInternal() {}
  union {
    CommandSendError _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSendErrorDefaultTypeInternal _CommandSendError_default_instance_;

inline constexpr CommandReachedEndOfTopic::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        consumer_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandReachedEndOfTopic::CommandReachedEndOfTopic(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandReachedEndOfTopicDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandReachedEndOfTopicDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandReachedEndOfTopicDefaultTypeInternal() {}
  union {
    CommandReachedEndOfTopic _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandReachedEndOfTopicDefaultTypeInternal _CommandReachedEndOfTopic_default_instance_;

inline constexpr CommandProducerSuccess::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        producer_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        schema_version_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        topic_epoch_{::uint64_t{0u}},
        producer_ready_{true},
        last_sequence_id_{::int64_t{-1}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandProducerSuccess::CommandProducerSuccess(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandProducerSuccessDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandProducerSuccessDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandProducerSuccessDefaultTypeInternal() {}
  union {
    CommandProducerSuccess _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandProducerSuccessDefaultTypeInternal _CommandProducerSuccess_default_instance_;

inline constexpr CommandPong::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CommandPong::CommandPong(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandPongDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandPongDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandPongDefaultTypeInternal() {}
  union {
    CommandPong _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandPongDefaultTypeInternal _CommandPong_default_instance_;

inline constexpr CommandPing::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CommandPing::CommandPing(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandPingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandPingDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandPingDefaultTypeInternal() {}
  union {
    CommandPing _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandPingDefaultTypeInternal _CommandPing_default_instance_;

inline constexpr CommandPartitionedTopicMetadataResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        partitions_{0u},
        response_{static_cast< ::pulsar::proto::CommandPartitionedTopicMetadataResponse_LookupType >(0)},
        error_{static_cast< ::pulsar::proto::ServerError >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandPartitionedTopicMetadataResponse::CommandPartitionedTopicMetadataResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandPartitionedTopicMetadataResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandPartitionedTopicMetadataResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandPartitionedTopicMetadataResponseDefaultTypeInternal() {}
  union {
    CommandPartitionedTopicMetadataResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandPartitionedTopicMetadataResponseDefaultTypeInternal _CommandPartitionedTopicMetadataResponse_default_instance_;

inline constexpr CommandPartitionedTopicMetadata::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        topic_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        original_principal_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        original_auth_data_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        original_auth_method_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandPartitionedTopicMetadata::CommandPartitionedTopicMetadata(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandPartitionedTopicMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandPartitionedTopicMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandPartitionedTopicMetadataDefaultTypeInternal() {}
  union {
    CommandPartitionedTopicMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandPartitionedTopicMetadataDefaultTypeInternal _CommandPartitionedTopicMetadata_default_instance_;

inline constexpr CommandNewTxnResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        txnid_least_bits_{::uint64_t{0u}},
        txnid_most_bits_{::uint64_t{0u}},
        error_{static_cast< ::pulsar::proto::ServerError >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandNewTxnResponse::CommandNewTxnResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandNewTxnResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandNewTxnResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandNewTxnResponseDefaultTypeInternal() {}
  union {
    CommandNewTxnResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandNewTxnResponseDefaultTypeInternal _CommandNewTxnResponse_default_instance_;

inline constexpr CommandNewTxn::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        request_id_{::uint64_t{0u}},
        txn_ttl_seconds_{::uint64_t{0u}},
        tc_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandNewTxn::CommandNewTxn(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandNewTxnDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandNewTxnDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandNewTxnDefaultTypeInternal() {}
  union {
    CommandNewTxn _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandNewTxnDefaultTypeInternal _CommandNewTxn_default_instance_;

inline constexpr CommandLookupTopicResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        brokerserviceurl_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        brokerserviceurltls_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        response_{static_cast< ::pulsar::proto::CommandLookupTopicResponse_LookupType >(0)},
        error_{static_cast< ::pulsar::proto::ServerError >(0)},
        authoritative_{false},
        proxy_through_service_url_{false} {}

template <typename>
PROTOBUF_CONSTEXPR CommandLookupTopicResponse::CommandLookupTopicResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandLookupTopicResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandLookupTopicResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandLookupTopicResponseDefaultTypeInternal() {}
  union {
    CommandLookupTopicResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandLookupTopicResponseDefaultTypeInternal _CommandLookupTopicResponse_default_instance_;

inline constexpr CommandLookupTopic::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        topic_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        original_principal_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        original_auth_data_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        original_auth_method_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        advertised_listener_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        authoritative_{false} {}

template <typename>
PROTOBUF_CONSTEXPR CommandLookupTopic::CommandLookupTopic(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandLookupTopicDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandLookupTopicDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandLookupTopicDefaultTypeInternal() {}
  union {
    CommandLookupTopic _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandLookupTopicDefaultTypeInternal _CommandLookupTopic_default_instance_;

inline constexpr CommandGetTopicsOfNamespaceResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        topics_{},
        topics_hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        filtered_{false},
        changed_{true} {}

template <typename>
PROTOBUF_CONSTEXPR CommandGetTopicsOfNamespaceResponse::CommandGetTopicsOfNamespaceResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandGetTopicsOfNamespaceResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandGetTopicsOfNamespaceResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandGetTopicsOfNamespaceResponseDefaultTypeInternal() {}
  union {
    CommandGetTopicsOfNamespaceResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandGetTopicsOfNamespaceResponseDefaultTypeInternal _CommandGetTopicsOfNamespaceResponse_default_instance_;

inline constexpr CommandGetTopicsOfNamespace::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        namespace__(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        topics_pattern_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        topics_hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        mode_{static_cast< ::pulsar::proto::CommandGetTopicsOfNamespace_Mode >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandGetTopicsOfNamespace::CommandGetTopicsOfNamespace(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandGetTopicsOfNamespaceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandGetTopicsOfNamespaceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandGetTopicsOfNamespaceDefaultTypeInternal() {}
  union {
    CommandGetTopicsOfNamespace _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandGetTopicsOfNamespaceDefaultTypeInternal _CommandGetTopicsOfNamespace_default_instance_;

inline constexpr CommandGetSchema::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        topic_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        schema_version_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandGetSchema::CommandGetSchema(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandGetSchemaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandGetSchemaDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandGetSchemaDefaultTypeInternal() {}
  union {
    CommandGetSchema _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandGetSchemaDefaultTypeInternal _CommandGetSchema_default_instance_;

inline constexpr CommandGetOrCreateSchemaResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        error_message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        schema_version_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        error_code_{static_cast< ::pulsar::proto::ServerError >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandGetOrCreateSchemaResponse::CommandGetOrCreateSchemaResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandGetOrCreateSchemaResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandGetOrCreateSchemaResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandGetOrCreateSchemaResponseDefaultTypeInternal() {}
  union {
    CommandGetOrCreateSchemaResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandGetOrCreateSchemaResponseDefaultTypeInternal _CommandGetOrCreateSchemaResponse_default_instance_;

inline constexpr CommandGetLastMessageId::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        consumer_id_{::uint64_t{0u}},
        request_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandGetLastMessageId::CommandGetLastMessageId(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandGetLastMessageIdDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandGetLastMessageIdDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandGetLastMessageIdDefaultTypeInternal() {}
  union {
    CommandGetLastMessageId _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandGetLastMessageIdDefaultTypeInternal _CommandGetLastMessageId_default_instance_;

inline constexpr CommandFlow::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        consumer_id_{::uint64_t{0u}},
        messagepermits_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR CommandFlow::CommandFlow(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandFlowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandFlowDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandFlowDefaultTypeInternal() {}
  union {
    CommandFlow _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandFlowDefaultTypeInternal _CommandFlow_default_instance_;

inline constexpr CommandError::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        error_{static_cast< ::pulsar::proto::ServerError >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandError::CommandError(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandErrorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandErrorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandErrorDefaultTypeInternal() {}
  union {
    CommandError _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandErrorDefaultTypeInternal _CommandError_default_instance_;

inline constexpr CommandEndTxnResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        txnid_least_bits_{::uint64_t{0u}},
        txnid_most_bits_{::uint64_t{0u}},
        error_{static_cast< ::pulsar::proto::ServerError >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandEndTxnResponse::CommandEndTxnResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandEndTxnResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandEndTxnResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandEndTxnResponseDefaultTypeInternal() {}
  union {
    CommandEndTxnResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandEndTxnResponseDefaultTypeInternal _CommandEndTxnResponse_default_instance_;

inline constexpr CommandEndTxnOnSubscriptionResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        txnid_least_bits_{::uint64_t{0u}},
        txnid_most_bits_{::uint64_t{0u}},
        error_{static_cast< ::pulsar::proto::ServerError >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandEndTxnOnSubscriptionResponse::CommandEndTxnOnSubscriptionResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandEndTxnOnSubscriptionResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandEndTxnOnSubscriptionResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandEndTxnOnSubscriptionResponseDefaultTypeInternal() {}
  union {
    CommandEndTxnOnSubscriptionResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandEndTxnOnSubscriptionResponseDefaultTypeInternal _CommandEndTxnOnSubscriptionResponse_default_instance_;

inline constexpr CommandEndTxnOnPartitionResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        txnid_least_bits_{::uint64_t{0u}},
        txnid_most_bits_{::uint64_t{0u}},
        error_{static_cast< ::pulsar::proto::ServerError >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandEndTxnOnPartitionResponse::CommandEndTxnOnPartitionResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandEndTxnOnPartitionResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandEndTxnOnPartitionResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandEndTxnOnPartitionResponseDefaultTypeInternal() {}
  union {
    CommandEndTxnOnPartitionResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandEndTxnOnPartitionResponseDefaultTypeInternal _CommandEndTxnOnPartitionResponse_default_instance_;

inline constexpr CommandEndTxnOnPartition::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        topic_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        txnid_least_bits_{::uint64_t{0u}},
        txnid_most_bits_{::uint64_t{0u}},
        txnid_least_bits_of_low_watermark_{::uint64_t{0u}},
        txn_action_{static_cast< ::pulsar::proto::TxnAction >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandEndTxnOnPartition::CommandEndTxnOnPartition(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandEndTxnOnPartitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandEndTxnOnPartitionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandEndTxnOnPartitionDefaultTypeInternal() {}
  union {
    CommandEndTxnOnPartition _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandEndTxnOnPartitionDefaultTypeInternal _CommandEndTxnOnPartition_default_instance_;

inline constexpr CommandEndTxn::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        request_id_{::uint64_t{0u}},
        txnid_least_bits_{::uint64_t{0u}},
        txnid_most_bits_{::uint64_t{0u}},
        txn_action_{static_cast< ::pulsar::proto::TxnAction >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandEndTxn::CommandEndTxn(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandEndTxnDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandEndTxnDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandEndTxnDefaultTypeInternal() {}
  union {
    CommandEndTxn _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandEndTxnDefaultTypeInternal _CommandEndTxn_default_instance_;

inline constexpr CommandConsumerStatsResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        error_message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        consumername_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        address_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        connectedsince_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        type_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        msgrateout_{0},
        msgthroughputout_{0},
        msgrateredeliver_{0},
        error_code_{static_cast< ::pulsar::proto::ServerError >(0)},
        blockedconsumeronunackedmsgs_{false},
        availablepermits_{::uint64_t{0u}},
        unackedmessages_{::uint64_t{0u}},
        msgrateexpired_{0},
        msgbacklog_{::uint64_t{0u}},
        messageackrate_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CommandConsumerStatsResponse::CommandConsumerStatsResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandConsumerStatsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandConsumerStatsResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandConsumerStatsResponseDefaultTypeInternal() {}
  union {
    CommandConsumerStatsResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandConsumerStatsResponseDefaultTypeInternal _CommandConsumerStatsResponse_default_instance_;

inline constexpr CommandConsumerStats::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        request_id_{::uint64_t{0u}},
        consumer_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandConsumerStats::CommandConsumerStats(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandConsumerStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandConsumerStatsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandConsumerStatsDefaultTypeInternal() {}
  union {
    CommandConsumerStats _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandConsumerStatsDefaultTypeInternal _CommandConsumerStats_default_instance_;

inline constexpr CommandCloseProducer::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        assignedbrokerserviceurl_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        assignedbrokerserviceurltls_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        producer_id_{::uint64_t{0u}},
        request_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandCloseProducer::CommandCloseProducer(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandCloseProducerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandCloseProducerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandCloseProducerDefaultTypeInternal() {}
  union {
    CommandCloseProducer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandCloseProducerDefaultTypeInternal _CommandCloseProducer_default_instance_;

inline constexpr CommandCloseConsumer::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        assignedbrokerserviceurl_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        assignedbrokerserviceurltls_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        consumer_id_{::uint64_t{0u}},
        request_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandCloseConsumer::CommandCloseConsumer(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandCloseConsumerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandCloseConsumerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandCloseConsumerDefaultTypeInternal() {}
  union {
    CommandCloseConsumer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandCloseConsumerDefaultTypeInternal _CommandCloseConsumer_default_instance_;

inline constexpr CommandAddSubscriptionToTxnResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        txnid_least_bits_{::uint64_t{0u}},
        txnid_most_bits_{::uint64_t{0u}},
        error_{static_cast< ::pulsar::proto::ServerError >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandAddSubscriptionToTxnResponse::CommandAddSubscriptionToTxnResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandAddSubscriptionToTxnResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandAddSubscriptionToTxnResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandAddSubscriptionToTxnResponseDefaultTypeInternal() {}
  union {
    CommandAddSubscriptionToTxnResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandAddSubscriptionToTxnResponseDefaultTypeInternal _CommandAddSubscriptionToTxnResponse_default_instance_;

inline constexpr CommandAddPartitionToTxnResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        request_id_{::uint64_t{0u}},
        txnid_least_bits_{::uint64_t{0u}},
        txnid_most_bits_{::uint64_t{0u}},
        error_{static_cast< ::pulsar::proto::ServerError >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandAddPartitionToTxnResponse::CommandAddPartitionToTxnResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandAddPartitionToTxnResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandAddPartitionToTxnResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandAddPartitionToTxnResponseDefaultTypeInternal() {}
  union {
    CommandAddPartitionToTxnResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandAddPartitionToTxnResponseDefaultTypeInternal _CommandAddPartitionToTxnResponse_default_instance_;

inline constexpr CommandAddPartitionToTxn::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        partitions_{},
        request_id_{::uint64_t{0u}},
        txnid_least_bits_{::uint64_t{0u}},
        txnid_most_bits_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandAddPartitionToTxn::CommandAddPartitionToTxn(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandAddPartitionToTxnDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandAddPartitionToTxnDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandAddPartitionToTxnDefaultTypeInternal() {}
  union {
    CommandAddPartitionToTxn _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandAddPartitionToTxnDefaultTypeInternal _CommandAddPartitionToTxn_default_instance_;

inline constexpr CommandActiveConsumerChange::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        consumer_id_{::uint64_t{0u}},
        is_active_{false} {}

template <typename>
PROTOBUF_CONSTEXPR CommandActiveConsumerChange::CommandActiveConsumerChange(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandActiveConsumerChangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandActiveConsumerChangeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandActiveConsumerChangeDefaultTypeInternal() {}
  union {
    CommandActiveConsumerChange _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandActiveConsumerChangeDefaultTypeInternal _CommandActiveConsumerChange_default_instance_;

inline constexpr CommandAckResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        consumer_id_{::uint64_t{0u}},
        txnid_least_bits_{::uint64_t{0u}},
        txnid_most_bits_{::uint64_t{0u}},
        request_id_{::uint64_t{0u}},
        error_{static_cast< ::pulsar::proto::ServerError >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandAckResponse::CommandAckResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandAckResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandAckResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandAckResponseDefaultTypeInternal() {}
  union {
    CommandAckResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandAckResponseDefaultTypeInternal _CommandAckResponse_default_instance_;

inline constexpr BrokerEntryMetadata::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        broker_timestamp_{::uint64_t{0u}},
        index_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR BrokerEntryMetadata::BrokerEntryMetadata(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct BrokerEntryMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BrokerEntryMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BrokerEntryMetadataDefaultTypeInternal() {}
  union {
    BrokerEntryMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrokerEntryMetadataDefaultTypeInternal _BrokerEntryMetadata_default_instance_;

inline constexpr AuthData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        auth_method_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        auth_data_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR AuthData::AuthData(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct AuthDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthDataDefaultTypeInternal() {}
  union {
    AuthData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthDataDefaultTypeInternal _AuthData_default_instance_;

inline constexpr SingleMessageMetadata::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        properties_{},
        partition_key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        ordering_key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        event_time_{::uint64_t{0u}},
        payload_size_{0},
        compacted_out_{false},
        partition_key_b64_encoded_{false},
        null_value_{false},
        null_partition_key_{false},
        sequence_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR SingleMessageMetadata::SingleMessageMetadata(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct SingleMessageMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SingleMessageMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SingleMessageMetadataDefaultTypeInternal() {}
  union {
    SingleMessageMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SingleMessageMetadataDefaultTypeInternal _SingleMessageMetadata_default_instance_;

inline constexpr Schema::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        properties_{},
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        schema_data_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        type_{static_cast< ::pulsar::proto::Schema_Type >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR Schema::Schema(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct SchemaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SchemaDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SchemaDefaultTypeInternal() {}
  union {
    Schema _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SchemaDefaultTypeInternal _Schema_default_instance_;

inline constexpr KeySharedMeta::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        hashranges_{},
        keysharedmode_{static_cast< ::pulsar::proto::KeySharedMode >(0)},
        allowoutoforderdelivery_{false} {}

template <typename>
PROTOBUF_CONSTEXPR KeySharedMeta::KeySharedMeta(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct KeySharedMetaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeySharedMetaDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeySharedMetaDefaultTypeInternal() {}
  union {
    KeySharedMeta _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeySharedMetaDefaultTypeInternal _KeySharedMeta_default_instance_;

inline constexpr EncryptionKeys::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        metadata_{},
        key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        value_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR EncryptionKeys::EncryptionKeys(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct EncryptionKeysDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EncryptionKeysDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EncryptionKeysDefaultTypeInternal() {}
  union {
    EncryptionKeys _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EncryptionKeysDefaultTypeInternal _EncryptionKeys_default_instance_;

inline constexpr CommandSendReceipt::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_id_{nullptr},
        producer_id_{::uint64_t{0u}},
        sequence_id_{::uint64_t{0u}},
        highest_sequence_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandSendReceipt::CommandSendReceipt(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandSendReceiptDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSendReceiptDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSendReceiptDefaultTypeInternal() {}
  union {
    CommandSendReceipt _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSendReceiptDefaultTypeInternal _CommandSendReceipt_default_instance_;

inline constexpr CommandSend::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_id_{nullptr},
        producer_id_{::uint64_t{0u}},
        sequence_id_{::uint64_t{0u}},
        txnid_least_bits_{::uint64_t{0u}},
        txnid_most_bits_{::uint64_t{0u}},
        highest_sequence_id_{::uint64_t{0u}},
        is_chunk_{false},
        marker_{false},
        num_messages_{1} {}

template <typename>
PROTOBUF_CONSTEXPR CommandSend::CommandSend(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandSendDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSendDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSendDefaultTypeInternal() {}
  union {
    CommandSend _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSendDefaultTypeInternal _CommandSend_default_instance_;

inline constexpr CommandSeek::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_id_{nullptr},
        consumer_id_{::uint64_t{0u}},
        request_id_{::uint64_t{0u}},
        message_publish_time_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandSeek::CommandSeek(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandSeekDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSeekDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSeekDefaultTypeInternal() {}
  union {
    CommandSeek _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSeekDefaultTypeInternal _CommandSeek_default_instance_;

inline constexpr CommandRedeliverUnacknowledgedMessages::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_ids_{},
        consumer_id_{::uint64_t{0u}},
        consumer_epoch_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandRedeliverUnacknowledgedMessages::CommandRedeliverUnacknowledgedMessages(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandRedeliverUnacknowledgedMessagesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandRedeliverUnacknowledgedMessagesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandRedeliverUnacknowledgedMessagesDefaultTypeInternal() {}
  union {
    CommandRedeliverUnacknowledgedMessages _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandRedeliverUnacknowledgedMessagesDefaultTypeInternal _CommandRedeliverUnacknowledgedMessages_default_instance_;

inline constexpr CommandMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        ack_set_{},
        message_id_{nullptr},
        consumer_id_{::uint64_t{0u}},
        consumer_epoch_{::uint64_t{0u}},
        redelivery_count_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR CommandMessage::CommandMessage(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandMessageDefaultTypeInternal() {}
  union {
    CommandMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandMessageDefaultTypeInternal _CommandMessage_default_instance_;

inline constexpr CommandGetLastMessageIdResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        last_message_id_{nullptr},
        consumer_mark_delete_position_{nullptr},
        request_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandGetLastMessageIdResponse::CommandGetLastMessageIdResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandGetLastMessageIdResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandGetLastMessageIdResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandGetLastMessageIdResponseDefaultTypeInternal() {}
  union {
    CommandGetLastMessageIdResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandGetLastMessageIdResponseDefaultTypeInternal _CommandGetLastMessageIdResponse_default_instance_;

inline constexpr CommandEndTxnOnSubscription::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        subscription_{nullptr},
        request_id_{::uint64_t{0u}},
        txnid_least_bits_{::uint64_t{0u}},
        txnid_most_bits_{::uint64_t{0u}},
        txnid_least_bits_of_low_watermark_{::uint64_t{0u}},
        txn_action_{static_cast< ::pulsar::proto::TxnAction >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandEndTxnOnSubscription::CommandEndTxnOnSubscription(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandEndTxnOnSubscriptionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandEndTxnOnSubscriptionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandEndTxnOnSubscriptionDefaultTypeInternal() {}
  union {
    CommandEndTxnOnSubscription _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandEndTxnOnSubscriptionDefaultTypeInternal _CommandEndTxnOnSubscription_default_instance_;

inline constexpr CommandConnected::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        server_version_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        feature_flags_{nullptr},
        protocol_version_{0},
        max_message_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CommandConnected::CommandConnected(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandConnectedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandConnectedDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandConnectedDefaultTypeInternal() {}
  union {
    CommandConnected _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandConnectedDefaultTypeInternal _CommandConnected_default_instance_;

inline constexpr CommandConnect::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        client_version_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        auth_data_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        auth_method_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        proxy_to_broker_url_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        original_principal_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        original_auth_data_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        original_auth_method_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        feature_flags_{nullptr},
        auth_method_{static_cast< ::pulsar::proto::AuthMethod >(0)},
        protocol_version_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CommandConnect::CommandConnect(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandConnectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandConnectDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandConnectDefaultTypeInternal() {}
  union {
    CommandConnect _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandConnectDefaultTypeInternal _CommandConnect_default_instance_;

inline constexpr CommandAuthResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        client_version_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        response_{nullptr},
        protocol_version_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CommandAuthResponse::CommandAuthResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandAuthResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandAuthResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandAuthResponseDefaultTypeInternal() {}
  union {
    CommandAuthResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandAuthResponseDefaultTypeInternal _CommandAuthResponse_default_instance_;

inline constexpr CommandAuthChallenge::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        server_version_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        challenge_{nullptr},
        protocol_version_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CommandAuthChallenge::CommandAuthChallenge(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandAuthChallengeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandAuthChallengeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandAuthChallengeDefaultTypeInternal() {}
  union {
    CommandAuthChallenge _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandAuthChallengeDefaultTypeInternal _CommandAuthChallenge_default_instance_;

inline constexpr CommandAddSubscriptionToTxn::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        subscription_{},
        request_id_{::uint64_t{0u}},
        txnid_least_bits_{::uint64_t{0u}},
        txnid_most_bits_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandAddSubscriptionToTxn::CommandAddSubscriptionToTxn(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandAddSubscriptionToTxnDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandAddSubscriptionToTxnDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandAddSubscriptionToTxnDefaultTypeInternal() {}
  union {
    CommandAddSubscriptionToTxn _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandAddSubscriptionToTxnDefaultTypeInternal _CommandAddSubscriptionToTxn_default_instance_;

inline constexpr CommandAck::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_id_{},
        properties_{},
        consumer_id_{::uint64_t{0u}},
        ack_type_{static_cast< ::pulsar::proto::CommandAck_AckType >(0)},
        validation_error_{static_cast< ::pulsar::proto::CommandAck_ValidationError >(0)},
        txnid_least_bits_{::uint64_t{0u}},
        txnid_most_bits_{::uint64_t{0u}},
        request_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandAck::CommandAck(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandAckDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandAckDefaultTypeInternal() {}
  union {
    CommandAck _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandAckDefaultTypeInternal _CommandAck_default_instance_;

inline constexpr MessageMetadata::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        properties_{},
        replicate_to_{},
        encryption_keys_{},
        producer_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        replicated_from_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        partition_key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        encryption_algo_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        encryption_param_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        schema_version_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        ordering_key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        uuid_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        sequence_id_{::uint64_t{0u}},
        publish_time_{::uint64_t{0u}},
        compression_{static_cast< ::pulsar::proto::CompressionType >(0)},
        uncompressed_size_{0u},
        event_time_{::uint64_t{0u}},
        deliver_at_time_{::int64_t{0}},
        txnid_least_bits_{::uint64_t{0u}},
        txnid_most_bits_{::uint64_t{0u}},
        marker_type_{0},
        partition_key_b64_encoded_{false},
        null_value_{false},
        null_partition_key_{false},
        highest_sequence_id_{::uint64_t{0u}},
        num_chunks_from_msg_{0},
        total_chunk_msg_size_{0},
        chunk_id_{0},
        num_messages_in_batch_{1} {}

template <typename>
PROTOBUF_CONSTEXPR MessageMetadata::MessageMetadata(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct MessageMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageMetadataDefaultTypeInternal() {}
  union {
    MessageMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageMetadataDefaultTypeInternal _MessageMetadata_default_instance_;

inline constexpr CommandSuccess::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        schema_{nullptr},
        request_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandSuccess::CommandSuccess(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandSuccessDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSuccessDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSuccessDefaultTypeInternal() {}
  union {
    CommandSuccess _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSuccessDefaultTypeInternal _CommandSuccess_default_instance_;

inline constexpr CommandSubscribe::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        metadata_{},
        subscription_properties_{},
        topic_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        subscription_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        consumer_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        start_message_id_{nullptr},
        schema_{nullptr},
        keysharedmeta_{nullptr},
        consumer_id_{::uint64_t{0u}},
        request_id_{::uint64_t{0u}},
        subtype_{static_cast< ::pulsar::proto::CommandSubscribe_SubType >(0)},
        priority_level_{0},
        read_compacted_{false},
        replicate_subscription_state_{false},
        initialposition_{static_cast< ::pulsar::proto::CommandSubscribe_InitialPosition >(0)},
        start_message_rollback_duration_sec_{::uint64_t{0u}},
        consumer_epoch_{::uint64_t{0u}},
        durable_{true},
        force_topic_creation_{true} {}

template <typename>
PROTOBUF_CONSTEXPR CommandSubscribe::CommandSubscribe(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandSubscribeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSubscribeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSubscribeDefaultTypeInternal() {}
  union {
    CommandSubscribe _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSubscribeDefaultTypeInternal _CommandSubscribe_default_instance_;

inline constexpr CommandProducer::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        metadata_{},
        topic_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        producer_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        initial_subscription_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        schema_{nullptr},
        producer_id_{::uint64_t{0u}},
        request_id_{::uint64_t{0u}},
        epoch_{::uint64_t{0u}},
        encrypted_{false},
        txn_enabled_{false},
        producer_access_mode_{static_cast< ::pulsar::proto::ProducerAccessMode >(0)},
        topic_epoch_{::uint64_t{0u}},
        user_provided_producer_name_{true} {}

template <typename>
PROTOBUF_CONSTEXPR CommandProducer::CommandProducer(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandProducerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandProducerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandProducerDefaultTypeInternal() {}
  union {
    CommandProducer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandProducerDefaultTypeInternal _CommandProducer_default_instance_;

inline constexpr CommandGetSchemaResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        error_message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        schema_version_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        schema_{nullptr},
        request_id_{::uint64_t{0u}},
        error_code_{static_cast< ::pulsar::proto::ServerError >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CommandGetSchemaResponse::CommandGetSchemaResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandGetSchemaResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandGetSchemaResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandGetSchemaResponseDefaultTypeInternal() {}
  union {
    CommandGetSchemaResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandGetSchemaResponseDefaultTypeInternal _CommandGetSchemaResponse_default_instance_;

inline constexpr CommandGetOrCreateSchema::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        topic_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        schema_{nullptr},
        request_id_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR CommandGetOrCreateSchema::CommandGetOrCreateSchema(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CommandGetOrCreateSchemaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandGetOrCreateSchemaDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandGetOrCreateSchemaDefaultTypeInternal() {}
  union {
    CommandGetOrCreateSchema _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandGetOrCreateSchemaDefaultTypeInternal _CommandGetOrCreateSchema_default_instance_;

inline constexpr BaseCommand::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        connect_{nullptr},
        connected_{nullptr},
        subscribe_{nullptr},
        producer_{nullptr},
        send_{nullptr},
        send_receipt_{nullptr},
        send_error_{nullptr},
        message_{nullptr},
        ack_{nullptr},
        flow_{nullptr},
        unsubscribe_{nullptr},
        success_{nullptr},
        error_{nullptr},
        close_producer_{nullptr},
        close_consumer_{nullptr},
        producer_success_{nullptr},
        ping_{nullptr},
        pong_{nullptr},
        redeliverunacknowledgedmessages_{nullptr},
        partitionmetadata_{nullptr},
        partitionmetadataresponse_{nullptr},
        lookuptopic_{nullptr},
        lookuptopicresponse_{nullptr},
        consumerstats_{nullptr},
        consumerstatsresponse_{nullptr},
        reachedendoftopic_{nullptr},
        seek_{nullptr},
        getlastmessageid_{nullptr},
        getlastmessageidresponse_{nullptr},
        active_consumer_change_{nullptr},
        gettopicsofnamespace_{nullptr},
        gettopicsofnamespaceresponse_{nullptr},
        getschema_{nullptr},
        getschemaresponse_{nullptr},
        authchallenge_{nullptr},
        authresponse_{nullptr},
        ackresponse_{nullptr},
        getorcreateschema_{nullptr},
        getorcreateschemaresponse_{nullptr},
        newtxn_{nullptr},
        newtxnresponse_{nullptr},
        addpartitiontotxn_{nullptr},
        addpartitiontotxnresponse_{nullptr},
        addsubscriptiontotxn_{nullptr},
        addsubscriptiontotxnresponse_{nullptr},
        endtxn_{nullptr},
        endtxnresponse_{nullptr},
        endtxnonpartition_{nullptr},
        endtxnonpartitionresponse_{nullptr},
        endtxnonsubscription_{nullptr},
        endtxnonsubscriptionresponse_{nullptr},
        tcclientconnectrequest_{nullptr},
        tcclientconnectresponse_{nullptr},
        watchtopiclist_{nullptr},
        watchtopiclistsuccess_{nullptr},
        watchtopicupdate_{nullptr},
        watchtopiclistclose_{nullptr},
        topicmigrated_{nullptr},
        type_{static_cast< ::pulsar::proto::BaseCommand_Type >(2)} {}

template <typename>
PROTOBUF_CONSTEXPR BaseCommand::BaseCommand(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct BaseCommandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BaseCommandDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BaseCommandDefaultTypeInternal() {}
  union {
    BaseCommand _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BaseCommandDefaultTypeInternal _BaseCommand_default_instance_;
}  // namespace proto
}  // namespace pulsar
namespace pulsar {
namespace proto {
PROTOBUF_CONSTINIT const uint32_t Schema_Type_internal_data_[] = {
    1376256u, 0u, };
bool Schema_Type_IsValid(int value) {
  return 0 <= value && value <= 20;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    Schema_Type_strings[21] = {};

static const char Schema_Type_names[] = {
    "Avro"
    "Bool"
    "Date"
    "Double"
    "Float"
    "Instant"
    "Int16"
    "Int32"
    "Int64"
    "Int8"
    "Json"
    "KeyValue"
    "LocalDate"
    "LocalDateTime"
    "LocalTime"
    "None"
    "Protobuf"
    "ProtobufNative"
    "String"
    "Time"
    "Timestamp"
};

static const ::google::protobuf::internal::EnumEntry Schema_Type_entries[] =
    {
        {{&Schema_Type_names[0], 4}, 4},
        {{&Schema_Type_names[4], 4}, 5},
        {{&Schema_Type_names[8], 4}, 12},
        {{&Schema_Type_names[12], 6}, 11},
        {{&Schema_Type_names[18], 5}, 10},
        {{&Schema_Type_names[23], 7}, 16},
        {{&Schema_Type_names[30], 5}, 7},
        {{&Schema_Type_names[35], 5}, 8},
        {{&Schema_Type_names[40], 5}, 9},
        {{&Schema_Type_names[45], 4}, 6},
        {{&Schema_Type_names[49], 4}, 2},
        {{&Schema_Type_names[53], 8}, 15},
        {{&Schema_Type_names[61], 9}, 17},
        {{&Schema_Type_names[70], 13}, 19},
        {{&Schema_Type_names[83], 9}, 18},
        {{&Schema_Type_names[92], 4}, 0},
        {{&Schema_Type_names[96], 8}, 3},
        {{&Schema_Type_names[104], 14}, 20},
        {{&Schema_Type_names[118], 6}, 1},
        {{&Schema_Type_names[124], 4}, 13},
        {{&Schema_Type_names[128], 9}, 14},
};

static const int Schema_Type_entries_by_number[] = {
    15,  // 0 -> None
    18,  // 1 -> String
    10,  // 2 -> Json
    16,  // 3 -> Protobuf
    0,  // 4 -> Avro
    1,  // 5 -> Bool
    9,  // 6 -> Int8
    6,  // 7 -> Int16
    7,  // 8 -> Int32
    8,  // 9 -> Int64
    4,  // 10 -> Float
    3,  // 11 -> Double
    2,  // 12 -> Date
    19,  // 13 -> Time
    20,  // 14 -> Timestamp
    11,  // 15 -> KeyValue
    5,  // 16 -> Instant
    12,  // 17 -> LocalDate
    14,  // 18 -> LocalTime
    13,  // 19 -> LocalDateTime
    17,  // 20 -> ProtobufNative
};

const std::string& Schema_Type_Name(Schema_Type value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          Schema_Type_entries, Schema_Type_entries_by_number,
          21, Schema_Type_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      Schema_Type_entries, Schema_Type_entries_by_number, 21,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : Schema_Type_strings[idx].get();
}

bool Schema_Type_Parse(absl::string_view name, Schema_Type* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      Schema_Type_entries, 21, name, &int_value);
  if (success) {
    *value = static_cast<Schema_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Schema_Type Schema::None;
constexpr Schema_Type Schema::String;
constexpr Schema_Type Schema::Json;
constexpr Schema_Type Schema::Protobuf;
constexpr Schema_Type Schema::Avro;
constexpr Schema_Type Schema::Bool;
constexpr Schema_Type Schema::Int8;
constexpr Schema_Type Schema::Int16;
constexpr Schema_Type Schema::Int32;
constexpr Schema_Type Schema::Int64;
constexpr Schema_Type Schema::Float;
constexpr Schema_Type Schema::Double;
constexpr Schema_Type Schema::Date;
constexpr Schema_Type Schema::Time;
constexpr Schema_Type Schema::Timestamp;
constexpr Schema_Type Schema::KeyValue;
constexpr Schema_Type Schema::Instant;
constexpr Schema_Type Schema::LocalDate;
constexpr Schema_Type Schema::LocalTime;
constexpr Schema_Type Schema::LocalDateTime;
constexpr Schema_Type Schema::ProtobufNative;
constexpr Schema_Type Schema::Type_MIN;
constexpr Schema_Type Schema::Type_MAX;
constexpr int Schema::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t CommandSubscribe_SubType_internal_data_[] = {
    262144u, 0u, };
bool CommandSubscribe_SubType_IsValid(int value) {
  return 0 <= value && value <= 3;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    CommandSubscribe_SubType_strings[4] = {};

static const char CommandSubscribe_SubType_names[] = {
    "Exclusive"
    "Failover"
    "Key_Shared"
    "Shared"
};

static const ::google::protobuf::internal::EnumEntry CommandSubscribe_SubType_entries[] =
    {
        {{&CommandSubscribe_SubType_names[0], 9}, 0},
        {{&CommandSubscribe_SubType_names[9], 8}, 2},
        {{&CommandSubscribe_SubType_names[17], 10}, 3},
        {{&CommandSubscribe_SubType_names[27], 6}, 1},
};

static const int CommandSubscribe_SubType_entries_by_number[] = {
    0,  // 0 -> Exclusive
    3,  // 1 -> Shared
    1,  // 2 -> Failover
    2,  // 3 -> Key_Shared
};

const std::string& CommandSubscribe_SubType_Name(CommandSubscribe_SubType value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          CommandSubscribe_SubType_entries, CommandSubscribe_SubType_entries_by_number,
          4, CommandSubscribe_SubType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      CommandSubscribe_SubType_entries, CommandSubscribe_SubType_entries_by_number, 4,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : CommandSubscribe_SubType_strings[idx].get();
}

bool CommandSubscribe_SubType_Parse(absl::string_view name, CommandSubscribe_SubType* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      CommandSubscribe_SubType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CommandSubscribe_SubType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr CommandSubscribe_SubType CommandSubscribe::Exclusive;
constexpr CommandSubscribe_SubType CommandSubscribe::Shared;
constexpr CommandSubscribe_SubType CommandSubscribe::Failover;
constexpr CommandSubscribe_SubType CommandSubscribe::Key_Shared;
constexpr CommandSubscribe_SubType CommandSubscribe::SubType_MIN;
constexpr CommandSubscribe_SubType CommandSubscribe::SubType_MAX;
constexpr int CommandSubscribe::SubType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t CommandSubscribe_InitialPosition_internal_data_[] = {
    131072u, 0u, };
bool CommandSubscribe_InitialPosition_IsValid(int value) {
  return 0 <= value && value <= 1;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    CommandSubscribe_InitialPosition_strings[2] = {};

static const char CommandSubscribe_InitialPosition_names[] = {
    "Earliest"
    "Latest"
};

static const ::google::protobuf::internal::EnumEntry CommandSubscribe_InitialPosition_entries[] =
    {
        {{&CommandSubscribe_InitialPosition_names[0], 8}, 1},
        {{&CommandSubscribe_InitialPosition_names[8], 6}, 0},
};

static const int CommandSubscribe_InitialPosition_entries_by_number[] = {
    1,  // 0 -> Latest
    0,  // 1 -> Earliest
};

const std::string& CommandSubscribe_InitialPosition_Name(CommandSubscribe_InitialPosition value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          CommandSubscribe_InitialPosition_entries, CommandSubscribe_InitialPosition_entries_by_number,
          2, CommandSubscribe_InitialPosition_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      CommandSubscribe_InitialPosition_entries, CommandSubscribe_InitialPosition_entries_by_number, 2,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : CommandSubscribe_InitialPosition_strings[idx].get();
}

bool CommandSubscribe_InitialPosition_Parse(absl::string_view name, CommandSubscribe_InitialPosition* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      CommandSubscribe_InitialPosition_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<CommandSubscribe_InitialPosition>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr CommandSubscribe_InitialPosition CommandSubscribe::Latest;
constexpr CommandSubscribe_InitialPosition CommandSubscribe::Earliest;
constexpr CommandSubscribe_InitialPosition CommandSubscribe::InitialPosition_MIN;
constexpr CommandSubscribe_InitialPosition CommandSubscribe::InitialPosition_MAX;
constexpr int CommandSubscribe::InitialPosition_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t CommandPartitionedTopicMetadataResponse_LookupType_internal_data_[] = {
    131072u, 0u, };
bool CommandPartitionedTopicMetadataResponse_LookupType_IsValid(int value) {
  return 0 <= value && value <= 1;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    CommandPartitionedTopicMetadataResponse_LookupType_strings[2] = {};

static const char CommandPartitionedTopicMetadataResponse_LookupType_names[] = {
    "Failed"
    "Success"
};

static const ::google::protobuf::internal::EnumEntry CommandPartitionedTopicMetadataResponse_LookupType_entries[] =
    {
        {{&CommandPartitionedTopicMetadataResponse_LookupType_names[0], 6}, 1},
        {{&CommandPartitionedTopicMetadataResponse_LookupType_names[6], 7}, 0},
};

static const int CommandPartitionedTopicMetadataResponse_LookupType_entries_by_number[] = {
    1,  // 0 -> Success
    0,  // 1 -> Failed
};

const std::string& CommandPartitionedTopicMetadataResponse_LookupType_Name(CommandPartitionedTopicMetadataResponse_LookupType value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          CommandPartitionedTopicMetadataResponse_LookupType_entries, CommandPartitionedTopicMetadataResponse_LookupType_entries_by_number,
          2, CommandPartitionedTopicMetadataResponse_LookupType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      CommandPartitionedTopicMetadataResponse_LookupType_entries, CommandPartitionedTopicMetadataResponse_LookupType_entries_by_number, 2,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : CommandPartitionedTopicMetadataResponse_LookupType_strings[idx].get();
}

bool CommandPartitionedTopicMetadataResponse_LookupType_Parse(absl::string_view name, CommandPartitionedTopicMetadataResponse_LookupType* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      CommandPartitionedTopicMetadataResponse_LookupType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<CommandPartitionedTopicMetadataResponse_LookupType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse::Success;
constexpr CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse::Failed;
constexpr CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse::LookupType_MIN;
constexpr CommandPartitionedTopicMetadataResponse_LookupType CommandPartitionedTopicMetadataResponse::LookupType_MAX;
constexpr int CommandPartitionedTopicMetadataResponse::LookupType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t CommandLookupTopicResponse_LookupType_internal_data_[] = {
    196608u, 0u, };
bool CommandLookupTopicResponse_LookupType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    CommandLookupTopicResponse_LookupType_strings[3] = {};

static const char CommandLookupTopicResponse_LookupType_names[] = {
    "Connect"
    "Failed"
    "Redirect"
};

static const ::google::protobuf::internal::EnumEntry CommandLookupTopicResponse_LookupType_entries[] =
    {
        {{&CommandLookupTopicResponse_LookupType_names[0], 7}, 1},
        {{&CommandLookupTopicResponse_LookupType_names[7], 6}, 2},
        {{&CommandLookupTopicResponse_LookupType_names[13], 8}, 0},
};

static const int CommandLookupTopicResponse_LookupType_entries_by_number[] = {
    2,  // 0 -> Redirect
    0,  // 1 -> Connect
    1,  // 2 -> Failed
};

const std::string& CommandLookupTopicResponse_LookupType_Name(CommandLookupTopicResponse_LookupType value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          CommandLookupTopicResponse_LookupType_entries, CommandLookupTopicResponse_LookupType_entries_by_number,
          3, CommandLookupTopicResponse_LookupType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      CommandLookupTopicResponse_LookupType_entries, CommandLookupTopicResponse_LookupType_entries_by_number, 3,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : CommandLookupTopicResponse_LookupType_strings[idx].get();
}

bool CommandLookupTopicResponse_LookupType_Parse(absl::string_view name, CommandLookupTopicResponse_LookupType* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      CommandLookupTopicResponse_LookupType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CommandLookupTopicResponse_LookupType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr CommandLookupTopicResponse_LookupType CommandLookupTopicResponse::Redirect;
constexpr CommandLookupTopicResponse_LookupType CommandLookupTopicResponse::Connect;
constexpr CommandLookupTopicResponse_LookupType CommandLookupTopicResponse::Failed;
constexpr CommandLookupTopicResponse_LookupType CommandLookupTopicResponse::LookupType_MIN;
constexpr CommandLookupTopicResponse_LookupType CommandLookupTopicResponse::LookupType_MAX;
constexpr int CommandLookupTopicResponse::LookupType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t CommandAck_AckType_internal_data_[] = {
    131072u, 0u, };
bool CommandAck_AckType_IsValid(int value) {
  return 0 <= value && value <= 1;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    CommandAck_AckType_strings[2] = {};

static const char CommandAck_AckType_names[] = {
    "Cumulative"
    "Individual"
};

static const ::google::protobuf::internal::EnumEntry CommandAck_AckType_entries[] =
    {
        {{&CommandAck_AckType_names[0], 10}, 1},
        {{&CommandAck_AckType_names[10], 10}, 0},
};

static const int CommandAck_AckType_entries_by_number[] = {
    1,  // 0 -> Individual
    0,  // 1 -> Cumulative
};

const std::string& CommandAck_AckType_Name(CommandAck_AckType value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          CommandAck_AckType_entries, CommandAck_AckType_entries_by_number,
          2, CommandAck_AckType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      CommandAck_AckType_entries, CommandAck_AckType_entries_by_number, 2,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : CommandAck_AckType_strings[idx].get();
}

bool CommandAck_AckType_Parse(absl::string_view name, CommandAck_AckType* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      CommandAck_AckType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<CommandAck_AckType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr CommandAck_AckType CommandAck::Individual;
constexpr CommandAck_AckType CommandAck::Cumulative;
constexpr CommandAck_AckType CommandAck::AckType_MIN;
constexpr CommandAck_AckType CommandAck::AckType_MAX;
constexpr int CommandAck::AckType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t CommandAck_ValidationError_internal_data_[] = {
    327680u, 0u, };
bool CommandAck_ValidationError_IsValid(int value) {
  return 0 <= value && value <= 4;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    CommandAck_ValidationError_strings[5] = {};

static const char CommandAck_ValidationError_names[] = {
    "BatchDeSerializeError"
    "ChecksumMismatch"
    "DecompressionError"
    "DecryptionError"
    "UncompressedSizeCorruption"
};

static const ::google::protobuf::internal::EnumEntry CommandAck_ValidationError_entries[] =
    {
        {{&CommandAck_ValidationError_names[0], 21}, 3},
        {{&CommandAck_ValidationError_names[21], 16}, 2},
        {{&CommandAck_ValidationError_names[37], 18}, 1},
        {{&CommandAck_ValidationError_names[55], 15}, 4},
        {{&CommandAck_ValidationError_names[70], 26}, 0},
};

static const int CommandAck_ValidationError_entries_by_number[] = {
    4,  // 0 -> UncompressedSizeCorruption
    2,  // 1 -> DecompressionError
    1,  // 2 -> ChecksumMismatch
    0,  // 3 -> BatchDeSerializeError
    3,  // 4 -> DecryptionError
};

const std::string& CommandAck_ValidationError_Name(CommandAck_ValidationError value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          CommandAck_ValidationError_entries, CommandAck_ValidationError_entries_by_number,
          5, CommandAck_ValidationError_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      CommandAck_ValidationError_entries, CommandAck_ValidationError_entries_by_number, 5,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : CommandAck_ValidationError_strings[idx].get();
}

bool CommandAck_ValidationError_Parse(absl::string_view name, CommandAck_ValidationError* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      CommandAck_ValidationError_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<CommandAck_ValidationError>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr CommandAck_ValidationError CommandAck::UncompressedSizeCorruption;
constexpr CommandAck_ValidationError CommandAck::DecompressionError;
constexpr CommandAck_ValidationError CommandAck::ChecksumMismatch;
constexpr CommandAck_ValidationError CommandAck::BatchDeSerializeError;
constexpr CommandAck_ValidationError CommandAck::DecryptionError;
constexpr CommandAck_ValidationError CommandAck::ValidationError_MIN;
constexpr CommandAck_ValidationError CommandAck::ValidationError_MAX;
constexpr int CommandAck::ValidationError_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t CommandTopicMigrated_ResourceType_internal_data_[] = {
    131072u, 0u, };
bool CommandTopicMigrated_ResourceType_IsValid(int value) {
  return 0 <= value && value <= 1;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    CommandTopicMigrated_ResourceType_strings[2] = {};

static const char CommandTopicMigrated_ResourceType_names[] = {
    "Consumer"
    "Producer"
};

static const ::google::protobuf::internal::EnumEntry CommandTopicMigrated_ResourceType_entries[] =
    {
        {{&CommandTopicMigrated_ResourceType_names[0], 8}, 1},
        {{&CommandTopicMigrated_ResourceType_names[8], 8}, 0},
};

static const int CommandTopicMigrated_ResourceType_entries_by_number[] = {
    1,  // 0 -> Producer
    0,  // 1 -> Consumer
};

const std::string& CommandTopicMigrated_ResourceType_Name(CommandTopicMigrated_ResourceType value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          CommandTopicMigrated_ResourceType_entries, CommandTopicMigrated_ResourceType_entries_by_number,
          2, CommandTopicMigrated_ResourceType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      CommandTopicMigrated_ResourceType_entries, CommandTopicMigrated_ResourceType_entries_by_number, 2,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : CommandTopicMigrated_ResourceType_strings[idx].get();
}

bool CommandTopicMigrated_ResourceType_Parse(absl::string_view name, CommandTopicMigrated_ResourceType* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      CommandTopicMigrated_ResourceType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<CommandTopicMigrated_ResourceType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr CommandTopicMigrated_ResourceType CommandTopicMigrated::Producer;
constexpr CommandTopicMigrated_ResourceType CommandTopicMigrated::Consumer;
constexpr CommandTopicMigrated_ResourceType CommandTopicMigrated::ResourceType_MIN;
constexpr CommandTopicMigrated_ResourceType CommandTopicMigrated::ResourceType_MAX;
constexpr int CommandTopicMigrated::ResourceType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t CommandGetTopicsOfNamespace_Mode_internal_data_[] = {
    196608u, 0u, };
bool CommandGetTopicsOfNamespace_Mode_IsValid(int value) {
  return 0 <= value && value <= 2;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    CommandGetTopicsOfNamespace_Mode_strings[3] = {};

static const char CommandGetTopicsOfNamespace_Mode_names[] = {
    "ALL"
    "NON_PERSISTENT"
    "PERSISTENT"
};

static const ::google::protobuf::internal::EnumEntry CommandGetTopicsOfNamespace_Mode_entries[] =
    {
        {{&CommandGetTopicsOfNamespace_Mode_names[0], 3}, 2},
        {{&CommandGetTopicsOfNamespace_Mode_names[3], 14}, 1},
        {{&CommandGetTopicsOfNamespace_Mode_names[17], 10}, 0},
};

static const int CommandGetTopicsOfNamespace_Mode_entries_by_number[] = {
    2,  // 0 -> PERSISTENT
    1,  // 1 -> NON_PERSISTENT
    0,  // 2 -> ALL
};

const std::string& CommandGetTopicsOfNamespace_Mode_Name(CommandGetTopicsOfNamespace_Mode value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          CommandGetTopicsOfNamespace_Mode_entries, CommandGetTopicsOfNamespace_Mode_entries_by_number,
          3, CommandGetTopicsOfNamespace_Mode_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      CommandGetTopicsOfNamespace_Mode_entries, CommandGetTopicsOfNamespace_Mode_entries_by_number, 3,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : CommandGetTopicsOfNamespace_Mode_strings[idx].get();
}

bool CommandGetTopicsOfNamespace_Mode_Parse(absl::string_view name, CommandGetTopicsOfNamespace_Mode* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      CommandGetTopicsOfNamespace_Mode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CommandGetTopicsOfNamespace_Mode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace::PERSISTENT;
constexpr CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace::NON_PERSISTENT;
constexpr CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace::ALL;
constexpr CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace::Mode_MIN;
constexpr CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace::Mode_MAX;
constexpr int CommandGetTopicsOfNamespace::Mode_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t BaseCommand_Type_internal_data_[] = {
    2555906u, 32u, 268434944u, };
bool BaseCommand_Type_IsValid(int value) {
  return ::_pbi::ValidateEnum(value, BaseCommand_Type_internal_data_);
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    BaseCommand_Type_strings[58] = {};

static const char BaseCommand_Type_names[] = {
    "ACK"
    "ACK_RESPONSE"
    "ACTIVE_CONSUMER_CHANGE"
    "ADD_PARTITION_TO_TXN"
    "ADD_PARTITION_TO_TXN_RESPONSE"
    "ADD_SUBSCRIPTION_TO_TXN"
    "ADD_SUBSCRIPTION_TO_TXN_RESPONSE"
    "AUTH_CHALLENGE"
    "AUTH_RESPONSE"
    "CLOSE_CONSUMER"
    "CLOSE_PRODUCER"
    "CONNECT"
    "CONNECTED"
    "CONSUMER_STATS"
    "CONSUMER_STATS_RESPONSE"
    "END_TXN"
    "END_TXN_ON_PARTITION"
    "END_TXN_ON_PARTITION_RESPONSE"
    "END_TXN_ON_SUBSCRIPTION"
    "END_TXN_ON_SUBSCRIPTION_RESPONSE"
    "END_TXN_RESPONSE"
    "ERROR"
    "FLOW"
    "GET_LAST_MESSAGE_ID"
    "GET_LAST_MESSAGE_ID_RESPONSE"
    "GET_OR_CREATE_SCHEMA"
    "GET_OR_CREATE_SCHEMA_RESPONSE"
    "GET_SCHEMA"
    "GET_SCHEMA_RESPONSE"
    "GET_TOPICS_OF_NAMESPACE"
    "GET_TOPICS_OF_NAMESPACE_RESPONSE"
    "LOOKUP"
    "LOOKUP_RESPONSE"
    "MESSAGE"
    "NEW_TXN"
    "NEW_TXN_RESPONSE"
    "PARTITIONED_METADATA"
    "PARTITIONED_METADATA_RESPONSE"
    "PING"
    "PONG"
    "PRODUCER"
    "PRODUCER_SUCCESS"
    "REACHED_END_OF_TOPIC"
    "REDELIVER_UNACKNOWLEDGED_MESSAGES"
    "SEEK"
    "SEND"
    "SEND_ERROR"
    "SEND_RECEIPT"
    "SUBSCRIBE"
    "SUCCESS"
    "TC_CLIENT_CONNECT_REQUEST"
    "TC_CLIENT_CONNECT_RESPONSE"
    "TOPIC_MIGRATED"
    "UNSUBSCRIBE"
    "WATCH_TOPIC_LIST"
    "WATCH_TOPIC_LIST_CLOSE"
    "WATCH_TOPIC_LIST_SUCCESS"
    "WATCH_TOPIC_UPDATE"
};

static const ::google::protobuf::internal::EnumEntry BaseCommand_Type_entries[] =
    {
        {{&BaseCommand_Type_names[0], 3}, 10},
        {{&BaseCommand_Type_names[3], 12}, 38},
        {{&BaseCommand_Type_names[15], 22}, 31},
        {{&BaseCommand_Type_names[37], 20}, 52},
        {{&BaseCommand_Type_names[57], 29}, 53},
        {{&BaseCommand_Type_names[86], 23}, 54},
        {{&BaseCommand_Type_names[109], 32}, 55},
        {{&BaseCommand_Type_names[141], 14}, 36},
        {{&BaseCommand_Type_names[155], 13}, 37},
        {{&BaseCommand_Type_names[168], 14}, 16},
        {{&BaseCommand_Type_names[182], 14}, 15},
        {{&BaseCommand_Type_names[196], 7}, 2},
        {{&BaseCommand_Type_names[203], 9}, 3},
        {{&BaseCommand_Type_names[212], 14}, 25},
        {{&BaseCommand_Type_names[226], 23}, 26},
        {{&BaseCommand_Type_names[249], 7}, 56},
        {{&BaseCommand_Type_names[256], 20}, 58},
        {{&BaseCommand_Type_names[276], 29}, 59},
        {{&BaseCommand_Type_names[305], 23}, 60},
        {{&BaseCommand_Type_names[328], 32}, 61},
        {{&BaseCommand_Type_names[360], 16}, 57},
        {{&BaseCommand_Type_names[376], 5}, 14},
        {{&BaseCommand_Type_names[381], 4}, 11},
        {{&BaseCommand_Type_names[385], 19}, 29},
        {{&BaseCommand_Type_names[404], 28}, 30},
        {{&BaseCommand_Type_names[432], 20}, 39},
        {{&BaseCommand_Type_names[452], 29}, 40},
        {{&BaseCommand_Type_names[481], 10}, 34},
        {{&BaseCommand_Type_names[491], 19}, 35},
        {{&BaseCommand_Type_names[510], 23}, 32},
        {{&BaseCommand_Type_names[533], 32}, 33},
        {{&BaseCommand_Type_names[565], 6}, 23},
        {{&BaseCommand_Type_names[571], 15}, 24},
        {{&BaseCommand_Type_names[586], 7}, 9},
        {{&BaseCommand_Type_names[593], 7}, 50},
        {{&BaseCommand_Type_names[600], 16}, 51},
        {{&BaseCommand_Type_names[616], 20}, 21},
        {{&BaseCommand_Type_names[636], 29}, 22},
        {{&BaseCommand_Type_names[665], 4}, 18},
        {{&BaseCommand_Type_names[669], 4}, 19},
        {{&BaseCommand_Type_names[673], 8}, 5},
        {{&BaseCommand_Type_names[681], 16}, 17},
        {{&BaseCommand_Type_names[697], 20}, 27},
        {{&BaseCommand_Type_names[717], 33}, 20},
        {{&BaseCommand_Type_names[750], 4}, 28},
        {{&BaseCommand_Type_names[754], 4}, 6},
        {{&BaseCommand_Type_names[758], 10}, 8},
        {{&BaseCommand_Type_names[768], 12}, 7},
        {{&BaseCommand_Type_names[780], 9}, 4},
        {{&BaseCommand_Type_names[789], 7}, 13},
        {{&BaseCommand_Type_names[796], 25}, 62},
        {{&BaseCommand_Type_names[821], 26}, 63},
        {{&BaseCommand_Type_names[847], 14}, 68},
        {{&BaseCommand_Type_names[861], 11}, 12},
        {{&BaseCommand_Type_names[872], 16}, 64},
        {{&BaseCommand_Type_names[888], 22}, 67},
        {{&BaseCommand_Type_names[910], 24}, 65},
        {{&BaseCommand_Type_names[934], 18}, 66},
};

static const int BaseCommand_Type_entries_by_number[] = {
    11,  // 2 -> CONNECT
    12,  // 3 -> CONNECTED
    48,  // 4 -> SUBSCRIBE
    40,  // 5 -> PRODUCER
    45,  // 6 -> SEND
    47,  // 7 -> SEND_RECEIPT
    46,  // 8 -> SEND_ERROR
    33,  // 9 -> MESSAGE
    0,  // 10 -> ACK
    22,  // 11 -> FLOW
    53,  // 12 -> UNSUBSCRIBE
    49,  // 13 -> SUCCESS
    21,  // 14 -> ERROR
    10,  // 15 -> CLOSE_PRODUCER
    9,  // 16 -> CLOSE_CONSUMER
    41,  // 17 -> PRODUCER_SUCCESS
    38,  // 18 -> PING
    39,  // 19 -> PONG
    43,  // 20 -> REDELIVER_UNACKNOWLEDGED_MESSAGES
    36,  // 21 -> PARTITIONED_METADATA
    37,  // 22 -> PARTITIONED_METADATA_RESPONSE
    31,  // 23 -> LOOKUP
    32,  // 24 -> LOOKUP_RESPONSE
    13,  // 25 -> CONSUMER_STATS
    14,  // 26 -> CONSUMER_STATS_RESPONSE
    42,  // 27 -> REACHED_END_OF_TOPIC
    44,  // 28 -> SEEK
    23,  // 29 -> GET_LAST_MESSAGE_ID
    24,  // 30 -> GET_LAST_MESSAGE_ID_RESPONSE
    2,  // 31 -> ACTIVE_CONSUMER_CHANGE
    29,  // 32 -> GET_TOPICS_OF_NAMESPACE
    30,  // 33 -> GET_TOPICS_OF_NAMESPACE_RESPONSE
    27,  // 34 -> GET_SCHEMA
    28,  // 35 -> GET_SCHEMA_RESPONSE
    7,  // 36 -> AUTH_CHALLENGE
    8,  // 37 -> AUTH_RESPONSE
    1,  // 38 -> ACK_RESPONSE
    25,  // 39 -> GET_OR_CREATE_SCHEMA
    26,  // 40 -> GET_OR_CREATE_SCHEMA_RESPONSE
    34,  // 50 -> NEW_TXN
    35,  // 51 -> NEW_TXN_RESPONSE
    3,  // 52 -> ADD_PARTITION_TO_TXN
    4,  // 53 -> ADD_PARTITION_TO_TXN_RESPONSE
    5,  // 54 -> ADD_SUBSCRIPTION_TO_TXN
    6,  // 55 -> ADD_SUBSCRIPTION_TO_TXN_RESPONSE
    15,  // 56 -> END_TXN
    20,  // 57 -> END_TXN_RESPONSE
    16,  // 58 -> END_TXN_ON_PARTITION
    17,  // 59 -> END_TXN_ON_PARTITION_RESPONSE
    18,  // 60 -> END_TXN_ON_SUBSCRIPTION
    19,  // 61 -> END_TXN_ON_SUBSCRIPTION_RESPONSE
    50,  // 62 -> TC_CLIENT_CONNECT_REQUEST
    51,  // 63 -> TC_CLIENT_CONNECT_RESPONSE
    54,  // 64 -> WATCH_TOPIC_LIST
    56,  // 65 -> WATCH_TOPIC_LIST_SUCCESS
    57,  // 66 -> WATCH_TOPIC_UPDATE
    55,  // 67 -> WATCH_TOPIC_LIST_CLOSE
    52,  // 68 -> TOPIC_MIGRATED
};

const std::string& BaseCommand_Type_Name(BaseCommand_Type value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          BaseCommand_Type_entries, BaseCommand_Type_entries_by_number,
          58, BaseCommand_Type_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      BaseCommand_Type_entries, BaseCommand_Type_entries_by_number, 58,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : BaseCommand_Type_strings[idx].get();
}

bool BaseCommand_Type_Parse(absl::string_view name, BaseCommand_Type* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      BaseCommand_Type_entries, 58, name, &int_value);
  if (success) {
    *value = static_cast<BaseCommand_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr BaseCommand_Type BaseCommand::CONNECT;
constexpr BaseCommand_Type BaseCommand::CONNECTED;
constexpr BaseCommand_Type BaseCommand::SUBSCRIBE;
constexpr BaseCommand_Type BaseCommand::PRODUCER;
constexpr BaseCommand_Type BaseCommand::SEND;
constexpr BaseCommand_Type BaseCommand::SEND_RECEIPT;
constexpr BaseCommand_Type BaseCommand::SEND_ERROR;
constexpr BaseCommand_Type BaseCommand::MESSAGE;
constexpr BaseCommand_Type BaseCommand::ACK;
constexpr BaseCommand_Type BaseCommand::FLOW;
constexpr BaseCommand_Type BaseCommand::UNSUBSCRIBE;
constexpr BaseCommand_Type BaseCommand::SUCCESS;
constexpr BaseCommand_Type BaseCommand::ERROR;
constexpr BaseCommand_Type BaseCommand::CLOSE_PRODUCER;
constexpr BaseCommand_Type BaseCommand::CLOSE_CONSUMER;
constexpr BaseCommand_Type BaseCommand::PRODUCER_SUCCESS;
constexpr BaseCommand_Type BaseCommand::PING;
constexpr BaseCommand_Type BaseCommand::PONG;
constexpr BaseCommand_Type BaseCommand::REDELIVER_UNACKNOWLEDGED_MESSAGES;
constexpr BaseCommand_Type BaseCommand::PARTITIONED_METADATA;
constexpr BaseCommand_Type BaseCommand::PARTITIONED_METADATA_RESPONSE;
constexpr BaseCommand_Type BaseCommand::LOOKUP;
constexpr BaseCommand_Type BaseCommand::LOOKUP_RESPONSE;
constexpr BaseCommand_Type BaseCommand::CONSUMER_STATS;
constexpr BaseCommand_Type BaseCommand::CONSUMER_STATS_RESPONSE;
constexpr BaseCommand_Type BaseCommand::REACHED_END_OF_TOPIC;
constexpr BaseCommand_Type BaseCommand::SEEK;
constexpr BaseCommand_Type BaseCommand::GET_LAST_MESSAGE_ID;
constexpr BaseCommand_Type BaseCommand::GET_LAST_MESSAGE_ID_RESPONSE;
constexpr BaseCommand_Type BaseCommand::ACTIVE_CONSUMER_CHANGE;
constexpr BaseCommand_Type BaseCommand::GET_TOPICS_OF_NAMESPACE;
constexpr BaseCommand_Type BaseCommand::GET_TOPICS_OF_NAMESPACE_RESPONSE;
constexpr BaseCommand_Type BaseCommand::GET_SCHEMA;
constexpr BaseCommand_Type BaseCommand::GET_SCHEMA_RESPONSE;
constexpr BaseCommand_Type BaseCommand::AUTH_CHALLENGE;
constexpr BaseCommand_Type BaseCommand::AUTH_RESPONSE;
constexpr BaseCommand_Type BaseCommand::ACK_RESPONSE;
constexpr BaseCommand_Type BaseCommand::GET_OR_CREATE_SCHEMA;
constexpr BaseCommand_Type BaseCommand::GET_OR_CREATE_SCHEMA_RESPONSE;
constexpr BaseCommand_Type BaseCommand::NEW_TXN;
constexpr BaseCommand_Type BaseCommand::NEW_TXN_RESPONSE;
constexpr BaseCommand_Type BaseCommand::ADD_PARTITION_TO_TXN;
constexpr BaseCommand_Type BaseCommand::ADD_PARTITION_TO_TXN_RESPONSE;
constexpr BaseCommand_Type BaseCommand::ADD_SUBSCRIPTION_TO_TXN;
constexpr BaseCommand_Type BaseCommand::ADD_SUBSCRIPTION_TO_TXN_RESPONSE;
constexpr BaseCommand_Type BaseCommand::END_TXN;
constexpr BaseCommand_Type BaseCommand::END_TXN_RESPONSE;
constexpr BaseCommand_Type BaseCommand::END_TXN_ON_PARTITION;
constexpr BaseCommand_Type BaseCommand::END_TXN_ON_PARTITION_RESPONSE;
constexpr BaseCommand_Type BaseCommand::END_TXN_ON_SUBSCRIPTION;
constexpr BaseCommand_Type BaseCommand::END_TXN_ON_SUBSCRIPTION_RESPONSE;
constexpr BaseCommand_Type BaseCommand::TC_CLIENT_CONNECT_REQUEST;
constexpr BaseCommand_Type BaseCommand::TC_CLIENT_CONNECT_RESPONSE;
constexpr BaseCommand_Type BaseCommand::WATCH_TOPIC_LIST;
constexpr BaseCommand_Type BaseCommand::WATCH_TOPIC_LIST_SUCCESS;
constexpr BaseCommand_Type BaseCommand::WATCH_TOPIC_UPDATE;
constexpr BaseCommand_Type BaseCommand::WATCH_TOPIC_LIST_CLOSE;
constexpr BaseCommand_Type BaseCommand::TOPIC_MIGRATED;
constexpr BaseCommand_Type BaseCommand::Type_MIN;
constexpr BaseCommand_Type BaseCommand::Type_MAX;
constexpr int BaseCommand::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t CompressionType_internal_data_[] = {
    327680u, 0u, };
bool CompressionType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    CompressionType_strings[5] = {};

static const char CompressionType_names[] = {
    "LZ4"
    "NONE"
    "SNAPPY"
    "ZLIB"
    "ZSTD"
};

static const ::google::protobuf::internal::EnumEntry CompressionType_entries[] =
    {
        {{&CompressionType_names[0], 3}, 1},
        {{&CompressionType_names[3], 4}, 0},
        {{&CompressionType_names[7], 6}, 4},
        {{&CompressionType_names[13], 4}, 2},
        {{&CompressionType_names[17], 4}, 3},
};

static const int CompressionType_entries_by_number[] = {
    1,  // 0 -> NONE
    0,  // 1 -> LZ4
    3,  // 2 -> ZLIB
    4,  // 3 -> ZSTD
    2,  // 4 -> SNAPPY
};

const std::string& CompressionType_Name(CompressionType value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          CompressionType_entries, CompressionType_entries_by_number,
          5, CompressionType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      CompressionType_entries, CompressionType_entries_by_number, 5,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : CompressionType_strings[idx].get();
}

bool CompressionType_Parse(absl::string_view name, CompressionType* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      CompressionType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<CompressionType>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t ProducerAccessMode_internal_data_[] = {
    262144u, 0u, };
bool ProducerAccessMode_IsValid(int value) {
  return 0 <= value && value <= 3;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    ProducerAccessMode_strings[4] = {};

static const char ProducerAccessMode_names[] = {
    "Exclusive"
    "ExclusiveWithFencing"
    "Shared"
    "WaitForExclusive"
};

static const ::google::protobuf::internal::EnumEntry ProducerAccessMode_entries[] =
    {
        {{&ProducerAccessMode_names[0], 9}, 1},
        {{&ProducerAccessMode_names[9], 20}, 3},
        {{&ProducerAccessMode_names[29], 6}, 0},
        {{&ProducerAccessMode_names[35], 16}, 2},
};

static const int ProducerAccessMode_entries_by_number[] = {
    2,  // 0 -> Shared
    0,  // 1 -> Exclusive
    3,  // 2 -> WaitForExclusive
    1,  // 3 -> ExclusiveWithFencing
};

const std::string& ProducerAccessMode_Name(ProducerAccessMode value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          ProducerAccessMode_entries, ProducerAccessMode_entries_by_number,
          4, ProducerAccessMode_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      ProducerAccessMode_entries, ProducerAccessMode_entries_by_number, 4,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : ProducerAccessMode_strings[idx].get();
}

bool ProducerAccessMode_Parse(absl::string_view name, ProducerAccessMode* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      ProducerAccessMode_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ProducerAccessMode>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t ServerError_internal_data_[] = {
    1703936u, 0u, };
bool ServerError_IsValid(int value) {
  return 0 <= value && value <= 25;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    ServerError_strings[26] = {};

static const char ServerError_names[] = {
    "AuthenticationError"
    "AuthorizationError"
    "ChecksumError"
    "ConsumerAssignError"
    "ConsumerBusy"
    "ConsumerNotFound"
    "IncompatibleSchema"
    "InvalidTopicName"
    "InvalidTxnStatus"
    "MetadataError"
    "NotAllowedError"
    "PersistenceError"
    "ProducerBlockedQuotaExceededError"
    "ProducerBlockedQuotaExceededException"
    "ProducerBusy"
    "ProducerFenced"
    "ServiceNotReady"
    "SubscriptionNotFound"
    "TooManyRequests"
    "TopicNotFound"
    "TopicTerminatedError"
    "TransactionConflict"
    "TransactionCoordinatorNotFound"
    "TransactionNotFound"
    "UnknownError"
    "UnsupportedVersionError"
};

static const ::google::protobuf::internal::EnumEntry ServerError_entries[] =
    {
        {{&ServerError_names[0], 19}, 3},
        {{&ServerError_names[19], 18}, 4},
        {{&ServerError_names[37], 13}, 9},
        {{&ServerError_names[50], 19}, 19},
        {{&ServerError_names[69], 12}, 5},
        {{&ServerError_names[81], 16}, 13},
        {{&ServerError_names[97], 18}, 18},
        {{&ServerError_names[115], 16}, 17},
        {{&ServerError_names[131], 16}, 21},
        {{&ServerError_names[147], 13}, 1},
        {{&ServerError_names[160], 15}, 22},
        {{&ServerError_names[175], 16}, 2},
        {{&ServerError_names[191], 33}, 7},
        {{&ServerError_names[224], 37}, 8},
        {{&ServerError_names[261], 12}, 16},
        {{&ServerError_names[273], 14}, 25},
        {{&ServerError_names[287], 15}, 6},
        {{&ServerError_names[302], 20}, 12},
        {{&ServerError_names[322], 15}, 14},
        {{&ServerError_names[337], 13}, 11},
        {{&ServerError_names[350], 20}, 15},
        {{&ServerError_names[370], 19}, 23},
        {{&ServerError_names[389], 30}, 20},
        {{&ServerError_names[419], 19}, 24},
        {{&ServerError_names[438], 12}, 0},
        {{&ServerError_names[450], 23}, 10},
};

static const int ServerError_entries_by_number[] = {
    24,  // 0 -> UnknownError
    9,  // 1 -> MetadataError
    11,  // 2 -> PersistenceError
    0,  // 3 -> AuthenticationError
    1,  // 4 -> AuthorizationError
    4,  // 5 -> ConsumerBusy
    16,  // 6 -> ServiceNotReady
    12,  // 7 -> ProducerBlockedQuotaExceededError
    13,  // 8 -> ProducerBlockedQuotaExceededException
    2,  // 9 -> ChecksumError
    25,  // 10 -> UnsupportedVersionError
    19,  // 11 -> TopicNotFound
    17,  // 12 -> SubscriptionNotFound
    5,  // 13 -> ConsumerNotFound
    18,  // 14 -> TooManyRequests
    20,  // 15 -> TopicTerminatedError
    14,  // 16 -> ProducerBusy
    7,  // 17 -> InvalidTopicName
    6,  // 18 -> IncompatibleSchema
    3,  // 19 -> ConsumerAssignError
    22,  // 20 -> TransactionCoordinatorNotFound
    8,  // 21 -> InvalidTxnStatus
    10,  // 22 -> NotAllowedError
    21,  // 23 -> TransactionConflict
    23,  // 24 -> TransactionNotFound
    15,  // 25 -> ProducerFenced
};

const std::string& ServerError_Name(ServerError value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          ServerError_entries, ServerError_entries_by_number,
          26, ServerError_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      ServerError_entries, ServerError_entries_by_number, 26,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : ServerError_strings[idx].get();
}

bool ServerError_Parse(absl::string_view name, ServerError* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      ServerError_entries, 26, name, &int_value);
  if (success) {
    *value = static_cast<ServerError>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t AuthMethod_internal_data_[] = {
    196608u, 0u, };
bool AuthMethod_IsValid(int value) {
  return 0 <= value && value <= 2;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    AuthMethod_strings[3] = {};

static const char AuthMethod_names[] = {
    "AuthMethodAthens"
    "AuthMethodNone"
    "AuthMethodYcaV1"
};

static const ::google::protobuf::internal::EnumEntry AuthMethod_entries[] =
    {
        {{&AuthMethod_names[0], 16}, 2},
        {{&AuthMethod_names[16], 14}, 0},
        {{&AuthMethod_names[30], 15}, 1},
};

static const int AuthMethod_entries_by_number[] = {
    1,  // 0 -> AuthMethodNone
    2,  // 1 -> AuthMethodYcaV1
    0,  // 2 -> AuthMethodAthens
};

const std::string& AuthMethod_Name(AuthMethod value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          AuthMethod_entries, AuthMethod_entries_by_number,
          3, AuthMethod_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      AuthMethod_entries, AuthMethod_entries_by_number, 3,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : AuthMethod_strings[idx].get();
}

bool AuthMethod_Parse(absl::string_view name, AuthMethod* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      AuthMethod_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<AuthMethod>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t ProtocolVersion_internal_data_[] = {
    1376256u, 0u, };
bool ProtocolVersion_IsValid(int value) {
  return 0 <= value && value <= 20;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    ProtocolVersion_strings[21] = {};

static const char ProtocolVersion_names[] = {
    "v0"
    "v1"
    "v10"
    "v11"
    "v12"
    "v13"
    "v14"
    "v15"
    "v16"
    "v17"
    "v18"
    "v19"
    "v2"
    "v20"
    "v3"
    "v4"
    "v5"
    "v6"
    "v7"
    "v8"
    "v9"
};

static const ::google::protobuf::internal::EnumEntry ProtocolVersion_entries[] =
    {
        {{&ProtocolVersion_names[0], 2}, 0},
        {{&ProtocolVersion_names[2], 2}, 1},
        {{&ProtocolVersion_names[4], 3}, 10},
        {{&ProtocolVersion_names[7], 3}, 11},
        {{&ProtocolVersion_names[10], 3}, 12},
        {{&ProtocolVersion_names[13], 3}, 13},
        {{&ProtocolVersion_names[16], 3}, 14},
        {{&ProtocolVersion_names[19], 3}, 15},
        {{&ProtocolVersion_names[22], 3}, 16},
        {{&ProtocolVersion_names[25], 3}, 17},
        {{&ProtocolVersion_names[28], 3}, 18},
        {{&ProtocolVersion_names[31], 3}, 19},
        {{&ProtocolVersion_names[34], 2}, 2},
        {{&ProtocolVersion_names[36], 3}, 20},
        {{&ProtocolVersion_names[39], 2}, 3},
        {{&ProtocolVersion_names[41], 2}, 4},
        {{&ProtocolVersion_names[43], 2}, 5},
        {{&ProtocolVersion_names[45], 2}, 6},
        {{&ProtocolVersion_names[47], 2}, 7},
        {{&ProtocolVersion_names[49], 2}, 8},
        {{&ProtocolVersion_names[51], 2}, 9},
};

static const int ProtocolVersion_entries_by_number[] = {
    0,  // 0 -> v0
    1,  // 1 -> v1
    12,  // 2 -> v2
    14,  // 3 -> v3
    15,  // 4 -> v4
    16,  // 5 -> v5
    17,  // 6 -> v6
    18,  // 7 -> v7
    19,  // 8 -> v8
    20,  // 9 -> v9
    2,  // 10 -> v10
    3,  // 11 -> v11
    4,  // 12 -> v12
    5,  // 13 -> v13
    6,  // 14 -> v14
    7,  // 15 -> v15
    8,  // 16 -> v16
    9,  // 17 -> v17
    10,  // 18 -> v18
    11,  // 19 -> v19
    13,  // 20 -> v20
};

const std::string& ProtocolVersion_Name(ProtocolVersion value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          ProtocolVersion_entries, ProtocolVersion_entries_by_number,
          21, ProtocolVersion_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      ProtocolVersion_entries, ProtocolVersion_entries_by_number, 21,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : ProtocolVersion_strings[idx].get();
}

bool ProtocolVersion_Parse(absl::string_view name, ProtocolVersion* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      ProtocolVersion_entries, 21, name, &int_value);
  if (success) {
    *value = static_cast<ProtocolVersion>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t KeySharedMode_internal_data_[] = {
    131072u, 0u, };
bool KeySharedMode_IsValid(int value) {
  return 0 <= value && value <= 1;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    KeySharedMode_strings[2] = {};

static const char KeySharedMode_names[] = {
    "AUTO_SPLIT"
    "STICKY"
};

static const ::google::protobuf::internal::EnumEntry KeySharedMode_entries[] =
    {
        {{&KeySharedMode_names[0], 10}, 0},
        {{&KeySharedMode_names[10], 6}, 1},
};

static const int KeySharedMode_entries_by_number[] = {
    0,  // 0 -> AUTO_SPLIT
    1,  // 1 -> STICKY
};

const std::string& KeySharedMode_Name(KeySharedMode value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          KeySharedMode_entries, KeySharedMode_entries_by_number,
          2, KeySharedMode_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      KeySharedMode_entries, KeySharedMode_entries_by_number, 2,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : KeySharedMode_strings[idx].get();
}

bool KeySharedMode_Parse(absl::string_view name, KeySharedMode* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      KeySharedMode_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<KeySharedMode>(int_value);
  }
  return success;
}
PROTOBUF_CONSTINIT const uint32_t TxnAction_internal_data_[] = {
    131072u, 0u, };
bool TxnAction_IsValid(int value) {
  return 0 <= value && value <= 1;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    TxnAction_strings[2] = {};

static const char TxnAction_names[] = {
    "ABORT"
    "COMMIT"
};

static const ::google::protobuf::internal::EnumEntry TxnAction_entries[] =
    {
        {{&TxnAction_names[0], 5}, 1},
        {{&TxnAction_names[5], 6}, 0},
};

static const int TxnAction_entries_by_number[] = {
    1,  // 0 -> COMMIT
    0,  // 1 -> ABORT
};

const std::string& TxnAction_Name(TxnAction value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          TxnAction_entries, TxnAction_entries_by_number,
          2, TxnAction_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      TxnAction_entries, TxnAction_entries_by_number, 2,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : TxnAction_strings[idx].get();
}

bool TxnAction_Parse(absl::string_view name, TxnAction* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      TxnAction_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<TxnAction>(int_value);
  }
  return success;
}
// ===================================================================

class Schema::_Internal {
 public:
  using HasBits = decltype(std::declval<Schema>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Schema, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_schema_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

Schema::Schema(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.Schema)
}
inline PROTOBUF_NDEBUG_INLINE Schema::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        properties_{visibility, arena, from.properties_},
        name_(arena, from.name_),
        schema_data_(arena, from.schema_data_) {}

Schema::Schema(
    ::google::protobuf::Arena* arena,
    const Schema& from)
    : ::google::protobuf::MessageLite(arena) {
  Schema* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  _impl_.type_ = from._impl_.type_;

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.Schema)
}
inline PROTOBUF_NDEBUG_INLINE Schema::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        properties_{visibility, arena},
        name_(arena),
        schema_data_(arena) {}

inline void Schema::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.type_ = {};
}
Schema::~Schema() {
  // @@protoc_insertion_point(destructor:pulsar.proto.Schema)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void Schema::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.name_.Destroy();
  _impl_.schema_data_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void Schema::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.Schema)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.properties_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.schema_data_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Schema::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 4, 2, 0, 2> Schema::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Schema, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967266,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Schema_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string name = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Schema, _impl_.name_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // required bytes schema_data = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 1, 0, PROTOBUF_FIELD_OFFSET(Schema, _impl_.schema_data_)}},
    // required .pulsar.proto.Schema.Type type = 4;
    {::_pbi::TcParser::FastEr0S1,
     {32, 2, 20, PROTOBUF_FIELD_OFFSET(Schema, _impl_.type_)}},
    // repeated .pulsar.proto.KeyValue properties = 5;
    {::_pbi::TcParser::FastMtR1,
     {42, 63, 1, PROTOBUF_FIELD_OFFSET(Schema, _impl_.properties_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required string name = 1;
    {PROTOBUF_FIELD_OFFSET(Schema, _impl_.name_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // required bytes schema_data = 3;
    {PROTOBUF_FIELD_OFFSET(Schema, _impl_.schema_data_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // required .pulsar.proto.Schema.Type type = 4;
    {PROTOBUF_FIELD_OFFSET(Schema, _impl_.type_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // repeated .pulsar.proto.KeyValue properties = 5;
    {PROTOBUF_FIELD_OFFSET(Schema, _impl_.properties_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {0, 21},
    {::_pbi::TcParser::GetTable<::pulsar::proto::KeyValue>()},
  }}, {{
  }},
};

::uint8_t* Schema::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.Schema)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_name();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required bytes schema_data = 3;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_schema_data();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  // required .pulsar.proto.Schema.Type type = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_type(), target);
  }

  // repeated .pulsar.proto.KeyValue properties = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_properties().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.Schema)
  return target;
}

::size_t Schema::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.Schema)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.KeyValue properties = 5;
  total_size += 1UL * this->_internal_properties_size();
  for (const auto& msg : this->_internal_properties()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // required string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_name());
    }

    // required bytes schema_data = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_schema_data());
    }

    // required .pulsar.proto.Schema.Type type = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void Schema::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Schema*>(
      &from));
}

void Schema::MergeFrom(const Schema& from) {
  Schema* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.Schema)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_properties()->MergeFrom(
      from._internal_properties());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_schema_data(from._internal_schema_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Schema::CopyFrom(const Schema& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.Schema)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Schema::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_properties()))
    return false;
  return true;
}

::_pbi::CachedSize* Schema::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void Schema::InternalSwap(Schema* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.properties_.InternalSwap(&other->_impl_.properties_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.schema_data_, &other->_impl_.schema_data_, arena);
  swap(_impl_.type_, other->_impl_.type_);
}

std::string Schema::GetTypeName() const {
  return "pulsar.proto.Schema";
}

// ===================================================================

class MessageIdData::_Internal {
 public:
  using HasBits = decltype(std::declval<MessageIdData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_._has_bits_);
  static void set_has_ledgerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_entryid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_partition(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_batch_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_batch_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::pulsar::proto::MessageIdData& first_chunk_message_id(const MessageIdData* msg);
  static void set_has_first_chunk_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

const ::pulsar::proto::MessageIdData& MessageIdData::_Internal::first_chunk_message_id(const MessageIdData* msg) {
  return *msg->_impl_.first_chunk_message_id_;
}
MessageIdData::MessageIdData(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.MessageIdData)
}
inline PROTOBUF_NDEBUG_INLINE MessageIdData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        ack_set_{visibility, arena, from.ack_set_} {}

MessageIdData::MessageIdData(
    ::google::protobuf::Arena* arena,
    const MessageIdData& from)
    : ::google::protobuf::MessageLite(arena) {
  MessageIdData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.first_chunk_message_id_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::pulsar::proto::MessageIdData>(arena, *from._impl_.first_chunk_message_id_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, ledgerid_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, ledgerid_),
           offsetof(Impl_, batch_index_) -
               offsetof(Impl_, ledgerid_) +
               sizeof(Impl_::batch_index_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.MessageIdData)
}
inline PROTOBUF_NDEBUG_INLINE MessageIdData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        ack_set_{visibility, arena},
        partition_{-1},
        batch_index_{-1} {}

inline void MessageIdData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, first_chunk_message_id_),
           0,
           offsetof(Impl_, batch_size_) -
               offsetof(Impl_, first_chunk_message_id_) +
               sizeof(Impl_::batch_size_));
}
MessageIdData::~MessageIdData() {
  // @@protoc_insertion_point(destructor:pulsar.proto.MessageIdData)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void MessageIdData::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.first_chunk_message_id_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void MessageIdData::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.MessageIdData)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ack_set_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.first_chunk_message_id_ != nullptr);
    _impl_.first_chunk_message_id_->Clear();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.ledgerid_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.batch_size_) -
        reinterpret_cast<char*>(&_impl_.ledgerid_)) + sizeof(_impl_.batch_size_));
    _impl_.partition_ = -1;
    _impl_.batch_index_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MessageIdData::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 1, 0, 2> MessageIdData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_MessageIdData_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 ledgerId = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_.ledgerid_)}},
    // required uint64 entryId = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_.entryid_)}},
    // optional int32 partition = 3 [default = -1];
    {::_pbi::TcParser::FastV32S1,
     {24, 4, 0, PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_.partition_)}},
    // optional int32 batch_index = 4 [default = -1];
    {::_pbi::TcParser::FastV32S1,
     {32, 5, 0, PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_.batch_index_)}},
    // repeated int64 ack_set = 5;
    {::_pbi::TcParser::FastV64R1,
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_.ack_set_)}},
    // optional int32 batch_size = 6;
    {::_pbi::TcParser::FastV32S1,
     {48, 3, 0, PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_.batch_size_)}},
    // optional .pulsar.proto.MessageIdData first_chunk_message_id = 7;
    {::_pbi::TcParser::FastMtS1,
     {58, 0, 0, PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_.first_chunk_message_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 ledgerId = 1;
    {PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_.ledgerid_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint64 entryId = 2;
    {PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_.entryid_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional int32 partition = 3 [default = -1];
    {PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_.partition_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 batch_index = 4 [default = -1];
    {PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_.batch_index_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // repeated int64 ack_set = 5;
    {PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_.ack_set_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt64)},
    // optional int32 batch_size = 6;
    {PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_.batch_size_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional .pulsar.proto.MessageIdData first_chunk_message_id = 7;
    {PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_.first_chunk_message_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::MessageIdData>()},
  }}, {{
  }},
};

::uint8_t* MessageIdData::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.MessageIdData)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 ledgerId = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_ledgerid(), target);
  }

  // required uint64 entryId = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_entryid(), target);
  }

  // optional int32 partition = 3 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_partition(), target);
  }

  // optional int32 batch_index = 4 [default = -1];
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<4>(
            stream, this->_internal_batch_index(), target);
  }

  // repeated int64 ack_set = 5;
  for (int i = 0, n = this->_internal_ack_set_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        5, this->_internal_ack_set().Get(i), target);
  }

  // optional int32 batch_size = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<6>(
            stream, this->_internal_batch_size(), target);
  }

  // optional .pulsar.proto.MessageIdData first_chunk_message_id = 7;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        7, _Internal::first_chunk_message_id(this),
        _Internal::first_chunk_message_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.MessageIdData)
  return target;
}

::size_t MessageIdData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.MessageIdData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 ack_set = 5;
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int64Size(
        this->_internal_ack_set())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_ack_set_size());
    ;
    total_size += tag_size + data_size;
  }
  // optional .pulsar.proto.MessageIdData first_chunk_message_id = 7;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.first_chunk_message_id_);
  }

  if (cached_has_bits & 0x00000006u) {
    // required uint64 ledgerId = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_ledgerid());
    }

    // required uint64 entryId = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_entryid());
    }

  }
  if (cached_has_bits & 0x00000038u) {
    // optional int32 batch_size = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_batch_size());
    }

    // optional int32 partition = 3 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_partition());
    }

    // optional int32 batch_index = 4 [default = -1];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_batch_index());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void MessageIdData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MessageIdData*>(
      &from));
}

void MessageIdData::MergeFrom(const MessageIdData& from) {
  MessageIdData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.MessageIdData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_ack_set()->MergeFrom(from._internal_ack_set());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_first_chunk_message_id()->::pulsar::proto::MessageIdData::MergeFrom(
          from._internal_first_chunk_message_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ledgerid_ = from._impl_.ledgerid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.entryid_ = from._impl_.entryid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.batch_size_ = from._impl_.batch_size_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.partition_ = from._impl_.partition_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.batch_index_ = from._impl_.batch_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MessageIdData::CopyFrom(const MessageIdData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.MessageIdData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool MessageIdData::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.first_chunk_message_id_->IsInitialized()) return false;
  }
  return true;
}

::_pbi::CachedSize* MessageIdData::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void MessageIdData::InternalSwap(MessageIdData* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.ack_set_.InternalSwap(&other->_impl_.ack_set_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_.batch_index_)
      + sizeof(MessageIdData::_impl_.batch_index_)
      - PROTOBUF_FIELD_OFFSET(MessageIdData, _impl_.first_chunk_message_id_)>(
          reinterpret_cast<char*>(&_impl_.first_chunk_message_id_),
          reinterpret_cast<char*>(&other->_impl_.first_chunk_message_id_));
}

std::string MessageIdData::GetTypeName() const {
  return "pulsar.proto.MessageIdData";
}

// ===================================================================

class KeyValue::_Internal {
 public:
  using HasBits = decltype(std::declval<KeyValue>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KeyValue, _impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

KeyValue::KeyValue(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.KeyValue)
}
inline PROTOBUF_NDEBUG_INLINE KeyValue::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        key_(arena, from.key_),
        value_(arena, from.value_) {}

KeyValue::KeyValue(
    ::google::protobuf::Arena* arena,
    const KeyValue& from)
    : ::google::protobuf::MessageLite(arena) {
  KeyValue* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.KeyValue)
}
inline PROTOBUF_NDEBUG_INLINE KeyValue::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        key_(arena),
        value_(arena) {}

inline void KeyValue::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
KeyValue::~KeyValue() {
  // @@protoc_insertion_point(destructor:pulsar.proto.KeyValue)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void KeyValue::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.key_.Destroy();
  _impl_.value_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void KeyValue::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.KeyValue)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KeyValue::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> KeyValue::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(KeyValue, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_KeyValue_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // required string value = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(KeyValue, _impl_.value_)}},
    // required string key = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(KeyValue, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string key = 1;
    {PROTOBUF_FIELD_OFFSET(KeyValue, _impl_.key_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // required string value = 2;
    {PROTOBUF_FIELD_OFFSET(KeyValue, _impl_.value_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* KeyValue::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.KeyValue)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string key = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_key();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required string value = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_value();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.KeyValue)
  return target;
}

::size_t KeyValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.KeyValue)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required string key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_key());
    }

    // required string value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void KeyValue::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KeyValue*>(
      &from));
}

void KeyValue::MergeFrom(const KeyValue& from) {
  KeyValue* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.KeyValue)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KeyValue::CopyFrom(const KeyValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.KeyValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool KeyValue::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* KeyValue::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void KeyValue::InternalSwap(KeyValue* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, &other->_impl_.key_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.value_, &other->_impl_.value_, arena);
}

std::string KeyValue::GetTypeName() const {
  return "pulsar.proto.KeyValue";
}

// ===================================================================

class KeyLongValue::_Internal {
 public:
  using HasBits = decltype(std::declval<KeyLongValue>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KeyLongValue, _impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

KeyLongValue::KeyLongValue(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.KeyLongValue)
}
inline PROTOBUF_NDEBUG_INLINE KeyLongValue::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        key_(arena, from.key_) {}

KeyLongValue::KeyLongValue(
    ::google::protobuf::Arena* arena,
    const KeyLongValue& from)
    : ::google::protobuf::MessageLite(arena) {
  KeyLongValue* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  _impl_.value_ = from._impl_.value_;

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.KeyLongValue)
}
inline PROTOBUF_NDEBUG_INLINE KeyLongValue::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        key_(arena) {}

inline void KeyLongValue::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.value_ = {};
}
KeyLongValue::~KeyLongValue() {
  // @@protoc_insertion_point(destructor:pulsar.proto.KeyLongValue)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void KeyLongValue::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.key_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void KeyLongValue::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.KeyLongValue)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.key_.ClearNonDefaultToEmpty();
  }
  _impl_.value_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KeyLongValue::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> KeyLongValue::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(KeyLongValue, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_KeyLongValue_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // required uint64 value = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(KeyLongValue, _impl_.value_)}},
    // required string key = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(KeyLongValue, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string key = 1;
    {PROTOBUF_FIELD_OFFSET(KeyLongValue, _impl_.key_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // required uint64 value = 2;
    {PROTOBUF_FIELD_OFFSET(KeyLongValue, _impl_.value_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* KeyLongValue::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.KeyLongValue)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string key = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_key();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required uint64 value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.KeyLongValue)
  return target;
}

::size_t KeyLongValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.KeyLongValue)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required string key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_key());
    }

    // required uint64 value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void KeyLongValue::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KeyLongValue*>(
      &from));
}

void KeyLongValue::MergeFrom(const KeyLongValue& from) {
  KeyLongValue* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.KeyLongValue)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KeyLongValue::CopyFrom(const KeyLongValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.KeyLongValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool KeyLongValue::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* KeyLongValue::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void KeyLongValue::InternalSwap(KeyLongValue* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, &other->_impl_.key_, arena);
        swap(_impl_.value_, other->_impl_.value_);
}

std::string KeyLongValue::GetTypeName() const {
  return "pulsar.proto.KeyLongValue";
}

// ===================================================================

class IntRange::_Internal {
 public:
  using HasBits = decltype(std::declval<IntRange>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IntRange, _impl_._has_bits_);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

IntRange::IntRange(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.IntRange)
}
IntRange::IntRange(
    ::google::protobuf::Arena* arena, const IntRange& from)
    : IntRange(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE IntRange::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void IntRange::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, start_),
           0,
           offsetof(Impl_, end_) -
               offsetof(Impl_, start_) +
               sizeof(Impl_::end_));
}
IntRange::~IntRange() {
  // @@protoc_insertion_point(destructor:pulsar.proto.IntRange)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void IntRange::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void IntRange::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.IntRange)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.start_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.end_) -
        reinterpret_cast<char*>(&_impl_.start_)) + sizeof(_impl_.end_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IntRange::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> IntRange::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(IntRange, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_IntRange_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // required int32 end = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(IntRange, _impl_.end_)}},
    // required int32 start = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(IntRange, _impl_.start_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required int32 start = 1;
    {PROTOBUF_FIELD_OFFSET(IntRange, _impl_.start_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // required int32 end = 2;
    {PROTOBUF_FIELD_OFFSET(IntRange, _impl_.end_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* IntRange::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.IntRange)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 start = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<1>(
            stream, this->_internal_start(), target);
  }

  // required int32 end = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<2>(
            stream, this->_internal_end(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.IntRange)
  return target;
}

::size_t IntRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.IntRange)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required int32 start = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_start());
    }

    // required int32 end = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_end());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void IntRange::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IntRange*>(
      &from));
}

void IntRange::MergeFrom(const IntRange& from) {
  IntRange* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.IntRange)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.start_ = from._impl_.start_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.end_ = from._impl_.end_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IntRange::CopyFrom(const IntRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.IntRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool IntRange::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* IntRange::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void IntRange::InternalSwap(IntRange* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IntRange, _impl_.end_)
      + sizeof(IntRange::_impl_.end_)
      - PROTOBUF_FIELD_OFFSET(IntRange, _impl_.start_)>(
          reinterpret_cast<char*>(&_impl_.start_),
          reinterpret_cast<char*>(&other->_impl_.start_));
}

std::string IntRange::GetTypeName() const {
  return "pulsar.proto.IntRange";
}

// ===================================================================

class EncryptionKeys::_Internal {
 public:
  using HasBits = decltype(std::declval<EncryptionKeys>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EncryptionKeys, _impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

EncryptionKeys::EncryptionKeys(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.EncryptionKeys)
}
inline PROTOBUF_NDEBUG_INLINE EncryptionKeys::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        metadata_{visibility, arena, from.metadata_},
        key_(arena, from.key_),
        value_(arena, from.value_) {}

EncryptionKeys::EncryptionKeys(
    ::google::protobuf::Arena* arena,
    const EncryptionKeys& from)
    : ::google::protobuf::MessageLite(arena) {
  EncryptionKeys* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.EncryptionKeys)
}
inline PROTOBUF_NDEBUG_INLINE EncryptionKeys::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        metadata_{visibility, arena},
        key_(arena),
        value_(arena) {}

inline void EncryptionKeys::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
EncryptionKeys::~EncryptionKeys() {
  // @@protoc_insertion_point(destructor:pulsar.proto.EncryptionKeys)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void EncryptionKeys::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.key_.Destroy();
  _impl_.value_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void EncryptionKeys::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.EncryptionKeys)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metadata_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EncryptionKeys::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> EncryptionKeys::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(EncryptionKeys, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_EncryptionKeys_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string key = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(EncryptionKeys, _impl_.key_)}},
    // required bytes value = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(EncryptionKeys, _impl_.value_)}},
    // repeated .pulsar.proto.KeyValue metadata = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(EncryptionKeys, _impl_.metadata_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string key = 1;
    {PROTOBUF_FIELD_OFFSET(EncryptionKeys, _impl_.key_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // required bytes value = 2;
    {PROTOBUF_FIELD_OFFSET(EncryptionKeys, _impl_.value_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // repeated .pulsar.proto.KeyValue metadata = 3;
    {PROTOBUF_FIELD_OFFSET(EncryptionKeys, _impl_.metadata_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::KeyValue>()},
  }}, {{
  }},
};

::uint8_t* EncryptionKeys::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.EncryptionKeys)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string key = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_key();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required bytes value = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_value();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // repeated .pulsar.proto.KeyValue metadata = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_metadata_size()); i < n; i++) {
    const auto& repfield = this->_internal_metadata().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.EncryptionKeys)
  return target;
}

::size_t EncryptionKeys::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.EncryptionKeys)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.KeyValue metadata = 3;
  total_size += 1UL * this->_internal_metadata_size();
  for (const auto& msg : this->_internal_metadata()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required string key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_key());
    }

    // required bytes value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void EncryptionKeys::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EncryptionKeys*>(
      &from));
}

void EncryptionKeys::MergeFrom(const EncryptionKeys& from) {
  EncryptionKeys* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.EncryptionKeys)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_metadata()->MergeFrom(
      from._internal_metadata());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EncryptionKeys::CopyFrom(const EncryptionKeys& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.EncryptionKeys)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool EncryptionKeys::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_metadata()))
    return false;
  return true;
}

::_pbi::CachedSize* EncryptionKeys::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void EncryptionKeys::InternalSwap(EncryptionKeys* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, &other->_impl_.key_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.value_, &other->_impl_.value_, arena);
}

std::string EncryptionKeys::GetTypeName() const {
  return "pulsar.proto.EncryptionKeys";
}

// ===================================================================

class MessageMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<MessageMetadata>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_._has_bits_);
  static void set_has_producer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_publish_time(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_replicated_from(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_partition_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_compression(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_uncompressed_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_num_messages_in_batch(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_event_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_encryption_algo(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_encryption_param(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_schema_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_partition_key_b64_encoded(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_ordering_key(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_deliver_at_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_marker_type(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_highest_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_null_value(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_uuid(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_num_chunks_from_msg(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_total_chunk_msg_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_chunk_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_null_partition_key(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000301) ^ 0x00000301) != 0;
  }
};

MessageMetadata::MessageMetadata(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.MessageMetadata)
}
inline PROTOBUF_NDEBUG_INLINE MessageMetadata::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        properties_{visibility, arena, from.properties_},
        replicate_to_{visibility, arena, from.replicate_to_},
        encryption_keys_{visibility, arena, from.encryption_keys_},
        producer_name_(arena, from.producer_name_),
        replicated_from_(arena, from.replicated_from_),
        partition_key_(arena, from.partition_key_),
        encryption_algo_(arena, from.encryption_algo_),
        encryption_param_(arena, from.encryption_param_),
        schema_version_(arena, from.schema_version_),
        ordering_key_(arena, from.ordering_key_),
        uuid_(arena, from.uuid_) {}

MessageMetadata::MessageMetadata(
    ::google::protobuf::Arena* arena,
    const MessageMetadata& from)
    : ::google::protobuf::MessageLite(arena) {
  MessageMetadata* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, sequence_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, sequence_id_),
           offsetof(Impl_, num_messages_in_batch_) -
               offsetof(Impl_, sequence_id_) +
               sizeof(Impl_::num_messages_in_batch_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.MessageMetadata)
}
inline PROTOBUF_NDEBUG_INLINE MessageMetadata::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        properties_{visibility, arena},
        replicate_to_{visibility, arena},
        encryption_keys_{visibility, arena},
        producer_name_(arena),
        replicated_from_(arena),
        partition_key_(arena),
        encryption_algo_(arena),
        encryption_param_(arena),
        schema_version_(arena),
        ordering_key_(arena),
        uuid_(arena),
        num_messages_in_batch_{1} {}

inline void MessageMetadata::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, sequence_id_),
           0,
           offsetof(Impl_, chunk_id_) -
               offsetof(Impl_, sequence_id_) +
               sizeof(Impl_::chunk_id_));
}
MessageMetadata::~MessageMetadata() {
  // @@protoc_insertion_point(destructor:pulsar.proto.MessageMetadata)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void MessageMetadata::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.producer_name_.Destroy();
  _impl_.replicated_from_.Destroy();
  _impl_.partition_key_.Destroy();
  _impl_.encryption_algo_.Destroy();
  _impl_.encryption_param_.Destroy();
  _impl_.schema_version_.Destroy();
  _impl_.ordering_key_.Destroy();
  _impl_.uuid_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void MessageMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.MessageMetadata)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.properties_.Clear();
  _impl_.replicate_to_.Clear();
  _impl_.encryption_keys_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.producer_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.replicated_from_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.partition_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.encryption_algo_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.encryption_param_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.schema_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.ordering_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.uuid_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.sequence_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.txnid_most_bits_) -
        reinterpret_cast<char*>(&_impl_.sequence_id_)) + sizeof(_impl_.txnid_most_bits_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.marker_type_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.chunk_id_) -
        reinterpret_cast<char*>(&_impl_.marker_type_)) + sizeof(_impl_.chunk_id_));
  }
  _impl_.num_messages_in_batch_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MessageMetadata::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 28, 3, 0, 2> MessageMetadata::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_._has_bits_),
    0, // no _extensions_
    30, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    3222274560,  // skipmap
    offsetof(decltype(_table_), field_entries),
    28,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_MessageMetadata_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string producer_name = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.producer_name_)}},
    // required uint64 sequence_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 8, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.sequence_id_)}},
    // required uint64 publish_time = 3;
    {::_pbi::TcParser::FastV64S1,
     {24, 9, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.publish_time_)}},
    // repeated .pulsar.proto.KeyValue properties = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.properties_)}},
    // optional string replicated_from = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 1, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.replicated_from_)}},
    // optional string partition_key = 6;
    {::_pbi::TcParser::FastBS1,
     {50, 2, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.partition_key_)}},
    // repeated string replicate_to = 7;
    {::_pbi::TcParser::FastBR1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.replicate_to_)}},
    // optional .pulsar.proto.CompressionType compression = 8 [default = NONE];
    {::_pbi::TcParser::FastEr0S1,
     {64, 10, 4, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.compression_)}},
    // optional uint32 uncompressed_size = 9 [default = 0];
    {::_pbi::TcParser::FastV32S1,
     {72, 11, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.uncompressed_size_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional int32 num_messages_in_batch = 11 [default = 1];
    {::_pbi::TcParser::FastV32S1,
     {88, 24, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.num_messages_in_batch_)}},
    // optional uint64 event_time = 12 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {96, 12, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.event_time_)}},
    // repeated .pulsar.proto.EncryptionKeys encryption_keys = 13;
    {::_pbi::TcParser::FastMtR1,
     {106, 63, 2, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.encryption_keys_)}},
    // optional string encryption_algo = 14;
    {::_pbi::TcParser::FastBS1,
     {114, 3, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.encryption_algo_)}},
    // optional bytes encryption_param = 15;
    {::_pbi::TcParser::FastBS1,
     {122, 4, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.encryption_param_)}},
    // optional bytes schema_version = 16;
    {::_pbi::TcParser::FastBS2,
     {386, 5, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.schema_version_)}},
    // optional bool partition_key_b64_encoded = 17 [default = false];
    {::_pbi::TcParser::FastV8S2,
     {392, 17, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.partition_key_b64_encoded_)}},
    // optional bytes ordering_key = 18;
    {::_pbi::TcParser::FastBS2,
     {402, 6, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.ordering_key_)}},
    // optional int64 deliver_at_time = 19;
    {::_pbi::TcParser::FastV64S2,
     {408, 13, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.deliver_at_time_)}},
    // optional int32 marker_type = 20;
    {::_pbi::TcParser::FastV32S2,
     {416, 16, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.marker_type_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint64 txnid_least_bits = 22;
    {::_pbi::TcParser::FastV64S2,
     {432, 14, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.txnid_least_bits_)}},
    // optional uint64 txnid_most_bits = 23;
    {::_pbi::TcParser::FastV64S2,
     {440, 15, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.txnid_most_bits_)}},
    // optional uint64 highest_sequence_id = 24 [default = 0];
    {::_pbi::TcParser::FastV64S2,
     {448, 20, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.highest_sequence_id_)}},
    // optional bool null_value = 25 [default = false];
    {::_pbi::TcParser::FastV8S2,
     {456, 18, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.null_value_)}},
    // optional string uuid = 26;
    {::_pbi::TcParser::FastBS2,
     {466, 7, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.uuid_)}},
    // optional int32 num_chunks_from_msg = 27;
    {::_pbi::TcParser::FastV32S2,
     {472, 21, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.num_chunks_from_msg_)}},
    // optional int32 total_chunk_msg_size = 28;
    {::_pbi::TcParser::FastV32S2,
     {480, 22, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.total_chunk_msg_size_)}},
    // optional int32 chunk_id = 29;
    {::_pbi::TcParser::FastV32S2,
     {488, 23, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.chunk_id_)}},
    // optional bool null_partition_key = 30 [default = false];
    {::_pbi::TcParser::FastV8S2,
     {496, 19, 0, PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.null_partition_key_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required string producer_name = 1;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.producer_name_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // required uint64 sequence_id = 2;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.sequence_id_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint64 publish_time = 3;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.publish_time_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // repeated .pulsar.proto.KeyValue properties = 4;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.properties_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional string replicated_from = 5;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.replicated_from_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string partition_key = 6;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.partition_key_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // repeated string replicate_to = 7;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.replicate_to_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
    // optional .pulsar.proto.CompressionType compression = 8 [default = NONE];
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.compression_), _Internal::kHasBitsOffset + 10, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional uint32 uncompressed_size = 9 [default = 0];
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.uncompressed_size_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional int32 num_messages_in_batch = 11 [default = 1];
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.num_messages_in_batch_), _Internal::kHasBitsOffset + 24, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional uint64 event_time = 12 [default = 0];
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.event_time_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // repeated .pulsar.proto.EncryptionKeys encryption_keys = 13;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.encryption_keys_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional string encryption_algo = 14;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.encryption_algo_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes encryption_param = 15;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.encryption_param_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes schema_version = 16;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.schema_version_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bool partition_key_b64_encoded = 17 [default = false];
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.partition_key_b64_encoded_), _Internal::kHasBitsOffset + 17, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bytes ordering_key = 18;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.ordering_key_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int64 deliver_at_time = 19;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.deliver_at_time_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int32 marker_type = 20;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.marker_type_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional uint64 txnid_least_bits = 22;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.txnid_least_bits_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_most_bits = 23;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.txnid_most_bits_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 highest_sequence_id = 24 [default = 0];
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.highest_sequence_id_), _Internal::kHasBitsOffset + 20, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional bool null_value = 25 [default = false];
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.null_value_), _Internal::kHasBitsOffset + 18, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional string uuid = 26;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.uuid_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int32 num_chunks_from_msg = 27;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.num_chunks_from_msg_), _Internal::kHasBitsOffset + 21, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 total_chunk_msg_size = 28;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.total_chunk_msg_size_), _Internal::kHasBitsOffset + 22, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 chunk_id = 29;
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.chunk_id_), _Internal::kHasBitsOffset + 23, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional bool null_partition_key = 30 [default = false];
    {PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.null_partition_key_), _Internal::kHasBitsOffset + 19, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::KeyValue>()},
    {0, 5},
    {::_pbi::TcParser::GetTable<::pulsar::proto::EncryptionKeys>()},
  }}, {{
  }},
};

::uint8_t* MessageMetadata::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.MessageMetadata)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string producer_name = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_producer_name();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required uint64 sequence_id = 2;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_sequence_id(), target);
  }

  // required uint64 publish_time = 3;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_publish_time(), target);
  }

  // repeated .pulsar.proto.KeyValue properties = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_properties().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string replicated_from = 5;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_replicated_from();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional string partition_key = 6;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_partition_key();
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // repeated string replicate_to = 7;
  for (int i = 0, n = this->_internal_replicate_to_size(); i < n; ++i) {
    const auto& s = this->_internal_replicate_to().Get(i);
    target = stream->WriteString(7, s, target);
  }

  // optional .pulsar.proto.CompressionType compression = 8 [default = NONE];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        8, this->_internal_compression(), target);
  }

  // optional uint32 uncompressed_size = 9 [default = 0];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this->_internal_uncompressed_size(), target);
  }

  // optional int32 num_messages_in_batch = 11 [default = 1];
  if (cached_has_bits & 0x01000000u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<11>(
            stream, this->_internal_num_messages_in_batch(), target);
  }

  // optional uint64 event_time = 12 [default = 0];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        12, this->_internal_event_time(), target);
  }

  // repeated .pulsar.proto.EncryptionKeys encryption_keys = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_encryption_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_encryption_keys().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string encryption_algo = 14;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_encryption_algo();
    target = stream->WriteStringMaybeAliased(14, _s, target);
  }

  // optional bytes encryption_param = 15;
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_encryption_param();
    target = stream->WriteBytesMaybeAliased(15, _s, target);
  }

  // optional bytes schema_version = 16;
  if (cached_has_bits & 0x00000020u) {
    const std::string& _s = this->_internal_schema_version();
    target = stream->WriteBytesMaybeAliased(16, _s, target);
  }

  // optional bool partition_key_b64_encoded = 17 [default = false];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        17, this->_internal_partition_key_b64_encoded(), target);
  }

  // optional bytes ordering_key = 18;
  if (cached_has_bits & 0x00000040u) {
    const std::string& _s = this->_internal_ordering_key();
    target = stream->WriteBytesMaybeAliased(18, _s, target);
  }

  // optional int64 deliver_at_time = 19;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        19, this->_internal_deliver_at_time(), target);
  }

  // optional int32 marker_type = 20;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        20, this->_internal_marker_type(), target);
  }

  // optional uint64 txnid_least_bits = 22;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        22, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 23;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        23, this->_internal_txnid_most_bits(), target);
  }

  // optional uint64 highest_sequence_id = 24 [default = 0];
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        24, this->_internal_highest_sequence_id(), target);
  }

  // optional bool null_value = 25 [default = false];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        25, this->_internal_null_value(), target);
  }

  // optional string uuid = 26;
  if (cached_has_bits & 0x00000080u) {
    const std::string& _s = this->_internal_uuid();
    target = stream->WriteStringMaybeAliased(26, _s, target);
  }

  // optional int32 num_chunks_from_msg = 27;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        27, this->_internal_num_chunks_from_msg(), target);
  }

  // optional int32 total_chunk_msg_size = 28;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        28, this->_internal_total_chunk_msg_size(), target);
  }

  // optional int32 chunk_id = 29;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        29, this->_internal_chunk_id(), target);
  }

  // optional bool null_partition_key = 30 [default = false];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        30, this->_internal_null_partition_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.MessageMetadata)
  return target;
}

::size_t MessageMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.MessageMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.KeyValue properties = 4;
  total_size += 1UL * this->_internal_properties_size();
  for (const auto& msg : this->_internal_properties()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated string replicate_to = 7;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_replicate_to().size());
  for (int i = 0, n = _internal_replicate_to().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_replicate_to().Get(i));
  }
  // repeated .pulsar.proto.EncryptionKeys encryption_keys = 13;
  total_size += 1UL * this->_internal_encryption_keys_size();
  for (const auto& msg : this->_internal_encryption_keys()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // required string producer_name = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_producer_name());
  }

  if (cached_has_bits & 0x000000feu) {
    // optional string replicated_from = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_replicated_from());
    }

    // optional string partition_key = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_partition_key());
    }

    // optional string encryption_algo = 14;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_encryption_algo());
    }

    // optional bytes encryption_param = 15;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_encryption_param());
    }

    // optional bytes schema_version = 16;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_schema_version());
    }

    // optional bytes ordering_key = 18;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_ordering_key());
    }

    // optional string uuid = 26;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_uuid());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // required uint64 sequence_id = 2;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_sequence_id());
    }

    // required uint64 publish_time = 3;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_publish_time());
    }

  }
  if (cached_has_bits & 0x0000fc00u) {
    // optional .pulsar.proto.CompressionType compression = 8 [default = NONE];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_compression());
    }

    // optional uint32 uncompressed_size = 9 [default = 0];
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_uncompressed_size());
    }

    // optional uint64 event_time = 12 [default = 0];
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_event_time());
    }

    // optional int64 deliver_at_time = 19;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int64Size(
                                      this->_internal_deliver_at_time());
    }

    // optional uint64 txnid_least_bits = 22;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                      this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 23;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                      this->_internal_txnid_most_bits());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional int32 marker_type = 20;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_marker_type());
    }

    // optional bool partition_key_b64_encoded = 17 [default = false];
    if (cached_has_bits & 0x00020000u) {
      total_size += 3;
    }

    // optional bool null_value = 25 [default = false];
    if (cached_has_bits & 0x00040000u) {
      total_size += 3;
    }

    // optional bool null_partition_key = 30 [default = false];
    if (cached_has_bits & 0x00080000u) {
      total_size += 3;
    }

    // optional uint64 highest_sequence_id = 24 [default = 0];
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                      this->_internal_highest_sequence_id());
    }

    // optional int32 num_chunks_from_msg = 27;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_num_chunks_from_msg());
    }

    // optional int32 total_chunk_msg_size = 28;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_total_chunk_msg_size());
    }

    // optional int32 chunk_id = 29;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_chunk_id());
    }

  }
  // optional int32 num_messages_in_batch = 11 [default = 1];
  if (cached_has_bits & 0x01000000u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_num_messages_in_batch());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void MessageMetadata::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MessageMetadata*>(
      &from));
}

void MessageMetadata::MergeFrom(const MessageMetadata& from) {
  MessageMetadata* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.MessageMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_properties()->MergeFrom(
      from._internal_properties());
  _this->_internal_mutable_replicate_to()->MergeFrom(from._internal_replicate_to());
  _this->_internal_mutable_encryption_keys()->MergeFrom(
      from._internal_encryption_keys());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_producer_name(from._internal_producer_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_replicated_from(from._internal_replicated_from());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_partition_key(from._internal_partition_key());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_encryption_algo(from._internal_encryption_algo());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_encryption_param(from._internal_encryption_param());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_schema_version(from._internal_schema_version());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_ordering_key(from._internal_ordering_key());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_uuid(from._internal_uuid());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.sequence_id_ = from._impl_.sequence_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.publish_time_ = from._impl_.publish_time_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.compression_ = from._impl_.compression_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.uncompressed_size_ = from._impl_.uncompressed_size_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.event_time_ = from._impl_.event_time_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.deliver_at_time_ = from._impl_.deliver_at_time_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.txnid_least_bits_ = from._impl_.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.txnid_most_bits_ = from._impl_.txnid_most_bits_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.marker_type_ = from._impl_.marker_type_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.partition_key_b64_encoded_ = from._impl_.partition_key_b64_encoded_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.null_value_ = from._impl_.null_value_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.null_partition_key_ = from._impl_.null_partition_key_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.highest_sequence_id_ = from._impl_.highest_sequence_id_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.num_chunks_from_msg_ = from._impl_.num_chunks_from_msg_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.total_chunk_msg_size_ = from._impl_.total_chunk_msg_size_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.chunk_id_ = from._impl_.chunk_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x01000000u) {
    _this->_internal_set_num_messages_in_batch(from._internal_num_messages_in_batch());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MessageMetadata::CopyFrom(const MessageMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.MessageMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool MessageMetadata::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_properties()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_encryption_keys()))
    return false;
  return true;
}

::_pbi::CachedSize* MessageMetadata::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void MessageMetadata::InternalSwap(MessageMetadata* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.properties_.InternalSwap(&other->_impl_.properties_);
  _impl_.replicate_to_.InternalSwap(&other->_impl_.replicate_to_);
  _impl_.encryption_keys_.InternalSwap(&other->_impl_.encryption_keys_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.producer_name_, &other->_impl_.producer_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.replicated_from_, &other->_impl_.replicated_from_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.partition_key_, &other->_impl_.partition_key_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encryption_algo_, &other->_impl_.encryption_algo_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encryption_param_, &other->_impl_.encryption_param_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.schema_version_, &other->_impl_.schema_version_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ordering_key_, &other->_impl_.ordering_key_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.uuid_, &other->_impl_.uuid_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.num_messages_in_batch_)
      + sizeof(MessageMetadata::_impl_.num_messages_in_batch_)
      - PROTOBUF_FIELD_OFFSET(MessageMetadata, _impl_.sequence_id_)>(
          reinterpret_cast<char*>(&_impl_.sequence_id_),
          reinterpret_cast<char*>(&other->_impl_.sequence_id_));
}

std::string MessageMetadata::GetTypeName() const {
  return "pulsar.proto.MessageMetadata";
}

// ===================================================================

class SingleMessageMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<SingleMessageMetadata>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_._has_bits_);
  static void set_has_partition_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_payload_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_compacted_out(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_event_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_partition_key_b64_encoded(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ordering_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_null_value(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_null_partition_key(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

SingleMessageMetadata::SingleMessageMetadata(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.SingleMessageMetadata)
}
inline PROTOBUF_NDEBUG_INLINE SingleMessageMetadata::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        properties_{visibility, arena, from.properties_},
        partition_key_(arena, from.partition_key_),
        ordering_key_(arena, from.ordering_key_) {}

SingleMessageMetadata::SingleMessageMetadata(
    ::google::protobuf::Arena* arena,
    const SingleMessageMetadata& from)
    : ::google::protobuf::MessageLite(arena) {
  SingleMessageMetadata* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, event_time_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, event_time_),
           offsetof(Impl_, sequence_id_) -
               offsetof(Impl_, event_time_) +
               sizeof(Impl_::sequence_id_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.SingleMessageMetadata)
}
inline PROTOBUF_NDEBUG_INLINE SingleMessageMetadata::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        properties_{visibility, arena},
        partition_key_(arena),
        ordering_key_(arena) {}

inline void SingleMessageMetadata::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, event_time_),
           0,
           offsetof(Impl_, sequence_id_) -
               offsetof(Impl_, event_time_) +
               sizeof(Impl_::sequence_id_));
}
SingleMessageMetadata::~SingleMessageMetadata() {
  // @@protoc_insertion_point(destructor:pulsar.proto.SingleMessageMetadata)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void SingleMessageMetadata::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.partition_key_.Destroy();
  _impl_.ordering_key_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void SingleMessageMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.SingleMessageMetadata)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.properties_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.partition_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ordering_key_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.event_time_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.null_partition_key_) -
        reinterpret_cast<char*>(&_impl_.event_time_)) + sizeof(_impl_.null_partition_key_));
  }
  _impl_.sequence_id_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SingleMessageMetadata::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 10, 1, 0, 2> SingleMessageMetadata::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_._has_bits_),
    0, // no _extensions_
    10, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    10,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_SingleMessageMetadata_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .pulsar.proto.KeyValue properties = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.properties_)}},
    // optional string partition_key = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.partition_key_)}},
    // required int32 payload_size = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.payload_size_)}},
    // optional bool compacted_out = 4 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {32, 4, 0, PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.compacted_out_)}},
    // optional uint64 event_time = 5 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {40, 2, 0, PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.event_time_)}},
    // optional bool partition_key_b64_encoded = 6 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {48, 5, 0, PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.partition_key_b64_encoded_)}},
    // optional bytes ordering_key = 7;
    {::_pbi::TcParser::FastBS1,
     {58, 1, 0, PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.ordering_key_)}},
    // optional uint64 sequence_id = 8;
    {::_pbi::TcParser::FastV64S1,
     {64, 8, 0, PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.sequence_id_)}},
    // optional bool null_value = 9 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {72, 6, 0, PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.null_value_)}},
    // optional bool null_partition_key = 10 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {80, 7, 0, PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.null_partition_key_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .pulsar.proto.KeyValue properties = 1;
    {PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.properties_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional string partition_key = 2;
    {PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.partition_key_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // required int32 payload_size = 3;
    {PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.payload_size_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional bool compacted_out = 4 [default = false];
    {PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.compacted_out_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional uint64 event_time = 5 [default = 0];
    {PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.event_time_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional bool partition_key_b64_encoded = 6 [default = false];
    {PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.partition_key_b64_encoded_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bytes ordering_key = 7;
    {PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.ordering_key_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint64 sequence_id = 8;
    {PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.sequence_id_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional bool null_value = 9 [default = false];
    {PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.null_value_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool null_partition_key = 10 [default = false];
    {PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.null_partition_key_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::KeyValue>()},
  }}, {{
  }},
};

::uint8_t* SingleMessageMetadata::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.SingleMessageMetadata)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .pulsar.proto.KeyValue properties = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_properties().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string partition_key = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_partition_key();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // required int32 payload_size = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_payload_size(), target);
  }

  // optional bool compacted_out = 4 [default = false];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_compacted_out(), target);
  }

  // optional uint64 event_time = 5 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_event_time(), target);
  }

  // optional bool partition_key_b64_encoded = 6 [default = false];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_partition_key_b64_encoded(), target);
  }

  // optional bytes ordering_key = 7;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_ordering_key();
    target = stream->WriteBytesMaybeAliased(7, _s, target);
  }

  // optional uint64 sequence_id = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        8, this->_internal_sequence_id(), target);
  }

  // optional bool null_value = 9 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this->_internal_null_value(), target);
  }

  // optional bool null_partition_key = 10 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        10, this->_internal_null_partition_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.SingleMessageMetadata)
  return target;
}

::size_t SingleMessageMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.SingleMessageMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.KeyValue properties = 1;
  total_size += 1UL * this->_internal_properties_size();
  for (const auto& msg : this->_internal_properties()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string partition_key = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_partition_key());
    }

    // optional bytes ordering_key = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_ordering_key());
    }

    // optional uint64 event_time = 5 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_event_time());
    }

  }
  // required int32 payload_size = 3;
  if (cached_has_bits & 0x00000008u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_payload_size());
  }

  if (cached_has_bits & 0x000000f0u) {
    // optional bool compacted_out = 4 [default = false];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2;
    }

    // optional bool partition_key_b64_encoded = 6 [default = false];
    if (cached_has_bits & 0x00000020u) {
      total_size += 2;
    }

    // optional bool null_value = 9 [default = false];
    if (cached_has_bits & 0x00000040u) {
      total_size += 2;
    }

    // optional bool null_partition_key = 10 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 2;
    }

  }
  // optional uint64 sequence_id = 8;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_sequence_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void SingleMessageMetadata::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SingleMessageMetadata*>(
      &from));
}

void SingleMessageMetadata::MergeFrom(const SingleMessageMetadata& from) {
  SingleMessageMetadata* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.SingleMessageMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_properties()->MergeFrom(
      from._internal_properties());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_partition_key(from._internal_partition_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_ordering_key(from._internal_ordering_key());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.event_time_ = from._impl_.event_time_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.payload_size_ = from._impl_.payload_size_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.compacted_out_ = from._impl_.compacted_out_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.partition_key_b64_encoded_ = from._impl_.partition_key_b64_encoded_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.null_value_ = from._impl_.null_value_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.null_partition_key_ = from._impl_.null_partition_key_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_sequence_id(from._internal_sequence_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SingleMessageMetadata::CopyFrom(const SingleMessageMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.SingleMessageMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SingleMessageMetadata::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_properties()))
    return false;
  return true;
}

::_pbi::CachedSize* SingleMessageMetadata::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void SingleMessageMetadata::InternalSwap(SingleMessageMetadata* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.properties_.InternalSwap(&other->_impl_.properties_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.partition_key_, &other->_impl_.partition_key_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ordering_key_, &other->_impl_.ordering_key_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.sequence_id_)
      + sizeof(SingleMessageMetadata::_impl_.sequence_id_)
      - PROTOBUF_FIELD_OFFSET(SingleMessageMetadata, _impl_.event_time_)>(
          reinterpret_cast<char*>(&_impl_.event_time_),
          reinterpret_cast<char*>(&other->_impl_.event_time_));
}

std::string SingleMessageMetadata::GetTypeName() const {
  return "pulsar.proto.SingleMessageMetadata";
}

// ===================================================================

class BrokerEntryMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<BrokerEntryMetadata>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BrokerEntryMetadata, _impl_._has_bits_);
  static void set_has_broker_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BrokerEntryMetadata::BrokerEntryMetadata(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.BrokerEntryMetadata)
}
BrokerEntryMetadata::BrokerEntryMetadata(
    ::google::protobuf::Arena* arena, const BrokerEntryMetadata& from)
    : BrokerEntryMetadata(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE BrokerEntryMetadata::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void BrokerEntryMetadata::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, broker_timestamp_),
           0,
           offsetof(Impl_, index_) -
               offsetof(Impl_, broker_timestamp_) +
               sizeof(Impl_::index_));
}
BrokerEntryMetadata::~BrokerEntryMetadata() {
  // @@protoc_insertion_point(destructor:pulsar.proto.BrokerEntryMetadata)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void BrokerEntryMetadata::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void BrokerEntryMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.BrokerEntryMetadata)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.broker_timestamp_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.index_) -
        reinterpret_cast<char*>(&_impl_.broker_timestamp_)) + sizeof(_impl_.index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BrokerEntryMetadata::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> BrokerEntryMetadata::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BrokerEntryMetadata, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_BrokerEntryMetadata_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional uint64 index = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(BrokerEntryMetadata, _impl_.index_)}},
    // optional uint64 broker_timestamp = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(BrokerEntryMetadata, _impl_.broker_timestamp_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint64 broker_timestamp = 1;
    {PROTOBUF_FIELD_OFFSET(BrokerEntryMetadata, _impl_.broker_timestamp_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 index = 2;
    {PROTOBUF_FIELD_OFFSET(BrokerEntryMetadata, _impl_.index_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* BrokerEntryMetadata::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.BrokerEntryMetadata)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 broker_timestamp = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_broker_timestamp(), target);
  }

  // optional uint64 index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.BrokerEntryMetadata)
  return target;
}

::size_t BrokerEntryMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.BrokerEntryMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 broker_timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_broker_timestamp());
    }

    // optional uint64 index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_index());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BrokerEntryMetadata::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BrokerEntryMetadata*>(
      &from));
}

void BrokerEntryMetadata::MergeFrom(const BrokerEntryMetadata& from) {
  BrokerEntryMetadata* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.BrokerEntryMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.broker_timestamp_ = from._impl_.broker_timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BrokerEntryMetadata::CopyFrom(const BrokerEntryMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.BrokerEntryMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool BrokerEntryMetadata::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* BrokerEntryMetadata::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void BrokerEntryMetadata::InternalSwap(BrokerEntryMetadata* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BrokerEntryMetadata, _impl_.index_)
      + sizeof(BrokerEntryMetadata::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(BrokerEntryMetadata, _impl_.broker_timestamp_)>(
          reinterpret_cast<char*>(&_impl_.broker_timestamp_),
          reinterpret_cast<char*>(&other->_impl_.broker_timestamp_));
}

std::string BrokerEntryMetadata::GetTypeName() const {
  return "pulsar.proto.BrokerEntryMetadata";
}

// ===================================================================

class CommandConnect::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandConnect>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_._has_bits_);
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_method(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_auth_method_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_auth_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_protocol_version(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_proxy_to_broker_url(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_original_principal(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_original_auth_data(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_original_auth_method(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::pulsar::proto::FeatureFlags& feature_flags(const CommandConnect* msg);
  static void set_has_feature_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::pulsar::proto::FeatureFlags& CommandConnect::_Internal::feature_flags(const CommandConnect* msg) {
  return *msg->_impl_.feature_flags_;
}
CommandConnect::CommandConnect(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandConnect)
}
inline PROTOBUF_NDEBUG_INLINE CommandConnect::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        client_version_(arena, from.client_version_),
        auth_data_(arena, from.auth_data_),
        auth_method_name_(arena, from.auth_method_name_),
        proxy_to_broker_url_(arena, from.proxy_to_broker_url_),
        original_principal_(arena, from.original_principal_),
        original_auth_data_(arena, from.original_auth_data_),
        original_auth_method_(arena, from.original_auth_method_) {}

CommandConnect::CommandConnect(
    ::google::protobuf::Arena* arena,
    const CommandConnect& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandConnect* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.feature_flags_ = (cached_has_bits & 0x00000080u)
                ? CreateMaybeMessage<::pulsar::proto::FeatureFlags>(arena, *from._impl_.feature_flags_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, auth_method_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, auth_method_),
           offsetof(Impl_, protocol_version_) -
               offsetof(Impl_, auth_method_) +
               sizeof(Impl_::protocol_version_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandConnect)
}
inline PROTOBUF_NDEBUG_INLINE CommandConnect::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        client_version_(arena),
        auth_data_(arena),
        auth_method_name_(arena),
        proxy_to_broker_url_(arena),
        original_principal_(arena),
        original_auth_data_(arena),
        original_auth_method_(arena) {}

inline void CommandConnect::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, feature_flags_),
           0,
           offsetof(Impl_, protocol_version_) -
               offsetof(Impl_, feature_flags_) +
               sizeof(Impl_::protocol_version_));
}
CommandConnect::~CommandConnect() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandConnect)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandConnect::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.client_version_.Destroy();
  _impl_.auth_data_.Destroy();
  _impl_.auth_method_name_.Destroy();
  _impl_.proxy_to_broker_url_.Destroy();
  _impl_.original_principal_.Destroy();
  _impl_.original_auth_data_.Destroy();
  _impl_.original_auth_method_.Destroy();
  delete _impl_.feature_flags_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandConnect::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandConnect)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.client_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.auth_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.auth_method_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.proxy_to_broker_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.original_principal_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.original_auth_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.original_auth_method_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      ABSL_DCHECK(_impl_.feature_flags_ != nullptr);
      _impl_.feature_flags_->Clear();
    }
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.auth_method_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.protocol_version_) -
        reinterpret_cast<char*>(&_impl_.auth_method_)) + sizeof(_impl_.protocol_version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandConnect::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 10, 2, 0, 2> CommandConnect::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_._has_bits_),
    0, // no _extensions_
    10, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    10,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandConnect_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string client_version = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.client_version_)}},
    // optional .pulsar.proto.AuthMethod auth_method = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 8, 2, PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.auth_method_)}},
    // optional bytes auth_data = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 1, 0, PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.auth_data_)}},
    // optional int32 protocol_version = 4 [default = 0];
    {::_pbi::TcParser::FastV32S1,
     {32, 9, 0, PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.protocol_version_)}},
    // optional string auth_method_name = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 2, 0, PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.auth_method_name_)}},
    // optional string proxy_to_broker_url = 6;
    {::_pbi::TcParser::FastBS1,
     {50, 3, 0, PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.proxy_to_broker_url_)}},
    // optional string original_principal = 7;
    {::_pbi::TcParser::FastBS1,
     {58, 4, 0, PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.original_principal_)}},
    // optional string original_auth_data = 8;
    {::_pbi::TcParser::FastBS1,
     {66, 5, 0, PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.original_auth_data_)}},
    // optional string original_auth_method = 9;
    {::_pbi::TcParser::FastBS1,
     {74, 6, 0, PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.original_auth_method_)}},
    // optional .pulsar.proto.FeatureFlags feature_flags = 10;
    {::_pbi::TcParser::FastMtS1,
     {82, 7, 1, PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.feature_flags_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required string client_version = 1;
    {PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.client_version_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .pulsar.proto.AuthMethod auth_method = 2;
    {PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.auth_method_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional bytes auth_data = 3;
    {PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.auth_data_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int32 protocol_version = 4 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.protocol_version_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional string auth_method_name = 5;
    {PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.auth_method_name_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string proxy_to_broker_url = 6;
    {PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.proxy_to_broker_url_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string original_principal = 7;
    {PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.original_principal_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string original_auth_data = 8;
    {PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.original_auth_data_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string original_auth_method = 9;
    {PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.original_auth_method_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .pulsar.proto.FeatureFlags feature_flags = 10;
    {PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.feature_flags_), _Internal::kHasBitsOffset + 7, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {0, 3},
    {::_pbi::TcParser::GetTable<::pulsar::proto::FeatureFlags>()},
  }}, {{
  }},
};

::uint8_t* CommandConnect::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandConnect)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string client_version = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_client_version();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional .pulsar.proto.AuthMethod auth_method = 2;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_auth_method(), target);
  }

  // optional bytes auth_data = 3;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_auth_data();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  // optional int32 protocol_version = 4 [default = 0];
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<4>(
            stream, this->_internal_protocol_version(), target);
  }

  // optional string auth_method_name = 5;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_auth_method_name();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional string proxy_to_broker_url = 6;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_proxy_to_broker_url();
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // optional string original_principal = 7;
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_original_principal();
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // optional string original_auth_data = 8;
  if (cached_has_bits & 0x00000020u) {
    const std::string& _s = this->_internal_original_auth_data();
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  // optional string original_auth_method = 9;
  if (cached_has_bits & 0x00000040u) {
    const std::string& _s = this->_internal_original_auth_method();
    target = stream->WriteStringMaybeAliased(9, _s, target);
  }

  // optional .pulsar.proto.FeatureFlags feature_flags = 10;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        10, _Internal::feature_flags(this),
        _Internal::feature_flags(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandConnect)
  return target;
}

::size_t CommandConnect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandConnect)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // required string client_version = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_client_version());
  }

  if (cached_has_bits & 0x000000feu) {
    // optional bytes auth_data = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_auth_data());
    }

    // optional string auth_method_name = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_auth_method_name());
    }

    // optional string proxy_to_broker_url = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_proxy_to_broker_url());
    }

    // optional string original_principal = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_original_principal());
    }

    // optional string original_auth_data = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_original_auth_data());
    }

    // optional string original_auth_method = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_original_auth_method());
    }

    // optional .pulsar.proto.FeatureFlags feature_flags = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.feature_flags_);
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional .pulsar.proto.AuthMethod auth_method = 2;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_auth_method());
    }

    // optional int32 protocol_version = 4 [default = 0];
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_protocol_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandConnect::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandConnect*>(
      &from));
}

void CommandConnect::MergeFrom(const CommandConnect& from) {
  CommandConnect* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandConnect)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_client_version(from._internal_client_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_auth_data(from._internal_auth_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_auth_method_name(from._internal_auth_method_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_proxy_to_broker_url(from._internal_proxy_to_broker_url());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_original_principal(from._internal_original_principal());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_original_auth_data(from._internal_original_auth_data());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_original_auth_method(from._internal_original_auth_method());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_feature_flags()->::pulsar::proto::FeatureFlags::MergeFrom(
          from._internal_feature_flags());
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.auth_method_ = from._impl_.auth_method_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.protocol_version_ = from._impl_.protocol_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandConnect::CopyFrom(const CommandConnect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandConnect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandConnect::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandConnect::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandConnect::InternalSwap(CommandConnect* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.client_version_, &other->_impl_.client_version_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.auth_data_, &other->_impl_.auth_data_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.auth_method_name_, &other->_impl_.auth_method_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.proxy_to_broker_url_, &other->_impl_.proxy_to_broker_url_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.original_principal_, &other->_impl_.original_principal_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.original_auth_data_, &other->_impl_.original_auth_data_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.original_auth_method_, &other->_impl_.original_auth_method_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.protocol_version_)
      + sizeof(CommandConnect::_impl_.protocol_version_)
      - PROTOBUF_FIELD_OFFSET(CommandConnect, _impl_.feature_flags_)>(
          reinterpret_cast<char*>(&_impl_.feature_flags_),
          reinterpret_cast<char*>(&other->_impl_.feature_flags_));
}

std::string CommandConnect::GetTypeName() const {
  return "pulsar.proto.CommandConnect";
}

// ===================================================================

class FeatureFlags::_Internal {
 public:
  using HasBits = decltype(std::declval<FeatureFlags>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(FeatureFlags, _impl_._has_bits_);
  static void set_has_supports_auth_refresh(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_supports_broker_entry_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_supports_partial_producer(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_supports_topic_watchers(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

FeatureFlags::FeatureFlags(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.FeatureFlags)
}
FeatureFlags::FeatureFlags(
    ::google::protobuf::Arena* arena, const FeatureFlags& from)
    : FeatureFlags(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE FeatureFlags::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void FeatureFlags::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, supports_auth_refresh_),
           0,
           offsetof(Impl_, supports_topic_watchers_) -
               offsetof(Impl_, supports_auth_refresh_) +
               sizeof(Impl_::supports_topic_watchers_));
}
FeatureFlags::~FeatureFlags() {
  // @@protoc_insertion_point(destructor:pulsar.proto.FeatureFlags)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void FeatureFlags::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void FeatureFlags::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.FeatureFlags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.supports_auth_refresh_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.supports_topic_watchers_) -
      reinterpret_cast<char*>(&_impl_.supports_auth_refresh_)) + sizeof(_impl_.supports_topic_watchers_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FeatureFlags::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> FeatureFlags::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(FeatureFlags, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_FeatureFlags_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional bool supports_topic_watchers = 4 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(FeatureFlags, _impl_.supports_topic_watchers_)}},
    // optional bool supports_auth_refresh = 1 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(FeatureFlags, _impl_.supports_auth_refresh_)}},
    // optional bool supports_broker_entry_metadata = 2 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(FeatureFlags, _impl_.supports_broker_entry_metadata_)}},
    // optional bool supports_partial_producer = 3 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(FeatureFlags, _impl_.supports_partial_producer_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool supports_auth_refresh = 1 [default = false];
    {PROTOBUF_FIELD_OFFSET(FeatureFlags, _impl_.supports_auth_refresh_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool supports_broker_entry_metadata = 2 [default = false];
    {PROTOBUF_FIELD_OFFSET(FeatureFlags, _impl_.supports_broker_entry_metadata_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool supports_partial_producer = 3 [default = false];
    {PROTOBUF_FIELD_OFFSET(FeatureFlags, _impl_.supports_partial_producer_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool supports_topic_watchers = 4 [default = false];
    {PROTOBUF_FIELD_OFFSET(FeatureFlags, _impl_.supports_topic_watchers_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* FeatureFlags::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.FeatureFlags)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool supports_auth_refresh = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_supports_auth_refresh(), target);
  }

  // optional bool supports_broker_entry_metadata = 2 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_supports_broker_entry_metadata(), target);
  }

  // optional bool supports_partial_producer = 3 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_supports_partial_producer(), target);
  }

  // optional bool supports_topic_watchers = 4 [default = false];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_supports_topic_watchers(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.FeatureFlags)
  return target;
}

::size_t FeatureFlags::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.FeatureFlags)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bool supports_auth_refresh = 1 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 2;
    }

    // optional bool supports_broker_entry_metadata = 2 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }

    // optional bool supports_partial_producer = 3 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2;
    }

    // optional bool supports_topic_watchers = 4 [default = false];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void FeatureFlags::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FeatureFlags*>(
      &from));
}

void FeatureFlags::MergeFrom(const FeatureFlags& from) {
  FeatureFlags* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.FeatureFlags)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.supports_auth_refresh_ = from._impl_.supports_auth_refresh_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.supports_broker_entry_metadata_ = from._impl_.supports_broker_entry_metadata_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.supports_partial_producer_ = from._impl_.supports_partial_producer_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.supports_topic_watchers_ = from._impl_.supports_topic_watchers_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FeatureFlags::CopyFrom(const FeatureFlags& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.FeatureFlags)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool FeatureFlags::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* FeatureFlags::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void FeatureFlags::InternalSwap(FeatureFlags* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FeatureFlags, _impl_.supports_topic_watchers_)
      + sizeof(FeatureFlags::_impl_.supports_topic_watchers_)
      - PROTOBUF_FIELD_OFFSET(FeatureFlags, _impl_.supports_auth_refresh_)>(
          reinterpret_cast<char*>(&_impl_.supports_auth_refresh_),
          reinterpret_cast<char*>(&other->_impl_.supports_auth_refresh_));
}

std::string FeatureFlags::GetTypeName() const {
  return "pulsar.proto.FeatureFlags";
}

// ===================================================================

class CommandConnected::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandConnected>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandConnected, _impl_._has_bits_);
  static void set_has_server_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_protocol_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_message_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::pulsar::proto::FeatureFlags& feature_flags(const CommandConnected* msg);
  static void set_has_feature_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::pulsar::proto::FeatureFlags& CommandConnected::_Internal::feature_flags(const CommandConnected* msg) {
  return *msg->_impl_.feature_flags_;
}
CommandConnected::CommandConnected(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandConnected)
}
inline PROTOBUF_NDEBUG_INLINE CommandConnected::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        server_version_(arena, from.server_version_) {}

CommandConnected::CommandConnected(
    ::google::protobuf::Arena* arena,
    const CommandConnected& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandConnected* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.feature_flags_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::pulsar::proto::FeatureFlags>(arena, *from._impl_.feature_flags_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, protocol_version_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, protocol_version_),
           offsetof(Impl_, max_message_size_) -
               offsetof(Impl_, protocol_version_) +
               sizeof(Impl_::max_message_size_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandConnected)
}
inline PROTOBUF_NDEBUG_INLINE CommandConnected::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        server_version_(arena) {}

inline void CommandConnected::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, feature_flags_),
           0,
           offsetof(Impl_, max_message_size_) -
               offsetof(Impl_, feature_flags_) +
               sizeof(Impl_::max_message_size_));
}
CommandConnected::~CommandConnected() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandConnected)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandConnected::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.server_version_.Destroy();
  delete _impl_.feature_flags_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandConnected::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandConnected)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.server_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.feature_flags_ != nullptr);
      _impl_.feature_flags_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.protocol_version_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.max_message_size_) -
        reinterpret_cast<char*>(&_impl_.protocol_version_)) + sizeof(_impl_.max_message_size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandConnected::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2> CommandConnected::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandConnected, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandConnected_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional .pulsar.proto.FeatureFlags feature_flags = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(CommandConnected, _impl_.feature_flags_)}},
    // required string server_version = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CommandConnected, _impl_.server_version_)}},
    // optional int32 protocol_version = 2 [default = 0];
    {::_pbi::TcParser::FastV32S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(CommandConnected, _impl_.protocol_version_)}},
    // optional int32 max_message_size = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(CommandConnected, _impl_.max_message_size_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string server_version = 1;
    {PROTOBUF_FIELD_OFFSET(CommandConnected, _impl_.server_version_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int32 protocol_version = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandConnected, _impl_.protocol_version_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 max_message_size = 3;
    {PROTOBUF_FIELD_OFFSET(CommandConnected, _impl_.max_message_size_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional .pulsar.proto.FeatureFlags feature_flags = 4;
    {PROTOBUF_FIELD_OFFSET(CommandConnected, _impl_.feature_flags_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::FeatureFlags>()},
  }}, {{
  }},
};

::uint8_t* CommandConnected::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandConnected)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string server_version = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_server_version();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional int32 protocol_version = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<2>(
            stream, this->_internal_protocol_version(), target);
  }

  // optional int32 max_message_size = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_max_message_size(), target);
  }

  // optional .pulsar.proto.FeatureFlags feature_flags = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, _Internal::feature_flags(this),
        _Internal::feature_flags(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandConnected)
  return target;
}

::size_t CommandConnected::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandConnected)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // required string server_version = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_server_version());
  }

  if (cached_has_bits & 0x0000000eu) {
    // optional .pulsar.proto.FeatureFlags feature_flags = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.feature_flags_);
    }

    // optional int32 protocol_version = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_protocol_version());
    }

    // optional int32 max_message_size = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_max_message_size());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandConnected::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandConnected*>(
      &from));
}

void CommandConnected::MergeFrom(const CommandConnected& from) {
  CommandConnected* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandConnected)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_server_version(from._internal_server_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_feature_flags()->::pulsar::proto::FeatureFlags::MergeFrom(
          from._internal_feature_flags());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.protocol_version_ = from._impl_.protocol_version_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.max_message_size_ = from._impl_.max_message_size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandConnected::CopyFrom(const CommandConnected& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandConnected)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandConnected::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandConnected::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandConnected::InternalSwap(CommandConnected* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.server_version_, &other->_impl_.server_version_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandConnected, _impl_.max_message_size_)
      + sizeof(CommandConnected::_impl_.max_message_size_)
      - PROTOBUF_FIELD_OFFSET(CommandConnected, _impl_.feature_flags_)>(
          reinterpret_cast<char*>(&_impl_.feature_flags_),
          reinterpret_cast<char*>(&other->_impl_.feature_flags_));
}

std::string CommandConnected::GetTypeName() const {
  return "pulsar.proto.CommandConnected";
}

// ===================================================================

class CommandAuthResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandAuthResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandAuthResponse, _impl_._has_bits_);
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pulsar::proto::AuthData& response(const CommandAuthResponse* msg);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_protocol_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::pulsar::proto::AuthData& CommandAuthResponse::_Internal::response(const CommandAuthResponse* msg) {
  return *msg->_impl_.response_;
}
CommandAuthResponse::CommandAuthResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandAuthResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandAuthResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        client_version_(arena, from.client_version_) {}

CommandAuthResponse::CommandAuthResponse(
    ::google::protobuf::Arena* arena,
    const CommandAuthResponse& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandAuthResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.response_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::pulsar::proto::AuthData>(arena, *from._impl_.response_)
                : nullptr;
  _impl_.protocol_version_ = from._impl_.protocol_version_;

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandAuthResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandAuthResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        client_version_(arena) {}

inline void CommandAuthResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, response_),
           0,
           offsetof(Impl_, protocol_version_) -
               offsetof(Impl_, response_) +
               sizeof(Impl_::protocol_version_));
}
CommandAuthResponse::~CommandAuthResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandAuthResponse)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandAuthResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.client_version_.Destroy();
  delete _impl_.response_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandAuthResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandAuthResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.client_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.response_ != nullptr);
      _impl_.response_->Clear();
    }
  }
  _impl_.protocol_version_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandAuthResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> CommandAuthResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandAuthResponse, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandAuthResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional string client_version = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CommandAuthResponse, _impl_.client_version_)}},
    // optional .pulsar.proto.AuthData response = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(CommandAuthResponse, _impl_.response_)}},
    // optional int32 protocol_version = 3 [default = 0];
    {::_pbi::TcParser::FastV32S1,
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(CommandAuthResponse, _impl_.protocol_version_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string client_version = 1;
    {PROTOBUF_FIELD_OFFSET(CommandAuthResponse, _impl_.client_version_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .pulsar.proto.AuthData response = 2;
    {PROTOBUF_FIELD_OFFSET(CommandAuthResponse, _impl_.response_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional int32 protocol_version = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandAuthResponse, _impl_.protocol_version_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::AuthData>()},
  }}, {{
  }},
};

::uint8_t* CommandAuthResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandAuthResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string client_version = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_client_version();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional .pulsar.proto.AuthData response = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::response(this),
        _Internal::response(this).GetCachedSize(), target, stream);
  }

  // optional int32 protocol_version = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_protocol_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandAuthResponse)
  return target;
}

::size_t CommandAuthResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandAuthResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string client_version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_client_version());
    }

    // optional .pulsar.proto.AuthData response = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.response_);
    }

    // optional int32 protocol_version = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_protocol_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandAuthResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandAuthResponse*>(
      &from));
}

void CommandAuthResponse::MergeFrom(const CommandAuthResponse& from) {
  CommandAuthResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandAuthResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_client_version(from._internal_client_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_response()->::pulsar::proto::AuthData::MergeFrom(
          from._internal_response());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.protocol_version_ = from._impl_.protocol_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandAuthResponse::CopyFrom(const CommandAuthResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandAuthResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandAuthResponse::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* CommandAuthResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandAuthResponse::InternalSwap(CommandAuthResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.client_version_, &other->_impl_.client_version_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandAuthResponse, _impl_.protocol_version_)
      + sizeof(CommandAuthResponse::_impl_.protocol_version_)
      - PROTOBUF_FIELD_OFFSET(CommandAuthResponse, _impl_.response_)>(
          reinterpret_cast<char*>(&_impl_.response_),
          reinterpret_cast<char*>(&other->_impl_.response_));
}

std::string CommandAuthResponse::GetTypeName() const {
  return "pulsar.proto.CommandAuthResponse";
}

// ===================================================================

class CommandAuthChallenge::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandAuthChallenge>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandAuthChallenge, _impl_._has_bits_);
  static void set_has_server_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pulsar::proto::AuthData& challenge(const CommandAuthChallenge* msg);
  static void set_has_challenge(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_protocol_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::pulsar::proto::AuthData& CommandAuthChallenge::_Internal::challenge(const CommandAuthChallenge* msg) {
  return *msg->_impl_.challenge_;
}
CommandAuthChallenge::CommandAuthChallenge(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandAuthChallenge)
}
inline PROTOBUF_NDEBUG_INLINE CommandAuthChallenge::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        server_version_(arena, from.server_version_) {}

CommandAuthChallenge::CommandAuthChallenge(
    ::google::protobuf::Arena* arena,
    const CommandAuthChallenge& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandAuthChallenge* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.challenge_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::pulsar::proto::AuthData>(arena, *from._impl_.challenge_)
                : nullptr;
  _impl_.protocol_version_ = from._impl_.protocol_version_;

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandAuthChallenge)
}
inline PROTOBUF_NDEBUG_INLINE CommandAuthChallenge::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        server_version_(arena) {}

inline void CommandAuthChallenge::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, challenge_),
           0,
           offsetof(Impl_, protocol_version_) -
               offsetof(Impl_, challenge_) +
               sizeof(Impl_::protocol_version_));
}
CommandAuthChallenge::~CommandAuthChallenge() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandAuthChallenge)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandAuthChallenge::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.server_version_.Destroy();
  delete _impl_.challenge_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandAuthChallenge::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandAuthChallenge)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.server_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.challenge_ != nullptr);
      _impl_.challenge_->Clear();
    }
  }
  _impl_.protocol_version_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandAuthChallenge::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> CommandAuthChallenge::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandAuthChallenge, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandAuthChallenge_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional string server_version = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CommandAuthChallenge, _impl_.server_version_)}},
    // optional .pulsar.proto.AuthData challenge = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(CommandAuthChallenge, _impl_.challenge_)}},
    // optional int32 protocol_version = 3 [default = 0];
    {::_pbi::TcParser::FastV32S1,
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(CommandAuthChallenge, _impl_.protocol_version_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string server_version = 1;
    {PROTOBUF_FIELD_OFFSET(CommandAuthChallenge, _impl_.server_version_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .pulsar.proto.AuthData challenge = 2;
    {PROTOBUF_FIELD_OFFSET(CommandAuthChallenge, _impl_.challenge_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional int32 protocol_version = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandAuthChallenge, _impl_.protocol_version_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::AuthData>()},
  }}, {{
  }},
};

::uint8_t* CommandAuthChallenge::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandAuthChallenge)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string server_version = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_server_version();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional .pulsar.proto.AuthData challenge = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::challenge(this),
        _Internal::challenge(this).GetCachedSize(), target, stream);
  }

  // optional int32 protocol_version = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_protocol_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandAuthChallenge)
  return target;
}

::size_t CommandAuthChallenge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandAuthChallenge)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string server_version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_server_version());
    }

    // optional .pulsar.proto.AuthData challenge = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.challenge_);
    }

    // optional int32 protocol_version = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_protocol_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandAuthChallenge::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandAuthChallenge*>(
      &from));
}

void CommandAuthChallenge::MergeFrom(const CommandAuthChallenge& from) {
  CommandAuthChallenge* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandAuthChallenge)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_server_version(from._internal_server_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_challenge()->::pulsar::proto::AuthData::MergeFrom(
          from._internal_challenge());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.protocol_version_ = from._impl_.protocol_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandAuthChallenge::CopyFrom(const CommandAuthChallenge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandAuthChallenge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandAuthChallenge::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* CommandAuthChallenge::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandAuthChallenge::InternalSwap(CommandAuthChallenge* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.server_version_, &other->_impl_.server_version_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandAuthChallenge, _impl_.protocol_version_)
      + sizeof(CommandAuthChallenge::_impl_.protocol_version_)
      - PROTOBUF_FIELD_OFFSET(CommandAuthChallenge, _impl_.challenge_)>(
          reinterpret_cast<char*>(&_impl_.challenge_),
          reinterpret_cast<char*>(&other->_impl_.challenge_));
}

std::string CommandAuthChallenge::GetTypeName() const {
  return "pulsar.proto.CommandAuthChallenge";
}

// ===================================================================

class AuthData::_Internal {
 public:
  using HasBits = decltype(std::declval<AuthData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AuthData, _impl_._has_bits_);
  static void set_has_auth_method_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AuthData::AuthData(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.AuthData)
}
inline PROTOBUF_NDEBUG_INLINE AuthData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        auth_method_name_(arena, from.auth_method_name_),
        auth_data_(arena, from.auth_data_) {}

AuthData::AuthData(
    ::google::protobuf::Arena* arena,
    const AuthData& from)
    : ::google::protobuf::MessageLite(arena) {
  AuthData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.AuthData)
}
inline PROTOBUF_NDEBUG_INLINE AuthData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        auth_method_name_(arena),
        auth_data_(arena) {}

inline void AuthData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
AuthData::~AuthData() {
  // @@protoc_insertion_point(destructor:pulsar.proto.AuthData)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void AuthData::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.auth_method_name_.Destroy();
  _impl_.auth_data_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void AuthData::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.AuthData)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.auth_method_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.auth_data_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AuthData::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> AuthData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AuthData, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_AuthData_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional bytes auth_data = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(AuthData, _impl_.auth_data_)}},
    // optional string auth_method_name = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(AuthData, _impl_.auth_method_name_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string auth_method_name = 1;
    {PROTOBUF_FIELD_OFFSET(AuthData, _impl_.auth_method_name_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes auth_data = 2;
    {PROTOBUF_FIELD_OFFSET(AuthData, _impl_.auth_data_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* AuthData::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.AuthData)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string auth_method_name = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_auth_method_name();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional bytes auth_data = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_auth_data();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.AuthData)
  return target;
}

::size_t AuthData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.AuthData)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string auth_method_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_auth_method_name());
    }

    // optional bytes auth_data = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_auth_data());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void AuthData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AuthData*>(
      &from));
}

void AuthData::MergeFrom(const AuthData& from) {
  AuthData* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.AuthData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_auth_method_name(from._internal_auth_method_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_auth_data(from._internal_auth_data());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AuthData::CopyFrom(const AuthData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.AuthData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AuthData::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* AuthData::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void AuthData::InternalSwap(AuthData* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.auth_method_name_, &other->_impl_.auth_method_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.auth_data_, &other->_impl_.auth_data_, arena);
}

std::string AuthData::GetTypeName() const {
  return "pulsar.proto.AuthData";
}

// ===================================================================

class KeySharedMeta::_Internal {
 public:
  using HasBits = decltype(std::declval<KeySharedMeta>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(KeySharedMeta, _impl_._has_bits_);
  static void set_has_keysharedmode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_allowoutoforderdelivery(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

KeySharedMeta::KeySharedMeta(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.KeySharedMeta)
}
inline PROTOBUF_NDEBUG_INLINE KeySharedMeta::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        hashranges_{visibility, arena, from.hashranges_} {}

KeySharedMeta::KeySharedMeta(
    ::google::protobuf::Arena* arena,
    const KeySharedMeta& from)
    : ::google::protobuf::MessageLite(arena) {
  KeySharedMeta* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, keysharedmode_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, keysharedmode_),
           offsetof(Impl_, allowoutoforderdelivery_) -
               offsetof(Impl_, keysharedmode_) +
               sizeof(Impl_::allowoutoforderdelivery_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.KeySharedMeta)
}
inline PROTOBUF_NDEBUG_INLINE KeySharedMeta::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        hashranges_{visibility, arena} {}

inline void KeySharedMeta::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, keysharedmode_),
           0,
           offsetof(Impl_, allowoutoforderdelivery_) -
               offsetof(Impl_, keysharedmode_) +
               sizeof(Impl_::allowoutoforderdelivery_));
}
KeySharedMeta::~KeySharedMeta() {
  // @@protoc_insertion_point(destructor:pulsar.proto.KeySharedMeta)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void KeySharedMeta::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void KeySharedMeta::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.KeySharedMeta)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hashranges_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.keysharedmode_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.allowoutoforderdelivery_) -
        reinterpret_cast<char*>(&_impl_.keysharedmode_)) + sizeof(_impl_.allowoutoforderdelivery_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KeySharedMeta::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 2, 0, 2> KeySharedMeta::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(KeySharedMeta, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967282,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_KeySharedMeta_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional bool allowOutOfOrderDelivery = 4 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {32, 1, 0, PROTOBUF_FIELD_OFFSET(KeySharedMeta, _impl_.allowoutoforderdelivery_)}},
    // required .pulsar.proto.KeySharedMode keySharedMode = 1;
    {::_pbi::TcParser::FastEr0S1,
     {8, 0, 1, PROTOBUF_FIELD_OFFSET(KeySharedMeta, _impl_.keysharedmode_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .pulsar.proto.IntRange hashRanges = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 1, PROTOBUF_FIELD_OFFSET(KeySharedMeta, _impl_.hashranges_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required .pulsar.proto.KeySharedMode keySharedMode = 1;
    {PROTOBUF_FIELD_OFFSET(KeySharedMeta, _impl_.keysharedmode_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // repeated .pulsar.proto.IntRange hashRanges = 3;
    {PROTOBUF_FIELD_OFFSET(KeySharedMeta, _impl_.hashranges_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bool allowOutOfOrderDelivery = 4 [default = false];
    {PROTOBUF_FIELD_OFFSET(KeySharedMeta, _impl_.allowoutoforderdelivery_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }}, {{
    {0, 2},
    {::_pbi::TcParser::GetTable<::pulsar::proto::IntRange>()},
  }}, {{
  }},
};

::uint8_t* KeySharedMeta::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.KeySharedMeta)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .pulsar.proto.KeySharedMode keySharedMode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_keysharedmode(), target);
  }

  // repeated .pulsar.proto.IntRange hashRanges = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hashranges_size()); i < n; i++) {
    const auto& repfield = this->_internal_hashranges().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool allowOutOfOrderDelivery = 4 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_allowoutoforderdelivery(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.KeySharedMeta)
  return target;
}

::size_t KeySharedMeta::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.KeySharedMeta)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.IntRange hashRanges = 3;
  total_size += 1UL * this->_internal_hashranges_size();
  for (const auto& msg : this->_internal_hashranges()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // required .pulsar.proto.KeySharedMode keySharedMode = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_keysharedmode());
  }

  // optional bool allowOutOfOrderDelivery = 4 [default = false];
  if (cached_has_bits & 0x00000002u) {
    total_size += 2;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void KeySharedMeta::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KeySharedMeta*>(
      &from));
}

void KeySharedMeta::MergeFrom(const KeySharedMeta& from) {
  KeySharedMeta* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.KeySharedMeta)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_hashranges()->MergeFrom(
      from._internal_hashranges());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.keysharedmode_ = from._impl_.keysharedmode_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.allowoutoforderdelivery_ = from._impl_.allowoutoforderdelivery_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KeySharedMeta::CopyFrom(const KeySharedMeta& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.KeySharedMeta)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool KeySharedMeta::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_hashranges()))
    return false;
  return true;
}

::_pbi::CachedSize* KeySharedMeta::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void KeySharedMeta::InternalSwap(KeySharedMeta* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.hashranges_.InternalSwap(&other->_impl_.hashranges_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeySharedMeta, _impl_.allowoutoforderdelivery_)
      + sizeof(KeySharedMeta::_impl_.allowoutoforderdelivery_)
      - PROTOBUF_FIELD_OFFSET(KeySharedMeta, _impl_.keysharedmode_)>(
          reinterpret_cast<char*>(&_impl_.keysharedmode_),
          reinterpret_cast<char*>(&other->_impl_.keysharedmode_));
}

std::string KeySharedMeta::GetTypeName() const {
  return "pulsar.proto.KeySharedMeta";
}

// ===================================================================

class CommandSubscribe::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSubscribe>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_._has_bits_);
  static void set_has_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_subscription(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_subtype(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_consumer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_priority_level(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_durable(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::pulsar::proto::MessageIdData& start_message_id(const CommandSubscribe* msg);
  static void set_has_start_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_read_compacted(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::pulsar::proto::Schema& schema(const CommandSubscribe* msg);
  static void set_has_schema(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_initialposition(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_replicate_subscription_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_force_topic_creation(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_start_message_rollback_duration_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::pulsar::proto::KeySharedMeta& keysharedmeta(const CommandSubscribe* msg);
  static void set_has_keysharedmeta(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_consumer_epoch(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000001c3) ^ 0x000001c3) != 0;
  }
};

const ::pulsar::proto::MessageIdData& CommandSubscribe::_Internal::start_message_id(const CommandSubscribe* msg) {
  return *msg->_impl_.start_message_id_;
}
const ::pulsar::proto::Schema& CommandSubscribe::_Internal::schema(const CommandSubscribe* msg) {
  return *msg->_impl_.schema_;
}
const ::pulsar::proto::KeySharedMeta& CommandSubscribe::_Internal::keysharedmeta(const CommandSubscribe* msg) {
  return *msg->_impl_.keysharedmeta_;
}
CommandSubscribe::CommandSubscribe(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandSubscribe)
}
inline PROTOBUF_NDEBUG_INLINE CommandSubscribe::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        metadata_{visibility, arena, from.metadata_},
        subscription_properties_{visibility, arena, from.subscription_properties_},
        topic_(arena, from.topic_),
        subscription_(arena, from.subscription_),
        consumer_name_(arena, from.consumer_name_) {}

CommandSubscribe::CommandSubscribe(
    ::google::protobuf::Arena* arena,
    const CommandSubscribe& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandSubscribe* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.start_message_id_ = (cached_has_bits & 0x00000008u)
                ? CreateMaybeMessage<::pulsar::proto::MessageIdData>(arena, *from._impl_.start_message_id_)
                : nullptr;
  _impl_.schema_ = (cached_has_bits & 0x00000010u)
                ? CreateMaybeMessage<::pulsar::proto::Schema>(arena, *from._impl_.schema_)
                : nullptr;
  _impl_.keysharedmeta_ = (cached_has_bits & 0x00000020u)
                ? CreateMaybeMessage<::pulsar::proto::KeySharedMeta>(arena, *from._impl_.keysharedmeta_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, consumer_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, consumer_id_),
           offsetof(Impl_, force_topic_creation_) -
               offsetof(Impl_, consumer_id_) +
               sizeof(Impl_::force_topic_creation_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandSubscribe)
}
inline PROTOBUF_NDEBUG_INLINE CommandSubscribe::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        metadata_{visibility, arena},
        subscription_properties_{visibility, arena},
        topic_(arena),
        subscription_(arena),
        consumer_name_(arena),
        durable_{true},
        force_topic_creation_{true} {}

inline void CommandSubscribe::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, start_message_id_),
           0,
           offsetof(Impl_, consumer_epoch_) -
               offsetof(Impl_, start_message_id_) +
               sizeof(Impl_::consumer_epoch_));
}
CommandSubscribe::~CommandSubscribe() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandSubscribe)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandSubscribe::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.topic_.Destroy();
  _impl_.subscription_.Destroy();
  _impl_.consumer_name_.Destroy();
  delete _impl_.start_message_id_;
  delete _impl_.schema_;
  delete _impl_.keysharedmeta_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandSubscribe::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandSubscribe)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metadata_.Clear();
  _impl_.subscription_properties_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.subscription_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.consumer_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.start_message_id_ != nullptr);
      _impl_.start_message_id_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.schema_ != nullptr);
      _impl_.schema_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.keysharedmeta_ != nullptr);
      _impl_.keysharedmeta_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.consumer_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.request_id_) -
        reinterpret_cast<char*>(&_impl_.consumer_id_)) + sizeof(_impl_.request_id_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.subtype_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.consumer_epoch_) -
        reinterpret_cast<char*>(&_impl_.subtype_)) + sizeof(_impl_.consumer_epoch_));
    _impl_.durable_ = true;
  }
  _impl_.force_topic_creation_ = true;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandSubscribe::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 19, 7, 0, 2> CommandSubscribe::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_._has_bits_),
    0, // no _extensions_
    19, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294443008,  // skipmap
    offsetof(decltype(_table_), field_entries),
    19,  // num_field_entries
    7,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandSubscribe_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string topic = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.topic_)}},
    // required string subscription = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.subscription_)}},
    // required .pulsar.proto.CommandSubscribe.SubType subType = 3;
    {::_pbi::TcParser::FastEr0S1,
     {24, 8, 3, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.subtype_)}},
    // required uint64 consumer_id = 4;
    {::_pbi::TcParser::FastV64S1,
     {32, 6, 0, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.consumer_id_)}},
    // required uint64 request_id = 5;
    {::_pbi::TcParser::FastV64S1,
     {40, 7, 0, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.request_id_)}},
    // optional string consumer_name = 6;
    {::_pbi::TcParser::FastBS1,
     {50, 2, 0, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.consumer_name_)}},
    // optional int32 priority_level = 7;
    {::_pbi::TcParser::FastV32S1,
     {56, 9, 0, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.priority_level_)}},
    // optional bool durable = 8 [default = true];
    {::_pbi::TcParser::FastV8S1,
     {64, 15, 0, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.durable_)}},
    // optional .pulsar.proto.MessageIdData start_message_id = 9;
    {::_pbi::TcParser::FastMtS1,
     {74, 3, 1, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.start_message_id_)}},
    // repeated .pulsar.proto.KeyValue metadata = 10;
    {::_pbi::TcParser::FastMtR1,
     {82, 63, 2, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.metadata_)}},
    // optional bool read_compacted = 11;
    {::_pbi::TcParser::FastV8S1,
     {88, 10, 0, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.read_compacted_)}},
    // optional .pulsar.proto.Schema schema = 12;
    {::_pbi::TcParser::FastMtS1,
     {98, 4, 3, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.schema_)}},
    // optional .pulsar.proto.CommandSubscribe.InitialPosition initialPosition = 13 [default = Latest];
    {::_pbi::TcParser::FastEr0S1,
     {104, 12, 1, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.initialposition_)}},
    // optional bool replicate_subscription_state = 14;
    {::_pbi::TcParser::FastV8S1,
     {112, 11, 0, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.replicate_subscription_state_)}},
    // optional bool force_topic_creation = 15 [default = true];
    {::_pbi::TcParser::FastV8S1,
     {120, 16, 0, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.force_topic_creation_)}},
    // optional uint64 start_message_rollback_duration_sec = 16 [default = 0];
    {::_pbi::TcParser::FastV64S2,
     {384, 13, 0, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.start_message_rollback_duration_sec_)}},
    // optional .pulsar.proto.KeySharedMeta keySharedMeta = 17;
    {::_pbi::TcParser::FastMtS2,
     {394, 5, 5, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.keysharedmeta_)}},
    // repeated .pulsar.proto.KeyValue subscription_properties = 18;
    {::_pbi::TcParser::FastMtR2,
     {402, 63, 6, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.subscription_properties_)}},
    // optional uint64 consumer_epoch = 19;
    {::_pbi::TcParser::FastV64S2,
     {408, 14, 0, PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.consumer_epoch_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required string topic = 1;
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.topic_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // required string subscription = 2;
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.subscription_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // required .pulsar.proto.CommandSubscribe.SubType subType = 3;
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.subtype_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // required uint64 consumer_id = 4;
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.consumer_id_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint64 request_id = 5;
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.request_id_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional string consumer_name = 6;
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.consumer_name_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int32 priority_level = 7;
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.priority_level_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional bool durable = 8 [default = true];
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.durable_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .pulsar.proto.MessageIdData start_message_id = 9;
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.start_message_id_), _Internal::kHasBitsOffset + 3, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .pulsar.proto.KeyValue metadata = 10;
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.metadata_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bool read_compacted = 11;
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.read_compacted_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .pulsar.proto.Schema schema = 12;
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.schema_), _Internal::kHasBitsOffset + 4, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandSubscribe.InitialPosition initialPosition = 13 [default = Latest];
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.initialposition_), _Internal::kHasBitsOffset + 12, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional bool replicate_subscription_state = 14;
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.replicate_subscription_state_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool force_topic_creation = 15 [default = true];
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.force_topic_creation_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional uint64 start_message_rollback_duration_sec = 16 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.start_message_rollback_duration_sec_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.KeySharedMeta keySharedMeta = 17;
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.keysharedmeta_), _Internal::kHasBitsOffset + 5, 5,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .pulsar.proto.KeyValue subscription_properties = 18;
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.subscription_properties_), -1, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint64 consumer_epoch = 19;
    {PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.consumer_epoch_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }}, {{
    {0, 4},
    {::_pbi::TcParser::GetTable<::pulsar::proto::MessageIdData>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::KeyValue>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::Schema>()},
    {0, 2},
    {::_pbi::TcParser::GetTable<::pulsar::proto::KeySharedMeta>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::KeyValue>()},
  }}, {{
  }},
};

::uint8_t* CommandSubscribe::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandSubscribe)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string topic = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_topic();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required string subscription = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_subscription();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // required .pulsar.proto.CommandSubscribe.SubType subType = 3;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_subtype(), target);
  }

  // required uint64 consumer_id = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_consumer_id(), target);
  }

  // required uint64 request_id = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_request_id(), target);
  }

  // optional string consumer_name = 6;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_consumer_name();
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // optional int32 priority_level = 7;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<7>(
            stream, this->_internal_priority_level(), target);
  }

  // optional bool durable = 8 [default = true];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_durable(), target);
  }

  // optional .pulsar.proto.MessageIdData start_message_id = 9;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        9, _Internal::start_message_id(this),
        _Internal::start_message_id(this).GetCachedSize(), target, stream);
  }

  // repeated .pulsar.proto.KeyValue metadata = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_metadata_size()); i < n; i++) {
    const auto& repfield = this->_internal_metadata().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool read_compacted = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        11, this->_internal_read_compacted(), target);
  }

  // optional .pulsar.proto.Schema schema = 12;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        12, _Internal::schema(this),
        _Internal::schema(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandSubscribe.InitialPosition initialPosition = 13 [default = Latest];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        13, this->_internal_initialposition(), target);
  }

  // optional bool replicate_subscription_state = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        14, this->_internal_replicate_subscription_state(), target);
  }

  // optional bool force_topic_creation = 15 [default = true];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        15, this->_internal_force_topic_creation(), target);
  }

  // optional uint64 start_message_rollback_duration_sec = 16 [default = 0];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        16, this->_internal_start_message_rollback_duration_sec(), target);
  }

  // optional .pulsar.proto.KeySharedMeta keySharedMeta = 17;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        17, _Internal::keysharedmeta(this),
        _Internal::keysharedmeta(this).GetCachedSize(), target, stream);
  }

  // repeated .pulsar.proto.KeyValue subscription_properties = 18;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_subscription_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_subscription_properties().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(18, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 consumer_epoch = 19;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        19, this->_internal_consumer_epoch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandSubscribe)
  return target;
}

::size_t CommandSubscribe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandSubscribe)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.KeyValue metadata = 10;
  total_size += 1UL * this->_internal_metadata_size();
  for (const auto& msg : this->_internal_metadata()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .pulsar.proto.KeyValue subscription_properties = 18;
  total_size += 2UL * this->_internal_subscription_properties_size();
  for (const auto& msg : this->_internal_subscription_properties()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required string topic = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_topic());
    }

    // required string subscription = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_subscription());
    }

  }
  if (cached_has_bits & 0x0000003cu) {
    // optional string consumer_name = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_consumer_name());
    }

    // optional .pulsar.proto.MessageIdData start_message_id = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.start_message_id_);
    }

    // optional .pulsar.proto.Schema schema = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.schema_);
    }

    // optional .pulsar.proto.KeySharedMeta keySharedMeta = 17;
    if (cached_has_bits & 0x00000020u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.keysharedmeta_);
    }

  }
  if (cached_has_bits & 0x000000c0u) {
    // required uint64 consumer_id = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_consumer_id());
    }

    // required uint64 request_id = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_request_id());
    }

  }
  // required .pulsar.proto.CommandSubscribe.SubType subType = 3;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_subtype());
  }

  if (cached_has_bits & 0x0000fe00u) {
    // optional int32 priority_level = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_priority_level());
    }

    // optional bool read_compacted = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2;
    }

    // optional bool replicate_subscription_state = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2;
    }

    // optional .pulsar.proto.CommandSubscribe.InitialPosition initialPosition = 13 [default = Latest];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_initialposition());
    }

    // optional uint64 start_message_rollback_duration_sec = 16 [default = 0];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                      this->_internal_start_message_rollback_duration_sec());
    }

    // optional uint64 consumer_epoch = 19;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                      this->_internal_consumer_epoch());
    }

    // optional bool durable = 8 [default = true];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2;
    }

  }
  // optional bool force_topic_creation = 15 [default = true];
  if (cached_has_bits & 0x00010000u) {
    total_size += 2;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandSubscribe::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandSubscribe*>(
      &from));
}

void CommandSubscribe::MergeFrom(const CommandSubscribe& from) {
  CommandSubscribe* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandSubscribe)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_metadata()->MergeFrom(
      from._internal_metadata());
  _this->_internal_mutable_subscription_properties()->MergeFrom(
      from._internal_subscription_properties());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_topic(from._internal_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_subscription(from._internal_subscription());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_consumer_name(from._internal_consumer_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_start_message_id()->::pulsar::proto::MessageIdData::MergeFrom(
          from._internal_start_message_id());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_schema()->::pulsar::proto::Schema::MergeFrom(
          from._internal_schema());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_keysharedmeta()->::pulsar::proto::KeySharedMeta::MergeFrom(
          from._internal_keysharedmeta());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.consumer_id_ = from._impl_.consumer_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.subtype_ = from._impl_.subtype_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.priority_level_ = from._impl_.priority_level_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.read_compacted_ = from._impl_.read_compacted_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.replicate_subscription_state_ = from._impl_.replicate_subscription_state_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.initialposition_ = from._impl_.initialposition_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.start_message_rollback_duration_sec_ = from._impl_.start_message_rollback_duration_sec_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.consumer_epoch_ = from._impl_.consumer_epoch_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.durable_ = from._impl_.durable_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    _this->_internal_set_force_topic_creation(from._internal_force_topic_creation());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandSubscribe::CopyFrom(const CommandSubscribe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandSubscribe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandSubscribe::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_metadata()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_subscription_properties()))
    return false;
  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (!_impl_.start_message_id_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000010u) != 0) {
    if (!_impl_.schema_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000020u) != 0) {
    if (!_impl_.keysharedmeta_->IsInitialized()) return false;
  }
  return true;
}

::_pbi::CachedSize* CommandSubscribe::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandSubscribe::InternalSwap(CommandSubscribe* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  _impl_.subscription_properties_.InternalSwap(&other->_impl_.subscription_properties_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.topic_, &other->_impl_.topic_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subscription_, &other->_impl_.subscription_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.consumer_name_, &other->_impl_.consumer_name_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.force_topic_creation_)
      + sizeof(CommandSubscribe::_impl_.force_topic_creation_)
      - PROTOBUF_FIELD_OFFSET(CommandSubscribe, _impl_.start_message_id_)>(
          reinterpret_cast<char*>(&_impl_.start_message_id_),
          reinterpret_cast<char*>(&other->_impl_.start_message_id_));
}

std::string CommandSubscribe::GetTypeName() const {
  return "pulsar.proto.CommandSubscribe";
}

// ===================================================================

class CommandPartitionedTopicMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandPartitionedTopicMetadata>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadata, _impl_._has_bits_);
  static void set_has_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_original_principal(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_original_auth_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_original_auth_method(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000011) ^ 0x00000011) != 0;
  }
};

CommandPartitionedTopicMetadata::CommandPartitionedTopicMetadata(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandPartitionedTopicMetadata)
}
inline PROTOBUF_NDEBUG_INLINE CommandPartitionedTopicMetadata::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        topic_(arena, from.topic_),
        original_principal_(arena, from.original_principal_),
        original_auth_data_(arena, from.original_auth_data_),
        original_auth_method_(arena, from.original_auth_method_) {}

CommandPartitionedTopicMetadata::CommandPartitionedTopicMetadata(
    ::google::protobuf::Arena* arena,
    const CommandPartitionedTopicMetadata& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandPartitionedTopicMetadata* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  _impl_.request_id_ = from._impl_.request_id_;

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandPartitionedTopicMetadata)
}
inline PROTOBUF_NDEBUG_INLINE CommandPartitionedTopicMetadata::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        topic_(arena),
        original_principal_(arena),
        original_auth_data_(arena),
        original_auth_method_(arena) {}

inline void CommandPartitionedTopicMetadata::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.request_id_ = {};
}
CommandPartitionedTopicMetadata::~CommandPartitionedTopicMetadata() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandPartitionedTopicMetadata)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandPartitionedTopicMetadata::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.topic_.Destroy();
  _impl_.original_principal_.Destroy();
  _impl_.original_auth_data_.Destroy();
  _impl_.original_auth_method_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandPartitionedTopicMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandPartitionedTopicMetadata)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.original_principal_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.original_auth_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.original_auth_method_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandPartitionedTopicMetadata::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2> CommandPartitionedTopicMetadata::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadata, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandPartitionedTopicMetadata_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string topic = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadata, _impl_.topic_)}},
    // required uint64 request_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 4, 0, PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadata, _impl_.request_id_)}},
    // optional string original_principal = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 1, 0, PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadata, _impl_.original_principal_)}},
    // optional string original_auth_data = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 2, 0, PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadata, _impl_.original_auth_data_)}},
    // optional string original_auth_method = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 3, 0, PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadata, _impl_.original_auth_method_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required string topic = 1;
    {PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadata, _impl_.topic_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // required uint64 request_id = 2;
    {PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadata, _impl_.request_id_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional string original_principal = 3;
    {PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadata, _impl_.original_principal_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string original_auth_data = 4;
    {PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadata, _impl_.original_auth_data_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string original_auth_method = 5;
    {PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadata, _impl_.original_auth_method_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandPartitionedTopicMetadata::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandPartitionedTopicMetadata)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string topic = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_topic();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_request_id(), target);
  }

  // optional string original_principal = 3;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_original_principal();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional string original_auth_data = 4;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_original_auth_data();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional string original_auth_method = 5;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_original_auth_method();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandPartitionedTopicMetadata)
  return target;
}

::size_t CommandPartitionedTopicMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandPartitionedTopicMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // required string topic = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_topic());
  }

  if (cached_has_bits & 0x0000000eu) {
    // optional string original_principal = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_original_principal());
    }

    // optional string original_auth_data = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_original_auth_data());
    }

    // optional string original_auth_method = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_original_auth_method());
    }

  }
  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000010u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandPartitionedTopicMetadata::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandPartitionedTopicMetadata*>(
      &from));
}

void CommandPartitionedTopicMetadata::MergeFrom(const CommandPartitionedTopicMetadata& from) {
  CommandPartitionedTopicMetadata* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandPartitionedTopicMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_topic(from._internal_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_original_principal(from._internal_original_principal());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_original_auth_data(from._internal_original_auth_data());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_original_auth_method(from._internal_original_auth_method());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandPartitionedTopicMetadata::CopyFrom(const CommandPartitionedTopicMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandPartitionedTopicMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandPartitionedTopicMetadata::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandPartitionedTopicMetadata::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandPartitionedTopicMetadata::InternalSwap(CommandPartitionedTopicMetadata* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.topic_, &other->_impl_.topic_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.original_principal_, &other->_impl_.original_principal_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.original_auth_data_, &other->_impl_.original_auth_data_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.original_auth_method_, &other->_impl_.original_auth_method_, arena);
        swap(_impl_.request_id_, other->_impl_.request_id_);
}

std::string CommandPartitionedTopicMetadata::GetTypeName() const {
  return "pulsar.proto.CommandPartitionedTopicMetadata";
}

// ===================================================================

class CommandPartitionedTopicMetadataResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandPartitionedTopicMetadataResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadataResponse, _impl_._has_bits_);
  static void set_has_partitions(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandPartitionedTopicMetadataResponse::CommandPartitionedTopicMetadataResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandPartitionedTopicMetadataResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandPartitionedTopicMetadataResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_(arena, from.message_) {}

CommandPartitionedTopicMetadataResponse::CommandPartitionedTopicMetadataResponse(
    ::google::protobuf::Arena* arena,
    const CommandPartitionedTopicMetadataResponse& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandPartitionedTopicMetadataResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandPartitionedTopicMetadataResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandPartitionedTopicMetadataResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        message_(arena) {}

inline void CommandPartitionedTopicMetadataResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));
}
CommandPartitionedTopicMetadataResponse::~CommandPartitionedTopicMetadataResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandPartitionedTopicMetadataResponse)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandPartitionedTopicMetadataResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.message_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandPartitionedTopicMetadataResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandPartitionedTopicMetadataResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.error_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.error_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandPartitionedTopicMetadataResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 2, 0, 2> CommandPartitionedTopicMetadataResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadataResponse, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandPartitionedTopicMetadataResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 partitions = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadataResponse, _impl_.partitions_)}},
    // required uint64 request_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadataResponse, _impl_.request_id_)}},
    // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse.LookupType response = 3;
    {::_pbi::TcParser::FastEr0S1,
     {24, 3, 1, PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadataResponse, _impl_.response_)}},
    // optional .pulsar.proto.ServerError error = 4;
    {::_pbi::TcParser::FastEr0S1,
     {32, 4, 25, PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadataResponse, _impl_.error_)}},
    // optional string message = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 0, 0, PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadataResponse, _impl_.message_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 partitions = 1;
    {PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadataResponse, _impl_.partitions_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // required uint64 request_id = 2;
    {PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadataResponse, _impl_.request_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse.LookupType response = 3;
    {PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadataResponse, _impl_.response_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .pulsar.proto.ServerError error = 4;
    {PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadataResponse, _impl_.error_), _Internal::kHasBitsOffset + 4, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string message = 5;
    {PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadataResponse, _impl_.message_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {0, 2},
    {0, 26},
  }}, {{
  }},
};

::uint8_t* CommandPartitionedTopicMetadataResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandPartitionedTopicMetadataResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 partitions = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_partitions(), target);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_request_id(), target);
  }

  // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse.LookupType response = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_response(), target);
  }

  // optional .pulsar.proto.ServerError error = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_error(), target);
  }

  // optional string message = 5;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_message();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandPartitionedTopicMetadataResponse)
  return target;
}

::size_t CommandPartitionedTopicMetadataResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandPartitionedTopicMetadataResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional uint32 partitions = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_partitions());
    }

    // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse.LookupType response = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_response());
    }

    // optional .pulsar.proto.ServerError error = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandPartitionedTopicMetadataResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandPartitionedTopicMetadataResponse*>(
      &from));
}

void CommandPartitionedTopicMetadataResponse::MergeFrom(const CommandPartitionedTopicMetadataResponse& from) {
  CommandPartitionedTopicMetadataResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandPartitionedTopicMetadataResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.partitions_ = from._impl_.partitions_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.response_ = from._impl_.response_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandPartitionedTopicMetadataResponse::CopyFrom(const CommandPartitionedTopicMetadataResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandPartitionedTopicMetadataResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandPartitionedTopicMetadataResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandPartitionedTopicMetadataResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandPartitionedTopicMetadataResponse::InternalSwap(CommandPartitionedTopicMetadataResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadataResponse, _impl_.error_)
      + sizeof(CommandPartitionedTopicMetadataResponse::_impl_.error_)
      - PROTOBUF_FIELD_OFFSET(CommandPartitionedTopicMetadataResponse, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandPartitionedTopicMetadataResponse::GetTypeName() const {
  return "pulsar.proto.CommandPartitionedTopicMetadataResponse";
}

// ===================================================================

class CommandLookupTopic::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandLookupTopic>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_._has_bits_);
  static void set_has_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_authoritative(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_original_principal(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_original_auth_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_original_auth_method(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_advertised_listener_name(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000021) ^ 0x00000021) != 0;
  }
};

CommandLookupTopic::CommandLookupTopic(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandLookupTopic)
}
inline PROTOBUF_NDEBUG_INLINE CommandLookupTopic::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        topic_(arena, from.topic_),
        original_principal_(arena, from.original_principal_),
        original_auth_data_(arena, from.original_auth_data_),
        original_auth_method_(arena, from.original_auth_method_),
        advertised_listener_name_(arena, from.advertised_listener_name_) {}

CommandLookupTopic::CommandLookupTopic(
    ::google::protobuf::Arena* arena,
    const CommandLookupTopic& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandLookupTopic* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, authoritative_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::authoritative_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandLookupTopic)
}
inline PROTOBUF_NDEBUG_INLINE CommandLookupTopic::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        topic_(arena),
        original_principal_(arena),
        original_auth_data_(arena),
        original_auth_method_(arena),
        advertised_listener_name_(arena) {}

inline void CommandLookupTopic::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, authoritative_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::authoritative_));
}
CommandLookupTopic::~CommandLookupTopic() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandLookupTopic)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandLookupTopic::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.topic_.Destroy();
  _impl_.original_principal_.Destroy();
  _impl_.original_auth_data_.Destroy();
  _impl_.original_auth_method_.Destroy();
  _impl_.advertised_listener_name_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandLookupTopic::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandLookupTopic)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.original_principal_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.original_auth_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.original_auth_method_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.advertised_listener_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.authoritative_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.authoritative_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandLookupTopic::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 0, 0, 2> CommandLookupTopic::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandLookupTopic_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string topic = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_.topic_)}},
    // required uint64 request_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 5, 0, PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_.request_id_)}},
    // optional bool authoritative = 3 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {24, 6, 0, PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_.authoritative_)}},
    // optional string original_principal = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_.original_principal_)}},
    // optional string original_auth_data = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 2, 0, PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_.original_auth_data_)}},
    // optional string original_auth_method = 6;
    {::_pbi::TcParser::FastBS1,
     {50, 3, 0, PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_.original_auth_method_)}},
    // optional string advertised_listener_name = 7;
    {::_pbi::TcParser::FastBS1,
     {58, 4, 0, PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_.advertised_listener_name_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string topic = 1;
    {PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_.topic_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // required uint64 request_id = 2;
    {PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_.request_id_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional bool authoritative = 3 [default = false];
    {PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_.authoritative_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional string original_principal = 4;
    {PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_.original_principal_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string original_auth_data = 5;
    {PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_.original_auth_data_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string original_auth_method = 6;
    {PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_.original_auth_method_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string advertised_listener_name = 7;
    {PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_.advertised_listener_name_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandLookupTopic::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandLookupTopic)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string topic = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_topic();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_request_id(), target);
  }

  // optional bool authoritative = 3 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_authoritative(), target);
  }

  // optional string original_principal = 4;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_original_principal();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional string original_auth_data = 5;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_original_auth_data();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional string original_auth_method = 6;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_original_auth_method();
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // optional string advertised_listener_name = 7;
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_advertised_listener_name();
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandLookupTopic)
  return target;
}

::size_t CommandLookupTopic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandLookupTopic)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // required string topic = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_topic());
  }

  if (cached_has_bits & 0x0000001eu) {
    // optional string original_principal = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_original_principal());
    }

    // optional string original_auth_data = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_original_auth_data());
    }

    // optional string original_auth_method = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_original_auth_method());
    }

    // optional string advertised_listener_name = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_advertised_listener_name());
    }

  }
  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000020u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  // optional bool authoritative = 3 [default = false];
  if (cached_has_bits & 0x00000040u) {
    total_size += 2;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandLookupTopic::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandLookupTopic*>(
      &from));
}

void CommandLookupTopic::MergeFrom(const CommandLookupTopic& from) {
  CommandLookupTopic* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandLookupTopic)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_topic(from._internal_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_original_principal(from._internal_original_principal());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_original_auth_data(from._internal_original_auth_data());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_original_auth_method(from._internal_original_auth_method());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_advertised_listener_name(from._internal_advertised_listener_name());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.authoritative_ = from._impl_.authoritative_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandLookupTopic::CopyFrom(const CommandLookupTopic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandLookupTopic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandLookupTopic::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandLookupTopic::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandLookupTopic::InternalSwap(CommandLookupTopic* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.topic_, &other->_impl_.topic_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.original_principal_, &other->_impl_.original_principal_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.original_auth_data_, &other->_impl_.original_auth_data_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.original_auth_method_, &other->_impl_.original_auth_method_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.advertised_listener_name_, &other->_impl_.advertised_listener_name_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_.authoritative_)
      + sizeof(CommandLookupTopic::_impl_.authoritative_)
      - PROTOBUF_FIELD_OFFSET(CommandLookupTopic, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandLookupTopic::GetTypeName() const {
  return "pulsar.proto.CommandLookupTopic";
}

// ===================================================================

class CommandLookupTopicResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandLookupTopicResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_._has_bits_);
  static void set_has_brokerserviceurl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_brokerserviceurltls(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_authoritative(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_proxy_through_service_url(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

CommandLookupTopicResponse::CommandLookupTopicResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandLookupTopicResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandLookupTopicResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        brokerserviceurl_(arena, from.brokerserviceurl_),
        brokerserviceurltls_(arena, from.brokerserviceurltls_),
        message_(arena, from.message_) {}

CommandLookupTopicResponse::CommandLookupTopicResponse(
    ::google::protobuf::Arena* arena,
    const CommandLookupTopicResponse& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandLookupTopicResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, proxy_through_service_url_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::proxy_through_service_url_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandLookupTopicResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandLookupTopicResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        brokerserviceurl_(arena),
        brokerserviceurltls_(arena),
        message_(arena) {}

inline void CommandLookupTopicResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, proxy_through_service_url_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::proxy_through_service_url_));
}
CommandLookupTopicResponse::~CommandLookupTopicResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandLookupTopicResponse)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandLookupTopicResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.brokerserviceurl_.Destroy();
  _impl_.brokerserviceurltls_.Destroy();
  _impl_.message_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandLookupTopicResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandLookupTopicResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.brokerserviceurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.brokerserviceurltls_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.proxy_through_service_url_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.proxy_through_service_url_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandLookupTopicResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 2, 0, 2> CommandLookupTopicResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandLookupTopicResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional bool proxy_through_service_url = 8 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {64, 7, 0, PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.proxy_through_service_url_)}},
    // optional string brokerServiceUrl = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.brokerserviceurl_)}},
    // optional string brokerServiceUrlTls = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.brokerserviceurltls_)}},
    // optional .pulsar.proto.CommandLookupTopicResponse.LookupType response = 3;
    {::_pbi::TcParser::FastEr0S1,
     {24, 4, 2, PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.response_)}},
    // required uint64 request_id = 4;
    {::_pbi::TcParser::FastV64S1,
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.request_id_)}},
    // optional bool authoritative = 5 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {40, 6, 0, PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.authoritative_)}},
    // optional .pulsar.proto.ServerError error = 6;
    {::_pbi::TcParser::FastEr0S1,
     {48, 5, 25, PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.error_)}},
    // optional string message = 7;
    {::_pbi::TcParser::FastBS1,
     {58, 2, 0, PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.message_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string brokerServiceUrl = 1;
    {PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.brokerserviceurl_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string brokerServiceUrlTls = 2;
    {PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.brokerserviceurltls_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .pulsar.proto.CommandLookupTopicResponse.LookupType response = 3;
    {PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.response_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // required uint64 request_id = 4;
    {PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.request_id_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional bool authoritative = 5 [default = false];
    {PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.authoritative_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .pulsar.proto.ServerError error = 6;
    {PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.error_), _Internal::kHasBitsOffset + 5, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string message = 7;
    {PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.message_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bool proxy_through_service_url = 8 [default = false];
    {PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.proxy_through_service_url_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }}, {{
    {0, 3},
    {0, 26},
  }}, {{
  }},
};

::uint8_t* CommandLookupTopicResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandLookupTopicResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string brokerServiceUrl = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_brokerserviceurl();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string brokerServiceUrlTls = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_brokerserviceurltls();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional .pulsar.proto.CommandLookupTopicResponse.LookupType response = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_response(), target);
  }

  // required uint64 request_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_request_id(), target);
  }

  // optional bool authoritative = 5 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_authoritative(), target);
  }

  // optional .pulsar.proto.ServerError error = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        6, this->_internal_error(), target);
  }

  // optional string message = 7;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_message();
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // optional bool proxy_through_service_url = 8 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_proxy_through_service_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandLookupTopicResponse)
  return target;
}

::size_t CommandLookupTopicResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandLookupTopicResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string brokerServiceUrl = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_brokerserviceurl());
    }

    // optional string brokerServiceUrlTls = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_brokerserviceurltls());
    }

    // optional string message = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_message());
    }

  }
  // required uint64 request_id = 4;
  if (cached_has_bits & 0x00000008u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (cached_has_bits & 0x000000f0u) {
    // optional .pulsar.proto.CommandLookupTopicResponse.LookupType response = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_response());
    }

    // optional .pulsar.proto.ServerError error = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
    }

    // optional bool authoritative = 5 [default = false];
    if (cached_has_bits & 0x00000040u) {
      total_size += 2;
    }

    // optional bool proxy_through_service_url = 8 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 2;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandLookupTopicResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandLookupTopicResponse*>(
      &from));
}

void CommandLookupTopicResponse::MergeFrom(const CommandLookupTopicResponse& from) {
  CommandLookupTopicResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandLookupTopicResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_brokerserviceurl(from._internal_brokerserviceurl());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_brokerserviceurltls(from._internal_brokerserviceurltls());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.response_ = from._impl_.response_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.authoritative_ = from._impl_.authoritative_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.proxy_through_service_url_ = from._impl_.proxy_through_service_url_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandLookupTopicResponse::CopyFrom(const CommandLookupTopicResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandLookupTopicResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandLookupTopicResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandLookupTopicResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandLookupTopicResponse::InternalSwap(CommandLookupTopicResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.brokerserviceurl_, &other->_impl_.brokerserviceurl_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.brokerserviceurltls_, &other->_impl_.brokerserviceurltls_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.proxy_through_service_url_)
      + sizeof(CommandLookupTopicResponse::_impl_.proxy_through_service_url_)
      - PROTOBUF_FIELD_OFFSET(CommandLookupTopicResponse, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandLookupTopicResponse::GetTypeName() const {
  return "pulsar.proto.CommandLookupTopicResponse";
}

// ===================================================================

class CommandProducer::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandProducer>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_._has_bits_);
  static void set_has_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_producer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_producer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_encrypted(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::pulsar::proto::Schema& schema(const CommandProducer* msg);
  static void set_has_schema(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_epoch(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_user_provided_producer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_producer_access_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_topic_epoch(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_txn_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_initial_subscription_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000031) ^ 0x00000031) != 0;
  }
};

const ::pulsar::proto::Schema& CommandProducer::_Internal::schema(const CommandProducer* msg) {
  return *msg->_impl_.schema_;
}
CommandProducer::CommandProducer(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandProducer)
}
inline PROTOBUF_NDEBUG_INLINE CommandProducer::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        metadata_{visibility, arena, from.metadata_},
        topic_(arena, from.topic_),
        producer_name_(arena, from.producer_name_),
        initial_subscription_name_(arena, from.initial_subscription_name_) {}

CommandProducer::CommandProducer(
    ::google::protobuf::Arena* arena,
    const CommandProducer& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandProducer* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.schema_ = (cached_has_bits & 0x00000008u)
                ? CreateMaybeMessage<::pulsar::proto::Schema>(arena, *from._impl_.schema_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, producer_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, producer_id_),
           offsetof(Impl_, user_provided_producer_name_) -
               offsetof(Impl_, producer_id_) +
               sizeof(Impl_::user_provided_producer_name_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandProducer)
}
inline PROTOBUF_NDEBUG_INLINE CommandProducer::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        metadata_{visibility, arena},
        topic_(arena),
        producer_name_(arena),
        initial_subscription_name_(arena),
        user_provided_producer_name_{true} {}

inline void CommandProducer::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, schema_),
           0,
           offsetof(Impl_, topic_epoch_) -
               offsetof(Impl_, schema_) +
               sizeof(Impl_::topic_epoch_));
}
CommandProducer::~CommandProducer() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandProducer)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandProducer::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.topic_.Destroy();
  _impl_.producer_name_.Destroy();
  _impl_.initial_subscription_name_.Destroy();
  delete _impl_.schema_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandProducer::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandProducer)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metadata_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.producer_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.initial_subscription_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.schema_ != nullptr);
      _impl_.schema_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.producer_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.encrypted_) -
        reinterpret_cast<char*>(&_impl_.producer_id_)) + sizeof(_impl_.encrypted_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.txn_enabled_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.topic_epoch_) -
        reinterpret_cast<char*>(&_impl_.txn_enabled_)) + sizeof(_impl_.topic_epoch_));
    _impl_.user_provided_producer_name_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandProducer::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 13, 3, 0, 2> CommandProducer::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_._has_bits_),
    0, // no _extensions_
    13, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294959104,  // skipmap
    offsetof(decltype(_table_), field_entries),
    13,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandProducer_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string topic = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.topic_)}},
    // required uint64 producer_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 4, 0, PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.producer_id_)}},
    // required uint64 request_id = 3;
    {::_pbi::TcParser::FastV64S1,
     {24, 5, 0, PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.request_id_)}},
    // optional string producer_name = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.producer_name_)}},
    // optional bool encrypted = 5 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {40, 7, 0, PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.encrypted_)}},
    // repeated .pulsar.proto.KeyValue metadata = 6;
    {::_pbi::TcParser::FastMtR1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.metadata_)}},
    // optional .pulsar.proto.Schema schema = 7;
    {::_pbi::TcParser::FastMtS1,
     {58, 3, 1, PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.schema_)}},
    // optional uint64 epoch = 8 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {64, 6, 0, PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.epoch_)}},
    // optional bool user_provided_producer_name = 9 [default = true];
    {::_pbi::TcParser::FastV8S1,
     {72, 11, 0, PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.user_provided_producer_name_)}},
    // optional .pulsar.proto.ProducerAccessMode producer_access_mode = 10 [default = Shared];
    {::_pbi::TcParser::FastEr0S1,
     {80, 9, 3, PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.producer_access_mode_)}},
    // optional uint64 topic_epoch = 11;
    {::_pbi::TcParser::FastV64S1,
     {88, 10, 0, PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.topic_epoch_)}},
    // optional bool txn_enabled = 12 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {96, 8, 0, PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.txn_enabled_)}},
    // optional string initial_subscription_name = 13;
    {::_pbi::TcParser::FastBS1,
     {106, 2, 0, PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.initial_subscription_name_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required string topic = 1;
    {PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.topic_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // required uint64 producer_id = 2;
    {PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.producer_id_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint64 request_id = 3;
    {PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.request_id_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional string producer_name = 4;
    {PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.producer_name_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bool encrypted = 5 [default = false];
    {PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.encrypted_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated .pulsar.proto.KeyValue metadata = 6;
    {PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.metadata_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.Schema schema = 7;
    {PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.schema_), _Internal::kHasBitsOffset + 3, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint64 epoch = 8 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.epoch_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional bool user_provided_producer_name = 9 [default = true];
    {PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.user_provided_producer_name_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .pulsar.proto.ProducerAccessMode producer_access_mode = 10 [default = Shared];
    {PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.producer_access_mode_), _Internal::kHasBitsOffset + 9, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional uint64 topic_epoch = 11;
    {PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.topic_epoch_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional bool txn_enabled = 12 [default = false];
    {PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.txn_enabled_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional string initial_subscription_name = 13;
    {PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.initial_subscription_name_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::KeyValue>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::Schema>()},
    {0, 4},
  }}, {{
  }},
};

::uint8_t* CommandProducer::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandProducer)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string topic = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_topic();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required uint64 producer_id = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_producer_id(), target);
  }

  // required uint64 request_id = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_request_id(), target);
  }

  // optional string producer_name = 4;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_producer_name();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional bool encrypted = 5 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_encrypted(), target);
  }

  // repeated .pulsar.proto.KeyValue metadata = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_metadata_size()); i < n; i++) {
    const auto& repfield = this->_internal_metadata().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.Schema schema = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        7, _Internal::schema(this),
        _Internal::schema(this).GetCachedSize(), target, stream);
  }

  // optional uint64 epoch = 8 [default = 0];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        8, this->_internal_epoch(), target);
  }

  // optional bool user_provided_producer_name = 9 [default = true];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this->_internal_user_provided_producer_name(), target);
  }

  // optional .pulsar.proto.ProducerAccessMode producer_access_mode = 10 [default = Shared];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        10, this->_internal_producer_access_mode(), target);
  }

  // optional uint64 topic_epoch = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        11, this->_internal_topic_epoch(), target);
  }

  // optional bool txn_enabled = 12 [default = false];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        12, this->_internal_txn_enabled(), target);
  }

  // optional string initial_subscription_name = 13;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_initial_subscription_name();
    target = stream->WriteStringMaybeAliased(13, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandProducer)
  return target;
}

::size_t CommandProducer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandProducer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.KeyValue metadata = 6;
  total_size += 1UL * this->_internal_metadata_size();
  for (const auto& msg : this->_internal_metadata()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // required string topic = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_topic());
  }

  if (cached_has_bits & 0x0000000eu) {
    // optional string producer_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_producer_name());
    }

    // optional string initial_subscription_name = 13;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_initial_subscription_name());
    }

    // optional .pulsar.proto.Schema schema = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.schema_);
    }

  }
  if (cached_has_bits & 0x00000030u) {
    // required uint64 producer_id = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_producer_id());
    }

    // required uint64 request_id = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_request_id());
    }

  }
  if (cached_has_bits & 0x000000c0u) {
    // optional uint64 epoch = 8 [default = 0];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_epoch());
    }

    // optional bool encrypted = 5 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 2;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional bool txn_enabled = 12 [default = false];
    if (cached_has_bits & 0x00000100u) {
      total_size += 2;
    }

    // optional .pulsar.proto.ProducerAccessMode producer_access_mode = 10 [default = Shared];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_producer_access_mode());
    }

    // optional uint64 topic_epoch = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_topic_epoch());
    }

    // optional bool user_provided_producer_name = 9 [default = true];
    if (cached_has_bits & 0x00000800u) {
      total_size += 2;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandProducer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandProducer*>(
      &from));
}

void CommandProducer::MergeFrom(const CommandProducer& from) {
  CommandProducer* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandProducer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_metadata()->MergeFrom(
      from._internal_metadata());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_topic(from._internal_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_producer_name(from._internal_producer_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_initial_subscription_name(from._internal_initial_subscription_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_schema()->::pulsar::proto::Schema::MergeFrom(
          from._internal_schema());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.producer_id_ = from._impl_.producer_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.epoch_ = from._impl_.epoch_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.encrypted_ = from._impl_.encrypted_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.txn_enabled_ = from._impl_.txn_enabled_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.producer_access_mode_ = from._impl_.producer_access_mode_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.topic_epoch_ = from._impl_.topic_epoch_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.user_provided_producer_name_ = from._impl_.user_provided_producer_name_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandProducer::CopyFrom(const CommandProducer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandProducer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandProducer::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_metadata()))
    return false;
  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (!_impl_.schema_->IsInitialized()) return false;
  }
  return true;
}

::_pbi::CachedSize* CommandProducer::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandProducer::InternalSwap(CommandProducer* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.topic_, &other->_impl_.topic_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.producer_name_, &other->_impl_.producer_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.initial_subscription_name_, &other->_impl_.initial_subscription_name_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.user_provided_producer_name_)
      + sizeof(CommandProducer::_impl_.user_provided_producer_name_)
      - PROTOBUF_FIELD_OFFSET(CommandProducer, _impl_.schema_)>(
          reinterpret_cast<char*>(&_impl_.schema_),
          reinterpret_cast<char*>(&other->_impl_.schema_));
}

std::string CommandProducer::GetTypeName() const {
  return "pulsar.proto.CommandProducer";
}

// ===================================================================

class CommandSend::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSend>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandSend, _impl_._has_bits_);
  static void set_has_producer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_messages(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_highest_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_chunk(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_marker(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::pulsar::proto::MessageIdData& message_id(const CommandSend* msg);
  static void set_has_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

const ::pulsar::proto::MessageIdData& CommandSend::_Internal::message_id(const CommandSend* msg) {
  return *msg->_impl_.message_id_;
}
CommandSend::CommandSend(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandSend)
}
inline PROTOBUF_NDEBUG_INLINE CommandSend::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

CommandSend::CommandSend(
    ::google::protobuf::Arena* arena,
    const CommandSend& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandSend* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.message_id_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::pulsar::proto::MessageIdData>(arena, *from._impl_.message_id_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, producer_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, producer_id_),
           offsetof(Impl_, num_messages_) -
               offsetof(Impl_, producer_id_) +
               sizeof(Impl_::num_messages_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandSend)
}
inline PROTOBUF_NDEBUG_INLINE CommandSend::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        num_messages_{1} {}

inline void CommandSend::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, message_id_),
           0,
           offsetof(Impl_, marker_) -
               offsetof(Impl_, message_id_) +
               sizeof(Impl_::marker_));
}
CommandSend::~CommandSend() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandSend)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandSend::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.message_id_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandSend::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandSend)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.message_id_ != nullptr);
    _impl_.message_id_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.producer_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.marker_) -
        reinterpret_cast<char*>(&_impl_.producer_id_)) + sizeof(_impl_.marker_));
  }
  _impl_.num_messages_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandSend::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 1, 0, 2> CommandSend::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandSend, _impl_._has_bits_),
    0, // no _extensions_
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandSend_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 producer_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.producer_id_)}},
    // required uint64 sequence_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.sequence_id_)}},
    // optional int32 num_messages = 3 [default = 1];
    {::_pbi::TcParser::FastV32S1,
     {24, 8, 0, PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.num_messages_)}},
    // optional uint64 txnid_least_bits = 4 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.txnid_least_bits_)}},
    // optional uint64 txnid_most_bits = 5 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {40, 4, 0, PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.txnid_most_bits_)}},
    // optional uint64 highest_sequence_id = 6 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {48, 5, 0, PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.highest_sequence_id_)}},
    // optional bool is_chunk = 7 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {56, 6, 0, PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.is_chunk_)}},
    // optional bool marker = 8 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {64, 7, 0, PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.marker_)}},
    // optional .pulsar.proto.MessageIdData message_id = 9;
    {::_pbi::TcParser::FastMtS1,
     {74, 0, 0, PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.message_id_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 producer_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.producer_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint64 sequence_id = 2;
    {PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.sequence_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional int32 num_messages = 3 [default = 1];
    {PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.num_messages_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional uint64 txnid_least_bits = 4 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.txnid_least_bits_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_most_bits = 5 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.txnid_most_bits_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 highest_sequence_id = 6 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.highest_sequence_id_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional bool is_chunk = 7 [default = false];
    {PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.is_chunk_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool marker = 8 [default = false];
    {PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.marker_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .pulsar.proto.MessageIdData message_id = 9;
    {PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.message_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::MessageIdData>()},
  }}, {{
  }},
};

::uint8_t* CommandSend::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandSend)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 producer_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_producer_id(), target);
  }

  // required uint64 sequence_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_sequence_id(), target);
  }

  // optional int32 num_messages = 3 [default = 1];
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_num_messages(), target);
  }

  // optional uint64 txnid_least_bits = 4 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 5 [default = 0];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_txnid_most_bits(), target);
  }

  // optional uint64 highest_sequence_id = 6 [default = 0];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_highest_sequence_id(), target);
  }

  // optional bool is_chunk = 7 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_is_chunk(), target);
  }

  // optional bool marker = 8 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_marker(), target);
  }

  // optional .pulsar.proto.MessageIdData message_id = 9;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        9, _Internal::message_id(this),
        _Internal::message_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandSend)
  return target;
}

::size_t CommandSend::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandSend)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .pulsar.proto.MessageIdData message_id = 9;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.message_id_);
  }

  if (cached_has_bits & 0x00000006u) {
    // required uint64 producer_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_producer_id());
    }

    // required uint64 sequence_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_sequence_id());
    }

  }
  if (cached_has_bits & 0x000000f8u) {
    // optional uint64 txnid_least_bits = 4 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 5 [default = 0];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_most_bits());
    }

    // optional uint64 highest_sequence_id = 6 [default = 0];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_highest_sequence_id());
    }

    // optional bool is_chunk = 7 [default = false];
    if (cached_has_bits & 0x00000040u) {
      total_size += 2;
    }

    // optional bool marker = 8 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 2;
    }

  }
  // optional int32 num_messages = 3 [default = 1];
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_num_messages());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandSend::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandSend*>(
      &from));
}

void CommandSend::MergeFrom(const CommandSend& from) {
  CommandSend* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandSend)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_message_id()->::pulsar::proto::MessageIdData::MergeFrom(
          from._internal_message_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.producer_id_ = from._impl_.producer_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sequence_id_ = from._impl_.sequence_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.txnid_least_bits_ = from._impl_.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.txnid_most_bits_ = from._impl_.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.highest_sequence_id_ = from._impl_.highest_sequence_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.is_chunk_ = from._impl_.is_chunk_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.marker_ = from._impl_.marker_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_num_messages(from._internal_num_messages());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandSend::CopyFrom(const CommandSend& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandSend)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandSend::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.message_id_->IsInitialized()) return false;
  }
  return true;
}

::_pbi::CachedSize* CommandSend::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandSend::InternalSwap(CommandSend* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.num_messages_)
      + sizeof(CommandSend::_impl_.num_messages_)
      - PROTOBUF_FIELD_OFFSET(CommandSend, _impl_.message_id_)>(
          reinterpret_cast<char*>(&_impl_.message_id_),
          reinterpret_cast<char*>(&other->_impl_.message_id_));
}

std::string CommandSend::GetTypeName() const {
  return "pulsar.proto.CommandSend";
}

// ===================================================================

class CommandSendReceipt::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSendReceipt>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandSendReceipt, _impl_._has_bits_);
  static void set_has_producer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::pulsar::proto::MessageIdData& message_id(const CommandSendReceipt* msg);
  static void set_has_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_highest_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

const ::pulsar::proto::MessageIdData& CommandSendReceipt::_Internal::message_id(const CommandSendReceipt* msg) {
  return *msg->_impl_.message_id_;
}
CommandSendReceipt::CommandSendReceipt(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandSendReceipt)
}
inline PROTOBUF_NDEBUG_INLINE CommandSendReceipt::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

CommandSendReceipt::CommandSendReceipt(
    ::google::protobuf::Arena* arena,
    const CommandSendReceipt& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandSendReceipt* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.message_id_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::pulsar::proto::MessageIdData>(arena, *from._impl_.message_id_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, producer_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, producer_id_),
           offsetof(Impl_, highest_sequence_id_) -
               offsetof(Impl_, producer_id_) +
               sizeof(Impl_::highest_sequence_id_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandSendReceipt)
}
inline PROTOBUF_NDEBUG_INLINE CommandSendReceipt::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CommandSendReceipt::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, message_id_),
           0,
           offsetof(Impl_, highest_sequence_id_) -
               offsetof(Impl_, message_id_) +
               sizeof(Impl_::highest_sequence_id_));
}
CommandSendReceipt::~CommandSendReceipt() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandSendReceipt)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandSendReceipt::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.message_id_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandSendReceipt::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandSendReceipt)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.message_id_ != nullptr);
    _impl_.message_id_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.producer_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.highest_sequence_id_) -
        reinterpret_cast<char*>(&_impl_.producer_id_)) + sizeof(_impl_.highest_sequence_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandSendReceipt::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2> CommandSendReceipt::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandSendReceipt, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandSendReceipt_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional uint64 highest_sequence_id = 4 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(CommandSendReceipt, _impl_.highest_sequence_id_)}},
    // required uint64 producer_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandSendReceipt, _impl_.producer_id_)}},
    // required uint64 sequence_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(CommandSendReceipt, _impl_.sequence_id_)}},
    // optional .pulsar.proto.MessageIdData message_id = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(CommandSendReceipt, _impl_.message_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 producer_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandSendReceipt, _impl_.producer_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint64 sequence_id = 2;
    {PROTOBUF_FIELD_OFFSET(CommandSendReceipt, _impl_.sequence_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.MessageIdData message_id = 3;
    {PROTOBUF_FIELD_OFFSET(CommandSendReceipt, _impl_.message_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint64 highest_sequence_id = 4 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandSendReceipt, _impl_.highest_sequence_id_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::MessageIdData>()},
  }}, {{
  }},
};

::uint8_t* CommandSendReceipt::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandSendReceipt)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 producer_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_producer_id(), target);
  }

  // required uint64 sequence_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_sequence_id(), target);
  }

  // optional .pulsar.proto.MessageIdData message_id = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::message_id(this),
        _Internal::message_id(this).GetCachedSize(), target, stream);
  }

  // optional uint64 highest_sequence_id = 4 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_highest_sequence_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandSendReceipt)
  return target;
}

::size_t CommandSendReceipt::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandSendReceipt)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .pulsar.proto.MessageIdData message_id = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.message_id_);
  }

  if (cached_has_bits & 0x00000006u) {
    // required uint64 producer_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_producer_id());
    }

    // required uint64 sequence_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_sequence_id());
    }

  }
  // optional uint64 highest_sequence_id = 4 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_highest_sequence_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandSendReceipt::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandSendReceipt*>(
      &from));
}

void CommandSendReceipt::MergeFrom(const CommandSendReceipt& from) {
  CommandSendReceipt* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandSendReceipt)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_message_id()->::pulsar::proto::MessageIdData::MergeFrom(
          from._internal_message_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.producer_id_ = from._impl_.producer_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sequence_id_ = from._impl_.sequence_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.highest_sequence_id_ = from._impl_.highest_sequence_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandSendReceipt::CopyFrom(const CommandSendReceipt& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandSendReceipt)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandSendReceipt::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.message_id_->IsInitialized()) return false;
  }
  return true;
}

::_pbi::CachedSize* CommandSendReceipt::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandSendReceipt::InternalSwap(CommandSendReceipt* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSendReceipt, _impl_.highest_sequence_id_)
      + sizeof(CommandSendReceipt::_impl_.highest_sequence_id_)
      - PROTOBUF_FIELD_OFFSET(CommandSendReceipt, _impl_.message_id_)>(
          reinterpret_cast<char*>(&_impl_.message_id_),
          reinterpret_cast<char*>(&other->_impl_.message_id_));
}

std::string CommandSendReceipt::GetTypeName() const {
  return "pulsar.proto.CommandSendReceipt";
}

// ===================================================================

class CommandSendError::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSendError>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandSendError, _impl_._has_bits_);
  static void set_has_producer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

CommandSendError::CommandSendError(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandSendError)
}
inline PROTOBUF_NDEBUG_INLINE CommandSendError::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_(arena, from.message_) {}

CommandSendError::CommandSendError(
    ::google::protobuf::Arena* arena,
    const CommandSendError& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandSendError* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, producer_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, producer_id_),
           offsetof(Impl_, error_) -
               offsetof(Impl_, producer_id_) +
               sizeof(Impl_::error_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandSendError)
}
inline PROTOBUF_NDEBUG_INLINE CommandSendError::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        message_(arena) {}

inline void CommandSendError::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, producer_id_),
           0,
           offsetof(Impl_, error_) -
               offsetof(Impl_, producer_id_) +
               sizeof(Impl_::error_));
}
CommandSendError::~CommandSendError() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandSendError)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandSendError::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.message_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandSendError::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandSendError)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.producer_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.error_) -
        reinterpret_cast<char*>(&_impl_.producer_id_)) + sizeof(_impl_.error_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandSendError::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2> CommandSendError::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandSendError, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandSendError_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // required string message = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(CommandSendError, _impl_.message_)}},
    // required uint64 producer_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandSendError, _impl_.producer_id_)}},
    // required uint64 sequence_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(CommandSendError, _impl_.sequence_id_)}},
    // required .pulsar.proto.ServerError error = 3;
    {::_pbi::TcParser::FastEr0S1,
     {24, 3, 25, PROTOBUF_FIELD_OFFSET(CommandSendError, _impl_.error_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 producer_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandSendError, _impl_.producer_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint64 sequence_id = 2;
    {PROTOBUF_FIELD_OFFSET(CommandSendError, _impl_.sequence_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required .pulsar.proto.ServerError error = 3;
    {PROTOBUF_FIELD_OFFSET(CommandSendError, _impl_.error_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // required string message = 4;
    {PROTOBUF_FIELD_OFFSET(CommandSendError, _impl_.message_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {0, 26},
  }}, {{
  }},
};

::uint8_t* CommandSendError::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandSendError)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 producer_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_producer_id(), target);
  }

  // required uint64 sequence_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_sequence_id(), target);
  }

  // required .pulsar.proto.ServerError error = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_error(), target);
  }

  // required string message = 4;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_message();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandSendError)
  return target;
}

::size_t CommandSendError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandSendError)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // required string message = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_message());
    }

    // required uint64 producer_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_producer_id());
    }

    // required uint64 sequence_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_sequence_id());
    }

    // required .pulsar.proto.ServerError error = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandSendError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandSendError*>(
      &from));
}

void CommandSendError::MergeFrom(const CommandSendError& from) {
  CommandSendError* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandSendError)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.producer_id_ = from._impl_.producer_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sequence_id_ = from._impl_.sequence_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandSendError::CopyFrom(const CommandSendError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandSendError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandSendError::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandSendError::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandSendError::InternalSwap(CommandSendError* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSendError, _impl_.error_)
      + sizeof(CommandSendError::_impl_.error_)
      - PROTOBUF_FIELD_OFFSET(CommandSendError, _impl_.producer_id_)>(
          reinterpret_cast<char*>(&_impl_.producer_id_),
          reinterpret_cast<char*>(&other->_impl_.producer_id_));
}

std::string CommandSendError::GetTypeName() const {
  return "pulsar.proto.CommandSendError";
}

// ===================================================================

class CommandMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandMessage, _impl_._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pulsar::proto::MessageIdData& message_id(const CommandMessage* msg);
  static void set_has_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_redelivery_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_consumer_epoch(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::pulsar::proto::MessageIdData& CommandMessage::_Internal::message_id(const CommandMessage* msg) {
  return *msg->_impl_.message_id_;
}
CommandMessage::CommandMessage(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandMessage)
}
inline PROTOBUF_NDEBUG_INLINE CommandMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        ack_set_{visibility, arena, from.ack_set_} {}

CommandMessage::CommandMessage(
    ::google::protobuf::Arena* arena,
    const CommandMessage& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandMessage* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.message_id_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::pulsar::proto::MessageIdData>(arena, *from._impl_.message_id_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, consumer_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, consumer_id_),
           offsetof(Impl_, redelivery_count_) -
               offsetof(Impl_, consumer_id_) +
               sizeof(Impl_::redelivery_count_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandMessage)
}
inline PROTOBUF_NDEBUG_INLINE CommandMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        ack_set_{visibility, arena} {}

inline void CommandMessage::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, message_id_),
           0,
           offsetof(Impl_, redelivery_count_) -
               offsetof(Impl_, message_id_) +
               sizeof(Impl_::redelivery_count_));
}
CommandMessage::~CommandMessage() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandMessage)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandMessage::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.message_id_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandMessage)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ack_set_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.message_id_ != nullptr);
    _impl_.message_id_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.consumer_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.redelivery_count_) -
        reinterpret_cast<char*>(&_impl_.consumer_id_)) + sizeof(_impl_.redelivery_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandMessage::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 1, 0, 2> CommandMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandMessage, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandMessage_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 consumer_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandMessage, _impl_.consumer_id_)}},
    // required .pulsar.proto.MessageIdData message_id = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(CommandMessage, _impl_.message_id_)}},
    // optional uint32 redelivery_count = 3 [default = 0];
    {::_pbi::TcParser::FastV32S1,
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(CommandMessage, _impl_.redelivery_count_)}},
    // repeated int64 ack_set = 4;
    {::_pbi::TcParser::FastV64R1,
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(CommandMessage, _impl_.ack_set_)}},
    // optional uint64 consumer_epoch = 5;
    {::_pbi::TcParser::FastV64S1,
     {40, 2, 0, PROTOBUF_FIELD_OFFSET(CommandMessage, _impl_.consumer_epoch_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 consumer_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandMessage, _impl_.consumer_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required .pulsar.proto.MessageIdData message_id = 2;
    {PROTOBUF_FIELD_OFFSET(CommandMessage, _impl_.message_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint32 redelivery_count = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandMessage, _impl_.redelivery_count_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // repeated int64 ack_set = 4;
    {PROTOBUF_FIELD_OFFSET(CommandMessage, _impl_.ack_set_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kInt64)},
    // optional uint64 consumer_epoch = 5;
    {PROTOBUF_FIELD_OFFSET(CommandMessage, _impl_.consumer_epoch_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::MessageIdData>()},
  }}, {{
  }},
};

::uint8_t* CommandMessage::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_consumer_id(), target);
  }

  // required .pulsar.proto.MessageIdData message_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::message_id(this),
        _Internal::message_id(this).GetCachedSize(), target, stream);
  }

  // optional uint32 redelivery_count = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_redelivery_count(), target);
  }

  // repeated int64 ack_set = 4;
  for (int i = 0, n = this->_internal_ack_set_size(); i < n; ++i) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        4, this->_internal_ack_set().Get(i), target);
  }

  // optional uint64 consumer_epoch = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_consumer_epoch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandMessage)
  return target;
}

::size_t CommandMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 ack_set = 4;
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int64Size(
        this->_internal_ack_set())
    ;
    std::size_t tag_size = std::size_t{1} *
        ::_pbi::FromIntSize(this->_internal_ack_set_size());
    ;
    total_size += tag_size + data_size;
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required .pulsar.proto.MessageIdData message_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.message_id_);
    }

    // required uint64 consumer_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_consumer_id());
    }

  }
  if (cached_has_bits & 0x0000000cu) {
    // optional uint64 consumer_epoch = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_consumer_epoch());
    }

    // optional uint32 redelivery_count = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_redelivery_count());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandMessage*>(
      &from));
}

void CommandMessage::MergeFrom(const CommandMessage& from) {
  CommandMessage* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_ack_set()->MergeFrom(from._internal_ack_set());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_message_id()->::pulsar::proto::MessageIdData::MergeFrom(
          from._internal_message_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.consumer_id_ = from._impl_.consumer_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.consumer_epoch_ = from._impl_.consumer_epoch_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.redelivery_count_ = from._impl_.redelivery_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandMessage::CopyFrom(const CommandMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.message_id_->IsInitialized()) return false;
  }
  return true;
}

::_pbi::CachedSize* CommandMessage::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandMessage::InternalSwap(CommandMessage* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.ack_set_.InternalSwap(&other->_impl_.ack_set_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandMessage, _impl_.redelivery_count_)
      + sizeof(CommandMessage::_impl_.redelivery_count_)
      - PROTOBUF_FIELD_OFFSET(CommandMessage, _impl_.message_id_)>(
          reinterpret_cast<char*>(&_impl_.message_id_),
          reinterpret_cast<char*>(&other->_impl_.message_id_));
}

std::string CommandMessage::GetTypeName() const {
  return "pulsar.proto.CommandMessage";
}

// ===================================================================

class CommandAck::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandAck>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandAck, _impl_._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ack_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_validation_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CommandAck::CommandAck(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandAck)
}
inline PROTOBUF_NDEBUG_INLINE CommandAck::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_id_{visibility, arena, from.message_id_},
        properties_{visibility, arena, from.properties_} {}

CommandAck::CommandAck(
    ::google::protobuf::Arena* arena,
    const CommandAck& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandAck* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, consumer_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, consumer_id_),
           offsetof(Impl_, request_id_) -
               offsetof(Impl_, consumer_id_) +
               sizeof(Impl_::request_id_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandAck)
}
inline PROTOBUF_NDEBUG_INLINE CommandAck::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        message_id_{visibility, arena},
        properties_{visibility, arena} {}

inline void CommandAck::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, consumer_id_),
           0,
           offsetof(Impl_, request_id_) -
               offsetof(Impl_, consumer_id_) +
               sizeof(Impl_::request_id_));
}
CommandAck::~CommandAck() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandAck)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandAck::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandAck::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandAck)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_id_.Clear();
  _impl_.properties_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.consumer_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.request_id_) -
        reinterpret_cast<char*>(&_impl_.consumer_id_)) + sizeof(_impl_.request_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandAck::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 4, 0, 2> CommandAck::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandAck, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandAck_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional uint64 request_id = 8;
    {::_pbi::TcParser::FastV64S1,
     {64, 5, 0, PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.request_id_)}},
    // required uint64 consumer_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.consumer_id_)}},
    // required .pulsar.proto.CommandAck.AckType ack_type = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 1, 1, PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.ack_type_)}},
    // repeated .pulsar.proto.MessageIdData message_id = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 1, PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.message_id_)}},
    // optional .pulsar.proto.CommandAck.ValidationError validation_error = 4;
    {::_pbi::TcParser::FastEr0S1,
     {32, 2, 4, PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.validation_error_)}},
    // repeated .pulsar.proto.KeyLongValue properties = 5;
    {::_pbi::TcParser::FastMtR1,
     {42, 63, 3, PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.properties_)}},
    // optional uint64 txnid_least_bits = 6 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {48, 3, 0, PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.txnid_least_bits_)}},
    // optional uint64 txnid_most_bits = 7 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {56, 4, 0, PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.txnid_most_bits_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 consumer_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.consumer_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required .pulsar.proto.CommandAck.AckType ack_type = 2;
    {PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.ack_type_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // repeated .pulsar.proto.MessageIdData message_id = 3;
    {PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.message_id_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandAck.ValidationError validation_error = 4;
    {PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.validation_error_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // repeated .pulsar.proto.KeyLongValue properties = 5;
    {PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.properties_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint64 txnid_least_bits = 6 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.txnid_least_bits_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_most_bits = 7 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.txnid_most_bits_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 request_id = 8;
    {PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.request_id_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }}, {{
    {0, 2},
    {::_pbi::TcParser::GetTable<::pulsar::proto::MessageIdData>()},
    {0, 5},
    {::_pbi::TcParser::GetTable<::pulsar::proto::KeyLongValue>()},
  }}, {{
  }},
};

::uint8_t* CommandAck::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandAck)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_consumer_id(), target);
  }

  // required .pulsar.proto.CommandAck.AckType ack_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_ack_type(), target);
  }

  // repeated .pulsar.proto.MessageIdData message_id = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_message_id_size()); i < n; i++) {
    const auto& repfield = this->_internal_message_id().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandAck.ValidationError validation_error = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_validation_error(), target);
  }

  // repeated .pulsar.proto.KeyLongValue properties = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_properties().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 txnid_least_bits = 6 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 7 [default = 0];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        7, this->_internal_txnid_most_bits(), target);
  }

  // optional uint64 request_id = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        8, this->_internal_request_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandAck)
  return target;
}

::size_t CommandAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandAck)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.MessageIdData message_id = 3;
  total_size += 1UL * this->_internal_message_id_size();
  for (const auto& msg : this->_internal_message_id()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .pulsar.proto.KeyLongValue properties = 5;
  total_size += 1UL * this->_internal_properties_size();
  for (const auto& msg : this->_internal_properties()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required uint64 consumer_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_consumer_id());
    }

    // required .pulsar.proto.CommandAck.AckType ack_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_ack_type());
    }

  }
  if (cached_has_bits & 0x0000003cu) {
    // optional .pulsar.proto.CommandAck.ValidationError validation_error = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_validation_error());
    }

    // optional uint64 txnid_least_bits = 6 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 7 [default = 0];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_most_bits());
    }

    // optional uint64 request_id = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_request_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandAck*>(
      &from));
}

void CommandAck::MergeFrom(const CommandAck& from) {
  CommandAck* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandAck)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_message_id()->MergeFrom(
      from._internal_message_id());
  _this->_internal_mutable_properties()->MergeFrom(
      from._internal_properties());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.consumer_id_ = from._impl_.consumer_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ack_type_ = from._impl_.ack_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.validation_error_ = from._impl_.validation_error_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.txnid_least_bits_ = from._impl_.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.txnid_most_bits_ = from._impl_.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandAck::CopyFrom(const CommandAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandAck::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_message_id()))
    return false;
  if (!::google::protobuf::internal::AllAreInitialized(_internal_properties()))
    return false;
  return true;
}

::_pbi::CachedSize* CommandAck::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandAck::InternalSwap(CommandAck* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.message_id_.InternalSwap(&other->_impl_.message_id_);
  _impl_.properties_.InternalSwap(&other->_impl_.properties_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.request_id_)
      + sizeof(CommandAck::_impl_.request_id_)
      - PROTOBUF_FIELD_OFFSET(CommandAck, _impl_.consumer_id_)>(
          reinterpret_cast<char*>(&_impl_.consumer_id_),
          reinterpret_cast<char*>(&other->_impl_.consumer_id_));
}

std::string CommandAck::GetTypeName() const {
  return "pulsar.proto.CommandAck";
}

// ===================================================================

class CommandAckResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandAckResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandAckResponse, _impl_._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandAckResponse::CommandAckResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandAckResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandAckResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_(arena, from.message_) {}

CommandAckResponse::CommandAckResponse(
    ::google::protobuf::Arena* arena,
    const CommandAckResponse& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandAckResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, consumer_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, consumer_id_),
           offsetof(Impl_, error_) -
               offsetof(Impl_, consumer_id_) +
               sizeof(Impl_::error_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandAckResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandAckResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        message_(arena) {}

inline void CommandAckResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, consumer_id_),
           0,
           offsetof(Impl_, error_) -
               offsetof(Impl_, consumer_id_) +
               sizeof(Impl_::error_));
}
CommandAckResponse::~CommandAckResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandAckResponse)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandAckResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.message_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandAckResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandAckResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.consumer_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.error_) -
        reinterpret_cast<char*>(&_impl_.consumer_id_)) + sizeof(_impl_.error_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandAckResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 1, 0, 2> CommandAckResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandAckResponse, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandAckResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 consumer_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandAckResponse, _impl_.consumer_id_)}},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(CommandAckResponse, _impl_.txnid_least_bits_)}},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(CommandAckResponse, _impl_.txnid_most_bits_)}},
    // optional .pulsar.proto.ServerError error = 4;
    {::_pbi::TcParser::FastEr0S1,
     {32, 5, 25, PROTOBUF_FIELD_OFFSET(CommandAckResponse, _impl_.error_)}},
    // optional string message = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 0, 0, PROTOBUF_FIELD_OFFSET(CommandAckResponse, _impl_.message_)}},
    // optional uint64 request_id = 6;
    {::_pbi::TcParser::FastV64S1,
     {48, 4, 0, PROTOBUF_FIELD_OFFSET(CommandAckResponse, _impl_.request_id_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 consumer_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandAckResponse, _impl_.consumer_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandAckResponse, _impl_.txnid_least_bits_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandAckResponse, _impl_.txnid_most_bits_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.ServerError error = 4;
    {PROTOBUF_FIELD_OFFSET(CommandAckResponse, _impl_.error_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string message = 5;
    {PROTOBUF_FIELD_OFFSET(CommandAckResponse, _impl_.message_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint64 request_id = 6;
    {PROTOBUF_FIELD_OFFSET(CommandAckResponse, _impl_.request_id_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }}, {{
    {0, 26},
  }}, {{
  }},
};

::uint8_t* CommandAckResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandAckResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_consumer_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.ServerError error = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_error(), target);
  }

  // optional string message = 5;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_message();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional uint64 request_id = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_request_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandAckResponse)
  return target;
}

::size_t CommandAckResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandAckResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_consumer_id());
  }

  if (cached_has_bits & 0x0000003cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_most_bits());
    }

    // optional uint64 request_id = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_request_id());
    }

    // optional .pulsar.proto.ServerError error = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandAckResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandAckResponse*>(
      &from));
}

void CommandAckResponse::MergeFrom(const CommandAckResponse& from) {
  CommandAckResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandAckResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.consumer_id_ = from._impl_.consumer_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.txnid_least_bits_ = from._impl_.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.txnid_most_bits_ = from._impl_.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandAckResponse::CopyFrom(const CommandAckResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandAckResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandAckResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandAckResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandAckResponse::InternalSwap(CommandAckResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandAckResponse, _impl_.error_)
      + sizeof(CommandAckResponse::_impl_.error_)
      - PROTOBUF_FIELD_OFFSET(CommandAckResponse, _impl_.consumer_id_)>(
          reinterpret_cast<char*>(&_impl_.consumer_id_),
          reinterpret_cast<char*>(&other->_impl_.consumer_id_));
}

std::string CommandAckResponse::GetTypeName() const {
  return "pulsar.proto.CommandAckResponse";
}

// ===================================================================

class CommandActiveConsumerChange::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandActiveConsumerChange>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandActiveConsumerChange, _impl_._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_active(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CommandActiveConsumerChange::CommandActiveConsumerChange(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandActiveConsumerChange)
}
CommandActiveConsumerChange::CommandActiveConsumerChange(
    ::google::protobuf::Arena* arena, const CommandActiveConsumerChange& from)
    : CommandActiveConsumerChange(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CommandActiveConsumerChange::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CommandActiveConsumerChange::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, consumer_id_),
           0,
           offsetof(Impl_, is_active_) -
               offsetof(Impl_, consumer_id_) +
               sizeof(Impl_::is_active_));
}
CommandActiveConsumerChange::~CommandActiveConsumerChange() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandActiveConsumerChange)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandActiveConsumerChange::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandActiveConsumerChange::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandActiveConsumerChange)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.consumer_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.is_active_) -
        reinterpret_cast<char*>(&_impl_.consumer_id_)) + sizeof(_impl_.is_active_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandActiveConsumerChange::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> CommandActiveConsumerChange::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandActiveConsumerChange, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandActiveConsumerChange_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional bool is_active = 2 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CommandActiveConsumerChange, _impl_.is_active_)}},
    // required uint64 consumer_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(CommandActiveConsumerChange, _impl_.consumer_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 consumer_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandActiveConsumerChange, _impl_.consumer_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional bool is_active = 2 [default = false];
    {PROTOBUF_FIELD_OFFSET(CommandActiveConsumerChange, _impl_.is_active_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandActiveConsumerChange::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandActiveConsumerChange)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_consumer_id(), target);
  }

  // optional bool is_active = 2 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_is_active(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandActiveConsumerChange)
  return target;
}

::size_t CommandActiveConsumerChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandActiveConsumerChange)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // required uint64 consumer_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_consumer_id());
  }

  // optional bool is_active = 2 [default = false];
  if (cached_has_bits & 0x00000002u) {
    total_size += 2;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandActiveConsumerChange::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandActiveConsumerChange*>(
      &from));
}

void CommandActiveConsumerChange::MergeFrom(const CommandActiveConsumerChange& from) {
  CommandActiveConsumerChange* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandActiveConsumerChange)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.consumer_id_ = from._impl_.consumer_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_active_ = from._impl_.is_active_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandActiveConsumerChange::CopyFrom(const CommandActiveConsumerChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandActiveConsumerChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandActiveConsumerChange::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandActiveConsumerChange::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandActiveConsumerChange::InternalSwap(CommandActiveConsumerChange* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandActiveConsumerChange, _impl_.is_active_)
      + sizeof(CommandActiveConsumerChange::_impl_.is_active_)
      - PROTOBUF_FIELD_OFFSET(CommandActiveConsumerChange, _impl_.consumer_id_)>(
          reinterpret_cast<char*>(&_impl_.consumer_id_),
          reinterpret_cast<char*>(&other->_impl_.consumer_id_));
}

std::string CommandActiveConsumerChange::GetTypeName() const {
  return "pulsar.proto.CommandActiveConsumerChange";
}

// ===================================================================

class CommandFlow::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandFlow>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandFlow, _impl_._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_messagepermits(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CommandFlow::CommandFlow(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandFlow)
}
CommandFlow::CommandFlow(
    ::google::protobuf::Arena* arena, const CommandFlow& from)
    : CommandFlow(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CommandFlow::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CommandFlow::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, consumer_id_),
           0,
           offsetof(Impl_, messagepermits_) -
               offsetof(Impl_, consumer_id_) +
               sizeof(Impl_::messagepermits_));
}
CommandFlow::~CommandFlow() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandFlow)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandFlow::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandFlow::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandFlow)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.consumer_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.messagepermits_) -
        reinterpret_cast<char*>(&_impl_.consumer_id_)) + sizeof(_impl_.messagepermits_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandFlow::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> CommandFlow::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandFlow, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandFlow_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // required uint32 messagePermits = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CommandFlow, _impl_.messagepermits_)}},
    // required uint64 consumer_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(CommandFlow, _impl_.consumer_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 consumer_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandFlow, _impl_.consumer_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint32 messagePermits = 2;
    {PROTOBUF_FIELD_OFFSET(CommandFlow, _impl_.messagepermits_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandFlow::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandFlow)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_consumer_id(), target);
  }

  // required uint32 messagePermits = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_messagepermits(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandFlow)
  return target;
}

::size_t CommandFlow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandFlow)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required uint64 consumer_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_consumer_id());
    }

    // required uint32 messagePermits = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_messagepermits());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandFlow::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandFlow*>(
      &from));
}

void CommandFlow::MergeFrom(const CommandFlow& from) {
  CommandFlow* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandFlow)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.consumer_id_ = from._impl_.consumer_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.messagepermits_ = from._impl_.messagepermits_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandFlow::CopyFrom(const CommandFlow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandFlow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandFlow::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandFlow::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandFlow::InternalSwap(CommandFlow* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandFlow, _impl_.messagepermits_)
      + sizeof(CommandFlow::_impl_.messagepermits_)
      - PROTOBUF_FIELD_OFFSET(CommandFlow, _impl_.consumer_id_)>(
          reinterpret_cast<char*>(&_impl_.consumer_id_),
          reinterpret_cast<char*>(&other->_impl_.consumer_id_));
}

std::string CommandFlow::GetTypeName() const {
  return "pulsar.proto.CommandFlow";
}

// ===================================================================

class CommandUnsubscribe::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandUnsubscribe>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandUnsubscribe, _impl_._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CommandUnsubscribe::CommandUnsubscribe(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandUnsubscribe)
}
CommandUnsubscribe::CommandUnsubscribe(
    ::google::protobuf::Arena* arena, const CommandUnsubscribe& from)
    : CommandUnsubscribe(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CommandUnsubscribe::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CommandUnsubscribe::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, consumer_id_),
           0,
           offsetof(Impl_, request_id_) -
               offsetof(Impl_, consumer_id_) +
               sizeof(Impl_::request_id_));
}
CommandUnsubscribe::~CommandUnsubscribe() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandUnsubscribe)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandUnsubscribe::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandUnsubscribe::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandUnsubscribe)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.consumer_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.request_id_) -
        reinterpret_cast<char*>(&_impl_.consumer_id_)) + sizeof(_impl_.request_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandUnsubscribe::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> CommandUnsubscribe::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandUnsubscribe, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandUnsubscribe_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // required uint64 request_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CommandUnsubscribe, _impl_.request_id_)}},
    // required uint64 consumer_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(CommandUnsubscribe, _impl_.consumer_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 consumer_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandUnsubscribe, _impl_.consumer_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint64 request_id = 2;
    {PROTOBUF_FIELD_OFFSET(CommandUnsubscribe, _impl_.request_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandUnsubscribe::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandUnsubscribe)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_consumer_id(), target);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_request_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandUnsubscribe)
  return target;
}

::size_t CommandUnsubscribe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandUnsubscribe)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required uint64 consumer_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_consumer_id());
    }

    // required uint64 request_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_request_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandUnsubscribe::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandUnsubscribe*>(
      &from));
}

void CommandUnsubscribe::MergeFrom(const CommandUnsubscribe& from) {
  CommandUnsubscribe* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandUnsubscribe)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.consumer_id_ = from._impl_.consumer_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandUnsubscribe::CopyFrom(const CommandUnsubscribe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandUnsubscribe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandUnsubscribe::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandUnsubscribe::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandUnsubscribe::InternalSwap(CommandUnsubscribe* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandUnsubscribe, _impl_.request_id_)
      + sizeof(CommandUnsubscribe::_impl_.request_id_)
      - PROTOBUF_FIELD_OFFSET(CommandUnsubscribe, _impl_.consumer_id_)>(
          reinterpret_cast<char*>(&_impl_.consumer_id_),
          reinterpret_cast<char*>(&other->_impl_.consumer_id_));
}

std::string CommandUnsubscribe::GetTypeName() const {
  return "pulsar.proto.CommandUnsubscribe";
}

// ===================================================================

class CommandSeek::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSeek>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandSeek, _impl_._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::pulsar::proto::MessageIdData& message_id(const CommandSeek* msg);
  static void set_has_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_message_publish_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

const ::pulsar::proto::MessageIdData& CommandSeek::_Internal::message_id(const CommandSeek* msg) {
  return *msg->_impl_.message_id_;
}
CommandSeek::CommandSeek(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandSeek)
}
inline PROTOBUF_NDEBUG_INLINE CommandSeek::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

CommandSeek::CommandSeek(
    ::google::protobuf::Arena* arena,
    const CommandSeek& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandSeek* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.message_id_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::pulsar::proto::MessageIdData>(arena, *from._impl_.message_id_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, consumer_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, consumer_id_),
           offsetof(Impl_, message_publish_time_) -
               offsetof(Impl_, consumer_id_) +
               sizeof(Impl_::message_publish_time_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandSeek)
}
inline PROTOBUF_NDEBUG_INLINE CommandSeek::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CommandSeek::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, message_id_),
           0,
           offsetof(Impl_, message_publish_time_) -
               offsetof(Impl_, message_id_) +
               sizeof(Impl_::message_publish_time_));
}
CommandSeek::~CommandSeek() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandSeek)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandSeek::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.message_id_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandSeek::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandSeek)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.message_id_ != nullptr);
    _impl_.message_id_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.consumer_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.message_publish_time_) -
        reinterpret_cast<char*>(&_impl_.consumer_id_)) + sizeof(_impl_.message_publish_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandSeek::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2> CommandSeek::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandSeek, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandSeek_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional uint64 message_publish_time = 4;
    {::_pbi::TcParser::FastV64S1,
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(CommandSeek, _impl_.message_publish_time_)}},
    // required uint64 consumer_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandSeek, _impl_.consumer_id_)}},
    // required uint64 request_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(CommandSeek, _impl_.request_id_)}},
    // optional .pulsar.proto.MessageIdData message_id = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(CommandSeek, _impl_.message_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 consumer_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandSeek, _impl_.consumer_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint64 request_id = 2;
    {PROTOBUF_FIELD_OFFSET(CommandSeek, _impl_.request_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.MessageIdData message_id = 3;
    {PROTOBUF_FIELD_OFFSET(CommandSeek, _impl_.message_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint64 message_publish_time = 4;
    {PROTOBUF_FIELD_OFFSET(CommandSeek, _impl_.message_publish_time_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::MessageIdData>()},
  }}, {{
  }},
};

::uint8_t* CommandSeek::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandSeek)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_consumer_id(), target);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_request_id(), target);
  }

  // optional .pulsar.proto.MessageIdData message_id = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::message_id(this),
        _Internal::message_id(this).GetCachedSize(), target, stream);
  }

  // optional uint64 message_publish_time = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_message_publish_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandSeek)
  return target;
}

::size_t CommandSeek::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandSeek)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .pulsar.proto.MessageIdData message_id = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.message_id_);
  }

  if (cached_has_bits & 0x00000006u) {
    // required uint64 consumer_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_consumer_id());
    }

    // required uint64 request_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_request_id());
    }

  }
  // optional uint64 message_publish_time = 4;
  if (cached_has_bits & 0x00000008u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_message_publish_time());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandSeek::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandSeek*>(
      &from));
}

void CommandSeek::MergeFrom(const CommandSeek& from) {
  CommandSeek* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandSeek)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_message_id()->::pulsar::proto::MessageIdData::MergeFrom(
          from._internal_message_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.consumer_id_ = from._impl_.consumer_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.message_publish_time_ = from._impl_.message_publish_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandSeek::CopyFrom(const CommandSeek& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandSeek)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandSeek::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.message_id_->IsInitialized()) return false;
  }
  return true;
}

::_pbi::CachedSize* CommandSeek::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandSeek::InternalSwap(CommandSeek* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSeek, _impl_.message_publish_time_)
      + sizeof(CommandSeek::_impl_.message_publish_time_)
      - PROTOBUF_FIELD_OFFSET(CommandSeek, _impl_.message_id_)>(
          reinterpret_cast<char*>(&_impl_.message_id_),
          reinterpret_cast<char*>(&other->_impl_.message_id_));
}

std::string CommandSeek::GetTypeName() const {
  return "pulsar.proto.CommandSeek";
}

// ===================================================================

class CommandReachedEndOfTopic::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandReachedEndOfTopic>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandReachedEndOfTopic, _impl_._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CommandReachedEndOfTopic::CommandReachedEndOfTopic(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandReachedEndOfTopic)
}
CommandReachedEndOfTopic::CommandReachedEndOfTopic(
    ::google::protobuf::Arena* arena, const CommandReachedEndOfTopic& from)
    : CommandReachedEndOfTopic(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CommandReachedEndOfTopic::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CommandReachedEndOfTopic::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.consumer_id_ = {};
}
CommandReachedEndOfTopic::~CommandReachedEndOfTopic() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandReachedEndOfTopic)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandReachedEndOfTopic::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandReachedEndOfTopic::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandReachedEndOfTopic)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.consumer_id_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandReachedEndOfTopic::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> CommandReachedEndOfTopic::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandReachedEndOfTopic, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandReachedEndOfTopic_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // required uint64 consumer_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(CommandReachedEndOfTopic, _impl_.consumer_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 consumer_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandReachedEndOfTopic, _impl_.consumer_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandReachedEndOfTopic::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandReachedEndOfTopic)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_consumer_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandReachedEndOfTopic)
  return target;
}

::size_t CommandReachedEndOfTopic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandReachedEndOfTopic)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // required uint64 consumer_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_consumer_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandReachedEndOfTopic::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandReachedEndOfTopic*>(
      &from));
}

void CommandReachedEndOfTopic::MergeFrom(const CommandReachedEndOfTopic& from) {
  CommandReachedEndOfTopic* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandReachedEndOfTopic)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_consumer_id(from._internal_consumer_id());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandReachedEndOfTopic::CopyFrom(const CommandReachedEndOfTopic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandReachedEndOfTopic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandReachedEndOfTopic::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandReachedEndOfTopic::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandReachedEndOfTopic::InternalSwap(CommandReachedEndOfTopic* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
        swap(_impl_.consumer_id_, other->_impl_.consumer_id_);
}

std::string CommandReachedEndOfTopic::GetTypeName() const {
  return "pulsar.proto.CommandReachedEndOfTopic";
}

// ===================================================================

class CommandTopicMigrated::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandTopicMigrated>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandTopicMigrated, _impl_._has_bits_);
  static void set_has_resource_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_resource_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_brokerserviceurl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_brokerserviceurltls(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000c) ^ 0x0000000c) != 0;
  }
};

CommandTopicMigrated::CommandTopicMigrated(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandTopicMigrated)
}
inline PROTOBUF_NDEBUG_INLINE CommandTopicMigrated::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        brokerserviceurl_(arena, from.brokerserviceurl_),
        brokerserviceurltls_(arena, from.brokerserviceurltls_) {}

CommandTopicMigrated::CommandTopicMigrated(
    ::google::protobuf::Arena* arena,
    const CommandTopicMigrated& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandTopicMigrated* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, resource_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, resource_id_),
           offsetof(Impl_, resource_type_) -
               offsetof(Impl_, resource_id_) +
               sizeof(Impl_::resource_type_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandTopicMigrated)
}
inline PROTOBUF_NDEBUG_INLINE CommandTopicMigrated::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        brokerserviceurl_(arena),
        brokerserviceurltls_(arena) {}

inline void CommandTopicMigrated::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, resource_id_),
           0,
           offsetof(Impl_, resource_type_) -
               offsetof(Impl_, resource_id_) +
               sizeof(Impl_::resource_type_));
}
CommandTopicMigrated::~CommandTopicMigrated() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandTopicMigrated)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandTopicMigrated::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.brokerserviceurl_.Destroy();
  _impl_.brokerserviceurltls_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandTopicMigrated::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandTopicMigrated)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.brokerserviceurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.brokerserviceurltls_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.resource_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.resource_type_) -
        reinterpret_cast<char*>(&_impl_.resource_id_)) + sizeof(_impl_.resource_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandTopicMigrated::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2> CommandTopicMigrated::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandTopicMigrated, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandTopicMigrated_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional string brokerServiceUrlTls = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(CommandTopicMigrated, _impl_.brokerserviceurltls_)}},
    // required uint64 resource_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(CommandTopicMigrated, _impl_.resource_id_)}},
    // required .pulsar.proto.CommandTopicMigrated.ResourceType resource_type = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 3, 1, PROTOBUF_FIELD_OFFSET(CommandTopicMigrated, _impl_.resource_type_)}},
    // optional string brokerServiceUrl = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(CommandTopicMigrated, _impl_.brokerserviceurl_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 resource_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandTopicMigrated, _impl_.resource_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required .pulsar.proto.CommandTopicMigrated.ResourceType resource_type = 2;
    {PROTOBUF_FIELD_OFFSET(CommandTopicMigrated, _impl_.resource_type_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string brokerServiceUrl = 3;
    {PROTOBUF_FIELD_OFFSET(CommandTopicMigrated, _impl_.brokerserviceurl_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string brokerServiceUrlTls = 4;
    {PROTOBUF_FIELD_OFFSET(CommandTopicMigrated, _impl_.brokerserviceurltls_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {0, 2},
  }}, {{
  }},
};

::uint8_t* CommandTopicMigrated::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandTopicMigrated)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 resource_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_resource_id(), target);
  }

  // required .pulsar.proto.CommandTopicMigrated.ResourceType resource_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_resource_type(), target);
  }

  // optional string brokerServiceUrl = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_brokerserviceurl();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional string brokerServiceUrlTls = 4;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_brokerserviceurltls();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandTopicMigrated)
  return target;
}

::size_t CommandTopicMigrated::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandTopicMigrated)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string brokerServiceUrl = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_brokerserviceurl());
    }

    // optional string brokerServiceUrlTls = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_brokerserviceurltls());
    }

  }
  if (cached_has_bits & 0x0000000cu) {
    // required uint64 resource_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_resource_id());
    }

    // required .pulsar.proto.CommandTopicMigrated.ResourceType resource_type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_resource_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandTopicMigrated::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandTopicMigrated*>(
      &from));
}

void CommandTopicMigrated::MergeFrom(const CommandTopicMigrated& from) {
  CommandTopicMigrated* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandTopicMigrated)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_brokerserviceurl(from._internal_brokerserviceurl());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_brokerserviceurltls(from._internal_brokerserviceurltls());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.resource_id_ = from._impl_.resource_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.resource_type_ = from._impl_.resource_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandTopicMigrated::CopyFrom(const CommandTopicMigrated& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandTopicMigrated)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandTopicMigrated::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandTopicMigrated::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandTopicMigrated::InternalSwap(CommandTopicMigrated* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.brokerserviceurl_, &other->_impl_.brokerserviceurl_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.brokerserviceurltls_, &other->_impl_.brokerserviceurltls_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandTopicMigrated, _impl_.resource_type_)
      + sizeof(CommandTopicMigrated::_impl_.resource_type_)
      - PROTOBUF_FIELD_OFFSET(CommandTopicMigrated, _impl_.resource_id_)>(
          reinterpret_cast<char*>(&_impl_.resource_id_),
          reinterpret_cast<char*>(&other->_impl_.resource_id_));
}

std::string CommandTopicMigrated::GetTypeName() const {
  return "pulsar.proto.CommandTopicMigrated";
}

// ===================================================================

class CommandCloseProducer::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandCloseProducer>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandCloseProducer, _impl_._has_bits_);
  static void set_has_producer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_assignedbrokerserviceurl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_assignedbrokerserviceurltls(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000c) ^ 0x0000000c) != 0;
  }
};

CommandCloseProducer::CommandCloseProducer(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandCloseProducer)
}
inline PROTOBUF_NDEBUG_INLINE CommandCloseProducer::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        assignedbrokerserviceurl_(arena, from.assignedbrokerserviceurl_),
        assignedbrokerserviceurltls_(arena, from.assignedbrokerserviceurltls_) {}

CommandCloseProducer::CommandCloseProducer(
    ::google::protobuf::Arena* arena,
    const CommandCloseProducer& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandCloseProducer* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, producer_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, producer_id_),
           offsetof(Impl_, request_id_) -
               offsetof(Impl_, producer_id_) +
               sizeof(Impl_::request_id_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandCloseProducer)
}
inline PROTOBUF_NDEBUG_INLINE CommandCloseProducer::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        assignedbrokerserviceurl_(arena),
        assignedbrokerserviceurltls_(arena) {}

inline void CommandCloseProducer::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, producer_id_),
           0,
           offsetof(Impl_, request_id_) -
               offsetof(Impl_, producer_id_) +
               sizeof(Impl_::request_id_));
}
CommandCloseProducer::~CommandCloseProducer() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandCloseProducer)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandCloseProducer::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.assignedbrokerserviceurl_.Destroy();
  _impl_.assignedbrokerserviceurltls_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandCloseProducer::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandCloseProducer)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.assignedbrokerserviceurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.assignedbrokerserviceurltls_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.producer_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.request_id_) -
        reinterpret_cast<char*>(&_impl_.producer_id_)) + sizeof(_impl_.request_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandCloseProducer::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> CommandCloseProducer::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandCloseProducer, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandCloseProducer_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional string assignedBrokerServiceUrlTls = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(CommandCloseProducer, _impl_.assignedbrokerserviceurltls_)}},
    // required uint64 producer_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(CommandCloseProducer, _impl_.producer_id_)}},
    // required uint64 request_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 3, 0, PROTOBUF_FIELD_OFFSET(CommandCloseProducer, _impl_.request_id_)}},
    // optional string assignedBrokerServiceUrl = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(CommandCloseProducer, _impl_.assignedbrokerserviceurl_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 producer_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandCloseProducer, _impl_.producer_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint64 request_id = 2;
    {PROTOBUF_FIELD_OFFSET(CommandCloseProducer, _impl_.request_id_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional string assignedBrokerServiceUrl = 3;
    {PROTOBUF_FIELD_OFFSET(CommandCloseProducer, _impl_.assignedbrokerserviceurl_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string assignedBrokerServiceUrlTls = 4;
    {PROTOBUF_FIELD_OFFSET(CommandCloseProducer, _impl_.assignedbrokerserviceurltls_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandCloseProducer::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandCloseProducer)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 producer_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_producer_id(), target);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_request_id(), target);
  }

  // optional string assignedBrokerServiceUrl = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_assignedbrokerserviceurl();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional string assignedBrokerServiceUrlTls = 4;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_assignedbrokerserviceurltls();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandCloseProducer)
  return target;
}

::size_t CommandCloseProducer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandCloseProducer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string assignedBrokerServiceUrl = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_assignedbrokerserviceurl());
    }

    // optional string assignedBrokerServiceUrlTls = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_assignedbrokerserviceurltls());
    }

  }
  if (cached_has_bits & 0x0000000cu) {
    // required uint64 producer_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_producer_id());
    }

    // required uint64 request_id = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_request_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandCloseProducer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandCloseProducer*>(
      &from));
}

void CommandCloseProducer::MergeFrom(const CommandCloseProducer& from) {
  CommandCloseProducer* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandCloseProducer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_assignedbrokerserviceurl(from._internal_assignedbrokerserviceurl());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_assignedbrokerserviceurltls(from._internal_assignedbrokerserviceurltls());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.producer_id_ = from._impl_.producer_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandCloseProducer::CopyFrom(const CommandCloseProducer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandCloseProducer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandCloseProducer::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandCloseProducer::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandCloseProducer::InternalSwap(CommandCloseProducer* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.assignedbrokerserviceurl_, &other->_impl_.assignedbrokerserviceurl_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.assignedbrokerserviceurltls_, &other->_impl_.assignedbrokerserviceurltls_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandCloseProducer, _impl_.request_id_)
      + sizeof(CommandCloseProducer::_impl_.request_id_)
      - PROTOBUF_FIELD_OFFSET(CommandCloseProducer, _impl_.producer_id_)>(
          reinterpret_cast<char*>(&_impl_.producer_id_),
          reinterpret_cast<char*>(&other->_impl_.producer_id_));
}

std::string CommandCloseProducer::GetTypeName() const {
  return "pulsar.proto.CommandCloseProducer";
}

// ===================================================================

class CommandCloseConsumer::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandCloseConsumer>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandCloseConsumer, _impl_._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_assignedbrokerserviceurl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_assignedbrokerserviceurltls(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000c) ^ 0x0000000c) != 0;
  }
};

CommandCloseConsumer::CommandCloseConsumer(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandCloseConsumer)
}
inline PROTOBUF_NDEBUG_INLINE CommandCloseConsumer::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        assignedbrokerserviceurl_(arena, from.assignedbrokerserviceurl_),
        assignedbrokerserviceurltls_(arena, from.assignedbrokerserviceurltls_) {}

CommandCloseConsumer::CommandCloseConsumer(
    ::google::protobuf::Arena* arena,
    const CommandCloseConsumer& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandCloseConsumer* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, consumer_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, consumer_id_),
           offsetof(Impl_, request_id_) -
               offsetof(Impl_, consumer_id_) +
               sizeof(Impl_::request_id_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandCloseConsumer)
}
inline PROTOBUF_NDEBUG_INLINE CommandCloseConsumer::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        assignedbrokerserviceurl_(arena),
        assignedbrokerserviceurltls_(arena) {}

inline void CommandCloseConsumer::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, consumer_id_),
           0,
           offsetof(Impl_, request_id_) -
               offsetof(Impl_, consumer_id_) +
               sizeof(Impl_::request_id_));
}
CommandCloseConsumer::~CommandCloseConsumer() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandCloseConsumer)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandCloseConsumer::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.assignedbrokerserviceurl_.Destroy();
  _impl_.assignedbrokerserviceurltls_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandCloseConsumer::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandCloseConsumer)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.assignedbrokerserviceurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.assignedbrokerserviceurltls_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.consumer_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.request_id_) -
        reinterpret_cast<char*>(&_impl_.consumer_id_)) + sizeof(_impl_.request_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandCloseConsumer::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> CommandCloseConsumer::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandCloseConsumer, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandCloseConsumer_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional string assignedBrokerServiceUrlTls = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(CommandCloseConsumer, _impl_.assignedbrokerserviceurltls_)}},
    // required uint64 consumer_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(CommandCloseConsumer, _impl_.consumer_id_)}},
    // required uint64 request_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 3, 0, PROTOBUF_FIELD_OFFSET(CommandCloseConsumer, _impl_.request_id_)}},
    // optional string assignedBrokerServiceUrl = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(CommandCloseConsumer, _impl_.assignedbrokerserviceurl_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 consumer_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandCloseConsumer, _impl_.consumer_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint64 request_id = 2;
    {PROTOBUF_FIELD_OFFSET(CommandCloseConsumer, _impl_.request_id_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional string assignedBrokerServiceUrl = 3;
    {PROTOBUF_FIELD_OFFSET(CommandCloseConsumer, _impl_.assignedbrokerserviceurl_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string assignedBrokerServiceUrlTls = 4;
    {PROTOBUF_FIELD_OFFSET(CommandCloseConsumer, _impl_.assignedbrokerserviceurltls_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandCloseConsumer::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandCloseConsumer)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_consumer_id(), target);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_request_id(), target);
  }

  // optional string assignedBrokerServiceUrl = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_assignedbrokerserviceurl();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional string assignedBrokerServiceUrlTls = 4;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_assignedbrokerserviceurltls();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandCloseConsumer)
  return target;
}

::size_t CommandCloseConsumer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandCloseConsumer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string assignedBrokerServiceUrl = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_assignedbrokerserviceurl());
    }

    // optional string assignedBrokerServiceUrlTls = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_assignedbrokerserviceurltls());
    }

  }
  if (cached_has_bits & 0x0000000cu) {
    // required uint64 consumer_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_consumer_id());
    }

    // required uint64 request_id = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_request_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandCloseConsumer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandCloseConsumer*>(
      &from));
}

void CommandCloseConsumer::MergeFrom(const CommandCloseConsumer& from) {
  CommandCloseConsumer* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandCloseConsumer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_assignedbrokerserviceurl(from._internal_assignedbrokerserviceurl());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_assignedbrokerserviceurltls(from._internal_assignedbrokerserviceurltls());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.consumer_id_ = from._impl_.consumer_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandCloseConsumer::CopyFrom(const CommandCloseConsumer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandCloseConsumer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandCloseConsumer::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandCloseConsumer::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandCloseConsumer::InternalSwap(CommandCloseConsumer* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.assignedbrokerserviceurl_, &other->_impl_.assignedbrokerserviceurl_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.assignedbrokerserviceurltls_, &other->_impl_.assignedbrokerserviceurltls_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandCloseConsumer, _impl_.request_id_)
      + sizeof(CommandCloseConsumer::_impl_.request_id_)
      - PROTOBUF_FIELD_OFFSET(CommandCloseConsumer, _impl_.consumer_id_)>(
          reinterpret_cast<char*>(&_impl_.consumer_id_),
          reinterpret_cast<char*>(&other->_impl_.consumer_id_));
}

std::string CommandCloseConsumer::GetTypeName() const {
  return "pulsar.proto.CommandCloseConsumer";
}

// ===================================================================

class CommandRedeliverUnacknowledgedMessages::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandRedeliverUnacknowledgedMessages>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandRedeliverUnacknowledgedMessages, _impl_._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_consumer_epoch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CommandRedeliverUnacknowledgedMessages::CommandRedeliverUnacknowledgedMessages(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
}
inline PROTOBUF_NDEBUG_INLINE CommandRedeliverUnacknowledgedMessages::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_ids_{visibility, arena, from.message_ids_} {}

CommandRedeliverUnacknowledgedMessages::CommandRedeliverUnacknowledgedMessages(
    ::google::protobuf::Arena* arena,
    const CommandRedeliverUnacknowledgedMessages& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandRedeliverUnacknowledgedMessages* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, consumer_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, consumer_id_),
           offsetof(Impl_, consumer_epoch_) -
               offsetof(Impl_, consumer_id_) +
               sizeof(Impl_::consumer_epoch_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
}
inline PROTOBUF_NDEBUG_INLINE CommandRedeliverUnacknowledgedMessages::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        message_ids_{visibility, arena} {}

inline void CommandRedeliverUnacknowledgedMessages::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, consumer_id_),
           0,
           offsetof(Impl_, consumer_epoch_) -
               offsetof(Impl_, consumer_id_) +
               sizeof(Impl_::consumer_epoch_));
}
CommandRedeliverUnacknowledgedMessages::~CommandRedeliverUnacknowledgedMessages() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandRedeliverUnacknowledgedMessages::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandRedeliverUnacknowledgedMessages::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_ids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.consumer_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.consumer_epoch_) -
        reinterpret_cast<char*>(&_impl_.consumer_id_)) + sizeof(_impl_.consumer_epoch_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandRedeliverUnacknowledgedMessages::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> CommandRedeliverUnacknowledgedMessages::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandRedeliverUnacknowledgedMessages, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandRedeliverUnacknowledgedMessages_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 consumer_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(CommandRedeliverUnacknowledgedMessages, _impl_.consumer_id_)}},
    // repeated .pulsar.proto.MessageIdData message_ids = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(CommandRedeliverUnacknowledgedMessages, _impl_.message_ids_)}},
    // optional uint64 consumer_epoch = 3;
    {::_pbi::TcParser::FastV64S1,
     {24, 1, 0, PROTOBUF_FIELD_OFFSET(CommandRedeliverUnacknowledgedMessages, _impl_.consumer_epoch_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 consumer_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandRedeliverUnacknowledgedMessages, _impl_.consumer_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // repeated .pulsar.proto.MessageIdData message_ids = 2;
    {PROTOBUF_FIELD_OFFSET(CommandRedeliverUnacknowledgedMessages, _impl_.message_ids_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint64 consumer_epoch = 3;
    {PROTOBUF_FIELD_OFFSET(CommandRedeliverUnacknowledgedMessages, _impl_.consumer_epoch_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::MessageIdData>()},
  }}, {{
  }},
};

::uint8_t* CommandRedeliverUnacknowledgedMessages::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_consumer_id(), target);
  }

  // repeated .pulsar.proto.MessageIdData message_ids = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_message_ids_size()); i < n; i++) {
    const auto& repfield = this->_internal_message_ids().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 consumer_epoch = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_consumer_epoch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
  return target;
}

::size_t CommandRedeliverUnacknowledgedMessages::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.MessageIdData message_ids = 2;
  total_size += 1UL * this->_internal_message_ids_size();
  for (const auto& msg : this->_internal_message_ids()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // required uint64 consumer_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_consumer_id());
  }

  // optional uint64 consumer_epoch = 3;
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_consumer_epoch());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandRedeliverUnacknowledgedMessages::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandRedeliverUnacknowledgedMessages*>(
      &from));
}

void CommandRedeliverUnacknowledgedMessages::MergeFrom(const CommandRedeliverUnacknowledgedMessages& from) {
  CommandRedeliverUnacknowledgedMessages* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_message_ids()->MergeFrom(
      from._internal_message_ids());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.consumer_id_ = from._impl_.consumer_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.consumer_epoch_ = from._impl_.consumer_epoch_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandRedeliverUnacknowledgedMessages::CopyFrom(const CommandRedeliverUnacknowledgedMessages& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandRedeliverUnacknowledgedMessages)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandRedeliverUnacknowledgedMessages::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_message_ids()))
    return false;
  return true;
}

::_pbi::CachedSize* CommandRedeliverUnacknowledgedMessages::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandRedeliverUnacknowledgedMessages::InternalSwap(CommandRedeliverUnacknowledgedMessages* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.message_ids_.InternalSwap(&other->_impl_.message_ids_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandRedeliverUnacknowledgedMessages, _impl_.consumer_epoch_)
      + sizeof(CommandRedeliverUnacknowledgedMessages::_impl_.consumer_epoch_)
      - PROTOBUF_FIELD_OFFSET(CommandRedeliverUnacknowledgedMessages, _impl_.consumer_id_)>(
          reinterpret_cast<char*>(&_impl_.consumer_id_),
          reinterpret_cast<char*>(&other->_impl_.consumer_id_));
}

std::string CommandRedeliverUnacknowledgedMessages::GetTypeName() const {
  return "pulsar.proto.CommandRedeliverUnacknowledgedMessages";
}

// ===================================================================

class CommandSuccess::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSuccess>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandSuccess, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pulsar::proto::Schema& schema(const CommandSuccess* msg);
  static void set_has_schema(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::pulsar::proto::Schema& CommandSuccess::_Internal::schema(const CommandSuccess* msg) {
  return *msg->_impl_.schema_;
}
CommandSuccess::CommandSuccess(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandSuccess)
}
inline PROTOBUF_NDEBUG_INLINE CommandSuccess::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

CommandSuccess::CommandSuccess(
    ::google::protobuf::Arena* arena,
    const CommandSuccess& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandSuccess* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.schema_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::pulsar::proto::Schema>(arena, *from._impl_.schema_)
                : nullptr;
  _impl_.request_id_ = from._impl_.request_id_;

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandSuccess)
}
inline PROTOBUF_NDEBUG_INLINE CommandSuccess::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CommandSuccess::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, schema_),
           0,
           offsetof(Impl_, request_id_) -
               offsetof(Impl_, schema_) +
               sizeof(Impl_::request_id_));
}
CommandSuccess::~CommandSuccess() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandSuccess)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandSuccess::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.schema_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandSuccess::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandSuccess)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.schema_ != nullptr);
    _impl_.schema_->Clear();
  }
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandSuccess::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2> CommandSuccess::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandSuccess, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandSuccess_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional .pulsar.proto.Schema schema = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(CommandSuccess, _impl_.schema_)}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandSuccess, _impl_.request_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandSuccess, _impl_.request_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.Schema schema = 2;
    {PROTOBUF_FIELD_OFFSET(CommandSuccess, _impl_.schema_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::Schema>()},
  }}, {{
  }},
};

::uint8_t* CommandSuccess::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandSuccess)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // optional .pulsar.proto.Schema schema = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::schema(this),
        _Internal::schema(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandSuccess)
  return target;
}

::size_t CommandSuccess::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandSuccess)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .pulsar.proto.Schema schema = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.schema_);
  }

  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandSuccess::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandSuccess*>(
      &from));
}

void CommandSuccess::MergeFrom(const CommandSuccess& from) {
  CommandSuccess* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandSuccess)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_schema()->::pulsar::proto::Schema::MergeFrom(
          from._internal_schema());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandSuccess::CopyFrom(const CommandSuccess& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandSuccess)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandSuccess::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.schema_->IsInitialized()) return false;
  }
  return true;
}

::_pbi::CachedSize* CommandSuccess::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandSuccess::InternalSwap(CommandSuccess* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSuccess, _impl_.request_id_)
      + sizeof(CommandSuccess::_impl_.request_id_)
      - PROTOBUF_FIELD_OFFSET(CommandSuccess, _impl_.schema_)>(
          reinterpret_cast<char*>(&_impl_.schema_),
          reinterpret_cast<char*>(&other->_impl_.schema_));
}

std::string CommandSuccess::GetTypeName() const {
  return "pulsar.proto.CommandSuccess";
}

// ===================================================================

class CommandProducerSuccess::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandProducerSuccess>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_producer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_last_sequence_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_schema_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_topic_epoch(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_producer_ready(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

CommandProducerSuccess::CommandProducerSuccess(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandProducerSuccess)
}
inline PROTOBUF_NDEBUG_INLINE CommandProducerSuccess::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        producer_name_(arena, from.producer_name_),
        schema_version_(arena, from.schema_version_) {}

CommandProducerSuccess::CommandProducerSuccess(
    ::google::protobuf::Arena* arena,
    const CommandProducerSuccess& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandProducerSuccess* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, last_sequence_id_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::last_sequence_id_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandProducerSuccess)
}
inline PROTOBUF_NDEBUG_INLINE CommandProducerSuccess::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        producer_name_(arena),
        schema_version_(arena),
        producer_ready_{true},
        last_sequence_id_{::int64_t{-1}} {}

inline void CommandProducerSuccess::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, topic_epoch_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::topic_epoch_));
}
CommandProducerSuccess::~CommandProducerSuccess() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandProducerSuccess)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandProducerSuccess::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.producer_name_.Destroy();
  _impl_.schema_version_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandProducerSuccess::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandProducerSuccess)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.producer_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.schema_version_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.topic_epoch_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.topic_epoch_));
    _impl_.producer_ready_ = true;
    _impl_.last_sequence_id_ = ::int64_t{-1};
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandProducerSuccess::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 0, 0, 2> CommandProducerSuccess::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandProducerSuccess_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, _impl_.request_id_)}},
    // required string producer_name = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, _impl_.producer_name_)}},
    // optional int64 last_sequence_id = 3 [default = -1];
    {::_pbi::TcParser::FastV64S1,
     {24, 5, 0, PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, _impl_.last_sequence_id_)}},
    // optional bytes schema_version = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, _impl_.schema_version_)}},
    // optional uint64 topic_epoch = 5;
    {::_pbi::TcParser::FastV64S1,
     {40, 3, 0, PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, _impl_.topic_epoch_)}},
    // optional bool producer_ready = 6 [default = true];
    {::_pbi::TcParser::FastV8S1,
     {48, 4, 0, PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, _impl_.producer_ready_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, _impl_.request_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required string producer_name = 2;
    {PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, _impl_.producer_name_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional int64 last_sequence_id = 3 [default = -1];
    {PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, _impl_.last_sequence_id_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional bytes schema_version = 4;
    {PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, _impl_.schema_version_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint64 topic_epoch = 5;
    {PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, _impl_.topic_epoch_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional bool producer_ready = 6 [default = true];
    {PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, _impl_.producer_ready_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandProducerSuccess::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandProducerSuccess)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // required string producer_name = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_producer_name();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional int64 last_sequence_id = 3 [default = -1];
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<3>(
            stream, this->_internal_last_sequence_id(), target);
  }

  // optional bytes schema_version = 4;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_schema_version();
    target = stream->WriteBytesMaybeAliased(4, _s, target);
  }

  // optional uint64 topic_epoch = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_topic_epoch(), target);
  }

  // optional bool producer_ready = 6 [default = true];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_producer_ready(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandProducerSuccess)
  return target;
}

::size_t CommandProducerSuccess::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandProducerSuccess)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // required string producer_name = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_producer_name());
  }

  // optional bytes schema_version = 4;
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                    this->_internal_schema_version());
  }

  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (cached_has_bits & 0x00000038u) {
    // optional uint64 topic_epoch = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_topic_epoch());
    }

    // optional bool producer_ready = 6 [default = true];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2;
    }

    // optional int64 last_sequence_id = 3 [default = -1];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_last_sequence_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandProducerSuccess::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandProducerSuccess*>(
      &from));
}

void CommandProducerSuccess::MergeFrom(const CommandProducerSuccess& from) {
  CommandProducerSuccess* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandProducerSuccess)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_producer_name(from._internal_producer_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_schema_version(from._internal_schema_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.topic_epoch_ = from._impl_.topic_epoch_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.producer_ready_ = from._impl_.producer_ready_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.last_sequence_id_ = from._impl_.last_sequence_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandProducerSuccess::CopyFrom(const CommandProducerSuccess& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandProducerSuccess)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandProducerSuccess::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandProducerSuccess::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandProducerSuccess::InternalSwap(CommandProducerSuccess* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.producer_name_, &other->_impl_.producer_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.schema_version_, &other->_impl_.schema_version_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, _impl_.last_sequence_id_)
      + sizeof(CommandProducerSuccess::_impl_.last_sequence_id_)
      - PROTOBUF_FIELD_OFFSET(CommandProducerSuccess, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandProducerSuccess::GetTypeName() const {
  return "pulsar.proto.CommandProducerSuccess";
}

// ===================================================================

class CommandError::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandError>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandError, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

CommandError::CommandError(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandError)
}
inline PROTOBUF_NDEBUG_INLINE CommandError::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_(arena, from.message_) {}

CommandError::CommandError(
    ::google::protobuf::Arena* arena,
    const CommandError& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandError* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandError)
}
inline PROTOBUF_NDEBUG_INLINE CommandError::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        message_(arena) {}

inline void CommandError::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));
}
CommandError::~CommandError() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandError)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandError::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.message_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandError::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandError)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.error_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.error_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandError::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> CommandError::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandError, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandError_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandError, _impl_.request_id_)}},
    // required .pulsar.proto.ServerError error = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 2, 25, PROTOBUF_FIELD_OFFSET(CommandError, _impl_.error_)}},
    // required string message = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(CommandError, _impl_.message_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandError, _impl_.request_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required .pulsar.proto.ServerError error = 2;
    {PROTOBUF_FIELD_OFFSET(CommandError, _impl_.error_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // required string message = 3;
    {PROTOBUF_FIELD_OFFSET(CommandError, _impl_.message_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {0, 26},
  }}, {{
  }},
};

::uint8_t* CommandError::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandError)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // required .pulsar.proto.ServerError error = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_error(), target);
  }

  // required string message = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_message();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandError)
  return target;
}

::size_t CommandError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandError)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // required string message = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_message());
    }

    // required uint64 request_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_request_id());
    }

    // required .pulsar.proto.ServerError error = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandError*>(
      &from));
}

void CommandError::MergeFrom(const CommandError& from) {
  CommandError* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandError)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandError::CopyFrom(const CommandError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandError::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandError::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandError::InternalSwap(CommandError* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandError, _impl_.error_)
      + sizeof(CommandError::_impl_.error_)
      - PROTOBUF_FIELD_OFFSET(CommandError, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandError::GetTypeName() const {
  return "pulsar.proto.CommandError";
}

// ===================================================================

class CommandPing::_Internal {
 public:
};

CommandPing::CommandPing(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandPing)
}
CommandPing::CommandPing(
    ::google::protobuf::Arena* arena, const CommandPing& from)
    : CommandPing(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CommandPing::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CommandPing::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
CommandPing::~CommandPing() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandPing)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandPing::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandPing::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandPing)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CommandPing::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 0, 0, 0, 2> CommandPing::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    0, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967295,  // skipmap
    offsetof(decltype(_table_), field_names),  // no field_entries
    0,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandPing_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }},
  // no field_entries, or aux_entries
  {{
  }},
};

::uint8_t* CommandPing::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandPing)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandPing)
  return target;
}

::size_t CommandPing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandPing)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandPing::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandPing*>(
      &from));
}

void CommandPing::MergeFrom(const CommandPing& from) {
  CommandPing* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandPing)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandPing::CopyFrom(const CommandPing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandPing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandPing::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* CommandPing::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandPing::InternalSwap(CommandPing* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CommandPing::GetTypeName() const {
  return "pulsar.proto.CommandPing";
}

// ===================================================================

class CommandPong::_Internal {
 public:
};

CommandPong::CommandPong(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandPong)
}
CommandPong::CommandPong(
    ::google::protobuf::Arena* arena, const CommandPong& from)
    : CommandPong(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CommandPong::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CommandPong::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
CommandPong::~CommandPong() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandPong)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandPong::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandPong::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandPong)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* CommandPong::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 0, 0, 0, 2> CommandPong::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    0, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967295,  // skipmap
    offsetof(decltype(_table_), field_names),  // no field_entries
    0,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandPong_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }},
  // no field_entries, or aux_entries
  {{
  }},
};

::uint8_t* CommandPong::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandPong)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandPong)
  return target;
}

::size_t CommandPong::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandPong)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandPong::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandPong*>(
      &from));
}

void CommandPong::MergeFrom(const CommandPong& from) {
  CommandPong* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandPong)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandPong::CopyFrom(const CommandPong& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandPong)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandPong::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* CommandPong::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandPong::InternalSwap(CommandPong* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CommandPong::GetTypeName() const {
  return "pulsar.proto.CommandPong";
}

// ===================================================================

class CommandConsumerStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandConsumerStats>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandConsumerStats, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CommandConsumerStats::CommandConsumerStats(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandConsumerStats)
}
CommandConsumerStats::CommandConsumerStats(
    ::google::protobuf::Arena* arena, const CommandConsumerStats& from)
    : CommandConsumerStats(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CommandConsumerStats::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CommandConsumerStats::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, consumer_id_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::consumer_id_));
}
CommandConsumerStats::~CommandConsumerStats() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandConsumerStats)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandConsumerStats::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandConsumerStats::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandConsumerStats)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.consumer_id_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.consumer_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandConsumerStats::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> CommandConsumerStats::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandConsumerStats, _impl_._has_bits_),
    0, // no _extensions_
    4, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967286,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandConsumerStats_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // required uint64 consumer_id = 4;
    {::_pbi::TcParser::FastV64S1,
     {32, 1, 0, PROTOBUF_FIELD_OFFSET(CommandConsumerStats, _impl_.consumer_id_)}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(CommandConsumerStats, _impl_.request_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStats, _impl_.request_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint64 consumer_id = 4;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStats, _impl_.consumer_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandConsumerStats::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandConsumerStats)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // required uint64 consumer_id = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_consumer_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandConsumerStats)
  return target;
}

::size_t CommandConsumerStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandConsumerStats)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required uint64 request_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_request_id());
    }

    // required uint64 consumer_id = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_consumer_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandConsumerStats::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandConsumerStats*>(
      &from));
}

void CommandConsumerStats::MergeFrom(const CommandConsumerStats& from) {
  CommandConsumerStats* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandConsumerStats)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.consumer_id_ = from._impl_.consumer_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandConsumerStats::CopyFrom(const CommandConsumerStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandConsumerStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandConsumerStats::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandConsumerStats::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandConsumerStats::InternalSwap(CommandConsumerStats* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandConsumerStats, _impl_.consumer_id_)
      + sizeof(CommandConsumerStats::_impl_.consumer_id_)
      - PROTOBUF_FIELD_OFFSET(CommandConsumerStats, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandConsumerStats::GetTypeName() const {
  return "pulsar.proto.CommandConsumerStats";
}

// ===================================================================

class CommandConsumerStatsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandConsumerStatsResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_msgrateout(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_msgthroughputout(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_msgrateredeliver(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_consumername(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_availablepermits(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_unackedmessages(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_blockedconsumeronunackedmsgs(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_connectedsince(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_msgrateexpired(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_msgbacklog(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_messageackrate(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000020) ^ 0x00000020) != 0;
  }
};

CommandConsumerStatsResponse::CommandConsumerStatsResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandConsumerStatsResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandConsumerStatsResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        error_message_(arena, from.error_message_),
        consumername_(arena, from.consumername_),
        address_(arena, from.address_),
        connectedsince_(arena, from.connectedsince_),
        type_(arena, from.type_) {}

CommandConsumerStatsResponse::CommandConsumerStatsResponse(
    ::google::protobuf::Arena* arena,
    const CommandConsumerStatsResponse& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandConsumerStatsResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, messageackrate_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::messageackrate_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandConsumerStatsResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandConsumerStatsResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        error_message_(arena),
        consumername_(arena),
        address_(arena),
        connectedsince_(arena),
        type_(arena) {}

inline void CommandConsumerStatsResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, messageackrate_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::messageackrate_));
}
CommandConsumerStatsResponse::~CommandConsumerStatsResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandConsumerStatsResponse)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandConsumerStatsResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.error_message_.Destroy();
  _impl_.consumername_.Destroy();
  _impl_.address_.Destroy();
  _impl_.connectedsince_.Destroy();
  _impl_.type_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandConsumerStatsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandConsumerStatsResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.error_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.consumername_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.connectedsince_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.type_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.msgthroughputout_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.msgthroughputout_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.msgrateredeliver_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.messageackrate_) -
        reinterpret_cast<char*>(&_impl_.msgrateredeliver_)) + sizeof(_impl_.messageackrate_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandConsumerStatsResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 16, 1, 0, 2> CommandConsumerStatsResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_._has_bits_),
    0, // no _extensions_
    16, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294901760,  // skipmap
    offsetof(decltype(_table_), field_entries),
    16,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandConsumerStatsResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional double messageAckRate = 16;
    {::_pbi::TcParser::FastF64S2,
     {385, 15, 0, PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.messageackrate_)}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 5, 0, PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.request_id_)}},
    // optional .pulsar.proto.ServerError error_code = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 9, 25, PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.error_code_)}},
    // optional string error_message = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.error_message_)}},
    // optional double msgRateOut = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 6, 0, PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.msgrateout_)}},
    // optional double msgThroughputOut = 5;
    {::_pbi::TcParser::FastF64S1,
     {41, 7, 0, PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.msgthroughputout_)}},
    // optional double msgRateRedeliver = 6;
    {::_pbi::TcParser::FastF64S1,
     {49, 8, 0, PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.msgrateredeliver_)}},
    // optional string consumerName = 7;
    {::_pbi::TcParser::FastBS1,
     {58, 1, 0, PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.consumername_)}},
    // optional uint64 availablePermits = 8;
    {::_pbi::TcParser::FastV64S1,
     {64, 11, 0, PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.availablepermits_)}},
    // optional uint64 unackedMessages = 9;
    {::_pbi::TcParser::FastV64S1,
     {72, 12, 0, PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.unackedmessages_)}},
    // optional bool blockedConsumerOnUnackedMsgs = 10;
    {::_pbi::TcParser::FastV8S1,
     {80, 10, 0, PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.blockedconsumeronunackedmsgs_)}},
    // optional string address = 11;
    {::_pbi::TcParser::FastBS1,
     {90, 2, 0, PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.address_)}},
    // optional string connectedSince = 12;
    {::_pbi::TcParser::FastBS1,
     {98, 3, 0, PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.connectedsince_)}},
    // optional string type = 13;
    {::_pbi::TcParser::FastBS1,
     {106, 4, 0, PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.type_)}},
    // optional double msgRateExpired = 14;
    {::_pbi::TcParser::FastF64S1,
     {113, 13, 0, PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.msgrateexpired_)}},
    // optional uint64 msgBacklog = 15;
    {::_pbi::TcParser::FastV64S1,
     {120, 14, 0, PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.msgbacklog_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.request_id_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.ServerError error_code = 2;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.error_code_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string error_message = 3;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.error_message_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional double msgRateOut = 4;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.msgrateout_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double msgThroughputOut = 5;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.msgthroughputout_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional double msgRateRedeliver = 6;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.msgrateredeliver_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional string consumerName = 7;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.consumername_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint64 availablePermits = 8;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.availablepermits_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 unackedMessages = 9;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.unackedmessages_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional bool blockedConsumerOnUnackedMsgs = 10;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.blockedconsumeronunackedmsgs_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional string address = 11;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.address_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string connectedSince = 12;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.connectedsince_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string type = 13;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.type_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional double msgRateExpired = 14;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.msgrateexpired_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // optional uint64 msgBacklog = 15;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.msgbacklog_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional double messageAckRate = 16;
    {PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.messageackrate_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
  }}, {{
    {0, 26},
  }}, {{
  }},
};

::uint8_t* CommandConsumerStatsResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandConsumerStatsResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // optional .pulsar.proto.ServerError error_code = 2;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_error_code(), target);
  }

  // optional string error_message = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_error_message();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional double msgRateOut = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_msgrateout(), target);
  }

  // optional double msgThroughputOut = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_msgthroughputout(), target);
  }

  // optional double msgRateRedeliver = 6;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        6, this->_internal_msgrateredeliver(), target);
  }

  // optional string consumerName = 7;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_consumername();
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // optional uint64 availablePermits = 8;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        8, this->_internal_availablepermits(), target);
  }

  // optional uint64 unackedMessages = 9;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        9, this->_internal_unackedmessages(), target);
  }

  // optional bool blockedConsumerOnUnackedMsgs = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        10, this->_internal_blockedconsumeronunackedmsgs(), target);
  }

  // optional string address = 11;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_address();
    target = stream->WriteStringMaybeAliased(11, _s, target);
  }

  // optional string connectedSince = 12;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_connectedsince();
    target = stream->WriteStringMaybeAliased(12, _s, target);
  }

  // optional string type = 13;
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_type();
    target = stream->WriteStringMaybeAliased(13, _s, target);
  }

  // optional double msgRateExpired = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        14, this->_internal_msgrateexpired(), target);
  }

  // optional uint64 msgBacklog = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        15, this->_internal_msgbacklog(), target);
  }

  // optional double messageAckRate = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        16, this->_internal_messageackrate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandConsumerStatsResponse)
  return target;
}

::size_t CommandConsumerStatsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandConsumerStatsResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string error_message = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_error_message());
    }

    // optional string consumerName = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_consumername());
    }

    // optional string address = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_address());
    }

    // optional string connectedSince = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_connectedsince());
    }

    // optional string type = 13;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_type());
    }

  }
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000020u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (cached_has_bits & 0x000000c0u) {
    // optional double msgRateOut = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 9;
    }

    // optional double msgThroughputOut = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 9;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double msgRateRedeliver = 6;
    if (cached_has_bits & 0x00000100u) {
      total_size += 9;
    }

    // optional .pulsar.proto.ServerError error_code = 2;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_error_code());
    }

    // optional bool blockedConsumerOnUnackedMsgs = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2;
    }

    // optional uint64 availablePermits = 8;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_availablepermits());
    }

    // optional uint64 unackedMessages = 9;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_unackedmessages());
    }

    // optional double msgRateExpired = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 9;
    }

    // optional uint64 msgBacklog = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_msgbacklog());
    }

    // optional double messageAckRate = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 10;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandConsumerStatsResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandConsumerStatsResponse*>(
      &from));
}

void CommandConsumerStatsResponse::MergeFrom(const CommandConsumerStatsResponse& from) {
  CommandConsumerStatsResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandConsumerStatsResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_consumername(from._internal_consumername());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_address(from._internal_address());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_connectedsince(from._internal_connectedsince());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.msgrateout_ = from._impl_.msgrateout_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.msgthroughputout_ = from._impl_.msgthroughputout_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.msgrateredeliver_ = from._impl_.msgrateredeliver_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.error_code_ = from._impl_.error_code_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.blockedconsumeronunackedmsgs_ = from._impl_.blockedconsumeronunackedmsgs_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.availablepermits_ = from._impl_.availablepermits_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.unackedmessages_ = from._impl_.unackedmessages_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.msgrateexpired_ = from._impl_.msgrateexpired_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.msgbacklog_ = from._impl_.msgbacklog_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.messageackrate_ = from._impl_.messageackrate_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandConsumerStatsResponse::CopyFrom(const CommandConsumerStatsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandConsumerStatsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandConsumerStatsResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandConsumerStatsResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandConsumerStatsResponse::InternalSwap(CommandConsumerStatsResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.error_message_, &other->_impl_.error_message_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.consumername_, &other->_impl_.consumername_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.address_, &other->_impl_.address_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.connectedsince_, &other->_impl_.connectedsince_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.type_, &other->_impl_.type_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.messageackrate_)
      + sizeof(CommandConsumerStatsResponse::_impl_.messageackrate_)
      - PROTOBUF_FIELD_OFFSET(CommandConsumerStatsResponse, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandConsumerStatsResponse::GetTypeName() const {
  return "pulsar.proto.CommandConsumerStatsResponse";
}

// ===================================================================

class CommandGetLastMessageId::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandGetLastMessageId>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandGetLastMessageId, _impl_._has_bits_);
  static void set_has_consumer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CommandGetLastMessageId::CommandGetLastMessageId(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandGetLastMessageId)
}
CommandGetLastMessageId::CommandGetLastMessageId(
    ::google::protobuf::Arena* arena, const CommandGetLastMessageId& from)
    : CommandGetLastMessageId(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CommandGetLastMessageId::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CommandGetLastMessageId::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, consumer_id_),
           0,
           offsetof(Impl_, request_id_) -
               offsetof(Impl_, consumer_id_) +
               sizeof(Impl_::request_id_));
}
CommandGetLastMessageId::~CommandGetLastMessageId() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandGetLastMessageId)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandGetLastMessageId::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandGetLastMessageId::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandGetLastMessageId)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.consumer_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.request_id_) -
        reinterpret_cast<char*>(&_impl_.consumer_id_)) + sizeof(_impl_.request_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandGetLastMessageId::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> CommandGetLastMessageId::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandGetLastMessageId, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandGetLastMessageId_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // required uint64 request_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CommandGetLastMessageId, _impl_.request_id_)}},
    // required uint64 consumer_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(CommandGetLastMessageId, _impl_.consumer_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 consumer_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandGetLastMessageId, _impl_.consumer_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint64 request_id = 2;
    {PROTOBUF_FIELD_OFFSET(CommandGetLastMessageId, _impl_.request_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandGetLastMessageId::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandGetLastMessageId)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 consumer_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_consumer_id(), target);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_request_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandGetLastMessageId)
  return target;
}

::size_t CommandGetLastMessageId::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandGetLastMessageId)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required uint64 consumer_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_consumer_id());
    }

    // required uint64 request_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_request_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandGetLastMessageId::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandGetLastMessageId*>(
      &from));
}

void CommandGetLastMessageId::MergeFrom(const CommandGetLastMessageId& from) {
  CommandGetLastMessageId* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandGetLastMessageId)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.consumer_id_ = from._impl_.consumer_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandGetLastMessageId::CopyFrom(const CommandGetLastMessageId& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandGetLastMessageId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandGetLastMessageId::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandGetLastMessageId::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandGetLastMessageId::InternalSwap(CommandGetLastMessageId* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandGetLastMessageId, _impl_.request_id_)
      + sizeof(CommandGetLastMessageId::_impl_.request_id_)
      - PROTOBUF_FIELD_OFFSET(CommandGetLastMessageId, _impl_.consumer_id_)>(
          reinterpret_cast<char*>(&_impl_.consumer_id_),
          reinterpret_cast<char*>(&other->_impl_.consumer_id_));
}

std::string CommandGetLastMessageId::GetTypeName() const {
  return "pulsar.proto.CommandGetLastMessageId";
}

// ===================================================================

class CommandGetLastMessageIdResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandGetLastMessageIdResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandGetLastMessageIdResponse, _impl_._has_bits_);
  static const ::pulsar::proto::MessageIdData& last_message_id(const CommandGetLastMessageIdResponse* msg);
  static void set_has_last_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::pulsar::proto::MessageIdData& consumer_mark_delete_position(const CommandGetLastMessageIdResponse* msg);
  static void set_has_consumer_mark_delete_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

const ::pulsar::proto::MessageIdData& CommandGetLastMessageIdResponse::_Internal::last_message_id(const CommandGetLastMessageIdResponse* msg) {
  return *msg->_impl_.last_message_id_;
}
const ::pulsar::proto::MessageIdData& CommandGetLastMessageIdResponse::_Internal::consumer_mark_delete_position(const CommandGetLastMessageIdResponse* msg) {
  return *msg->_impl_.consumer_mark_delete_position_;
}
CommandGetLastMessageIdResponse::CommandGetLastMessageIdResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandGetLastMessageIdResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandGetLastMessageIdResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

CommandGetLastMessageIdResponse::CommandGetLastMessageIdResponse(
    ::google::protobuf::Arena* arena,
    const CommandGetLastMessageIdResponse& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandGetLastMessageIdResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.last_message_id_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::pulsar::proto::MessageIdData>(arena, *from._impl_.last_message_id_)
                : nullptr;
  _impl_.consumer_mark_delete_position_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::pulsar::proto::MessageIdData>(arena, *from._impl_.consumer_mark_delete_position_)
                : nullptr;
  _impl_.request_id_ = from._impl_.request_id_;

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandGetLastMessageIdResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandGetLastMessageIdResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CommandGetLastMessageIdResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, last_message_id_),
           0,
           offsetof(Impl_, request_id_) -
               offsetof(Impl_, last_message_id_) +
               sizeof(Impl_::request_id_));
}
CommandGetLastMessageIdResponse::~CommandGetLastMessageIdResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandGetLastMessageIdResponse)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandGetLastMessageIdResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.last_message_id_;
  delete _impl_.consumer_mark_delete_position_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandGetLastMessageIdResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandGetLastMessageIdResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.last_message_id_ != nullptr);
      _impl_.last_message_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.consumer_mark_delete_position_ != nullptr);
      _impl_.consumer_mark_delete_position_->Clear();
    }
  }
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandGetLastMessageIdResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 2, 0, 2> CommandGetLastMessageIdResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandGetLastMessageIdResponse, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandGetLastMessageIdResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required .pulsar.proto.MessageIdData last_message_id = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CommandGetLastMessageIdResponse, _impl_.last_message_id_)}},
    // required uint64 request_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(CommandGetLastMessageIdResponse, _impl_.request_id_)}},
    // optional .pulsar.proto.MessageIdData consumer_mark_delete_position = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1, PROTOBUF_FIELD_OFFSET(CommandGetLastMessageIdResponse, _impl_.consumer_mark_delete_position_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required .pulsar.proto.MessageIdData last_message_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandGetLastMessageIdResponse, _impl_.last_message_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // required uint64 request_id = 2;
    {PROTOBUF_FIELD_OFFSET(CommandGetLastMessageIdResponse, _impl_.request_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.MessageIdData consumer_mark_delete_position = 3;
    {PROTOBUF_FIELD_OFFSET(CommandGetLastMessageIdResponse, _impl_.consumer_mark_delete_position_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::MessageIdData>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::MessageIdData>()},
  }}, {{
  }},
};

::uint8_t* CommandGetLastMessageIdResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandGetLastMessageIdResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .pulsar.proto.MessageIdData last_message_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::last_message_id(this),
        _Internal::last_message_id(this).GetCachedSize(), target, stream);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_request_id(), target);
  }

  // optional .pulsar.proto.MessageIdData consumer_mark_delete_position = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::consumer_mark_delete_position(this),
        _Internal::consumer_mark_delete_position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandGetLastMessageIdResponse)
  return target;
}

::size_t CommandGetLastMessageIdResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandGetLastMessageIdResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // required .pulsar.proto.MessageIdData last_message_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.last_message_id_);
  }

  // optional .pulsar.proto.MessageIdData consumer_mark_delete_position = 3;
  if (cached_has_bits & 0x00000002u) {
    total_size +=
        1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.consumer_mark_delete_position_);
  }

  // required uint64 request_id = 2;
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandGetLastMessageIdResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandGetLastMessageIdResponse*>(
      &from));
}

void CommandGetLastMessageIdResponse::MergeFrom(const CommandGetLastMessageIdResponse& from) {
  CommandGetLastMessageIdResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandGetLastMessageIdResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_last_message_id()->::pulsar::proto::MessageIdData::MergeFrom(
          from._internal_last_message_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_consumer_mark_delete_position()->::pulsar::proto::MessageIdData::MergeFrom(
          from._internal_consumer_mark_delete_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandGetLastMessageIdResponse::CopyFrom(const CommandGetLastMessageIdResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandGetLastMessageIdResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandGetLastMessageIdResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.last_message_id_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!_impl_.consumer_mark_delete_position_->IsInitialized()) return false;
  }
  return true;
}

::_pbi::CachedSize* CommandGetLastMessageIdResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandGetLastMessageIdResponse::InternalSwap(CommandGetLastMessageIdResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandGetLastMessageIdResponse, _impl_.request_id_)
      + sizeof(CommandGetLastMessageIdResponse::_impl_.request_id_)
      - PROTOBUF_FIELD_OFFSET(CommandGetLastMessageIdResponse, _impl_.last_message_id_)>(
          reinterpret_cast<char*>(&_impl_.last_message_id_),
          reinterpret_cast<char*>(&other->_impl_.last_message_id_));
}

std::string CommandGetLastMessageIdResponse::GetTypeName() const {
  return "pulsar.proto.CommandGetLastMessageIdResponse";
}

// ===================================================================

class CommandGetTopicsOfNamespace::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandGetTopicsOfNamespace>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespace, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_namespace_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_topics_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_topics_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000009) ^ 0x00000009) != 0;
  }
};

CommandGetTopicsOfNamespace::CommandGetTopicsOfNamespace(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandGetTopicsOfNamespace)
}
inline PROTOBUF_NDEBUG_INLINE CommandGetTopicsOfNamespace::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        namespace__(arena, from.namespace__),
        topics_pattern_(arena, from.topics_pattern_),
        topics_hash_(arena, from.topics_hash_) {}

CommandGetTopicsOfNamespace::CommandGetTopicsOfNamespace(
    ::google::protobuf::Arena* arena,
    const CommandGetTopicsOfNamespace& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandGetTopicsOfNamespace* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, mode_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::mode_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandGetTopicsOfNamespace)
}
inline PROTOBUF_NDEBUG_INLINE CommandGetTopicsOfNamespace::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        namespace__(arena),
        topics_pattern_(arena),
        topics_hash_(arena) {}

inline void CommandGetTopicsOfNamespace::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, mode_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::mode_));
}
CommandGetTopicsOfNamespace::~CommandGetTopicsOfNamespace() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandGetTopicsOfNamespace)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandGetTopicsOfNamespace::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.namespace__.Destroy();
  _impl_.topics_pattern_.Destroy();
  _impl_.topics_hash_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandGetTopicsOfNamespace::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandGetTopicsOfNamespace)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.namespace__.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.topics_pattern_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.topics_hash_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.mode_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.mode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandGetTopicsOfNamespace::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 1, 0, 2> CommandGetTopicsOfNamespace::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespace, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandGetTopicsOfNamespace_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 3, 0, PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespace, _impl_.request_id_)}},
    // required string namespace = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespace, _impl_.namespace__)}},
    // optional .pulsar.proto.CommandGetTopicsOfNamespace.Mode mode = 3 [default = PERSISTENT];
    {::_pbi::TcParser::FastEr0S1,
     {24, 4, 2, PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespace, _impl_.mode_)}},
    // optional string topics_pattern = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespace, _impl_.topics_pattern_)}},
    // optional string topics_hash = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 2, 0, PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespace, _impl_.topics_hash_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespace, _impl_.request_id_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required string namespace = 2;
    {PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespace, _impl_.namespace__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .pulsar.proto.CommandGetTopicsOfNamespace.Mode mode = 3 [default = PERSISTENT];
    {PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespace, _impl_.mode_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string topics_pattern = 4;
    {PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespace, _impl_.topics_pattern_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string topics_hash = 5;
    {PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespace, _impl_.topics_hash_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {0, 3},
  }}, {{
  }},
};

::uint8_t* CommandGetTopicsOfNamespace::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandGetTopicsOfNamespace)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // required string namespace = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_namespace_();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional .pulsar.proto.CommandGetTopicsOfNamespace.Mode mode = 3 [default = PERSISTENT];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_mode(), target);
  }

  // optional string topics_pattern = 4;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_topics_pattern();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional string topics_hash = 5;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_topics_hash();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandGetTopicsOfNamespace)
  return target;
}

::size_t CommandGetTopicsOfNamespace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandGetTopicsOfNamespace)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // required string namespace = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_namespace_());
  }

  if (cached_has_bits & 0x00000006u) {
    // optional string topics_pattern = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_topics_pattern());
    }

    // optional string topics_hash = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_topics_hash());
    }

  }
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000008u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  // optional .pulsar.proto.CommandGetTopicsOfNamespace.Mode mode = 3 [default = PERSISTENT];
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandGetTopicsOfNamespace::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandGetTopicsOfNamespace*>(
      &from));
}

void CommandGetTopicsOfNamespace::MergeFrom(const CommandGetTopicsOfNamespace& from) {
  CommandGetTopicsOfNamespace* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandGetTopicsOfNamespace)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_namespace_(from._internal_namespace_());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_topics_pattern(from._internal_topics_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_topics_hash(from._internal_topics_hash());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandGetTopicsOfNamespace::CopyFrom(const CommandGetTopicsOfNamespace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandGetTopicsOfNamespace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandGetTopicsOfNamespace::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandGetTopicsOfNamespace::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandGetTopicsOfNamespace::InternalSwap(CommandGetTopicsOfNamespace* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.namespace__, &other->_impl_.namespace__, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.topics_pattern_, &other->_impl_.topics_pattern_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.topics_hash_, &other->_impl_.topics_hash_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespace, _impl_.mode_)
      + sizeof(CommandGetTopicsOfNamespace::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespace, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandGetTopicsOfNamespace::GetTypeName() const {
  return "pulsar.proto.CommandGetTopicsOfNamespace";
}

// ===================================================================

class CommandGetTopicsOfNamespaceResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandGetTopicsOfNamespaceResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespaceResponse, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_filtered(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_topics_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_changed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandGetTopicsOfNamespaceResponse::CommandGetTopicsOfNamespaceResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandGetTopicsOfNamespaceResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        topics_{visibility, arena, from.topics_},
        topics_hash_(arena, from.topics_hash_) {}

CommandGetTopicsOfNamespaceResponse::CommandGetTopicsOfNamespaceResponse(
    ::google::protobuf::Arena* arena,
    const CommandGetTopicsOfNamespaceResponse& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandGetTopicsOfNamespaceResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, changed_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::changed_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandGetTopicsOfNamespaceResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        topics_{visibility, arena},
        topics_hash_(arena),
        changed_{true} {}

inline void CommandGetTopicsOfNamespaceResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, filtered_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::filtered_));
}
CommandGetTopicsOfNamespaceResponse::~CommandGetTopicsOfNamespaceResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandGetTopicsOfNamespaceResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.topics_hash_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandGetTopicsOfNamespaceResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.topics_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.topics_hash_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.filtered_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.filtered_));
    _impl_.changed_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandGetTopicsOfNamespaceResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2> CommandGetTopicsOfNamespaceResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespaceResponse, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandGetTopicsOfNamespaceResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespaceResponse, _impl_.request_id_)}},
    // repeated string topics = 2;
    {::_pbi::TcParser::FastBR1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespaceResponse, _impl_.topics_)}},
    // optional bool filtered = 3 [default = false];
    {::_pbi::TcParser::FastV8S1,
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespaceResponse, _impl_.filtered_)}},
    // optional string topics_hash = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespaceResponse, _impl_.topics_hash_)}},
    // optional bool changed = 5 [default = true];
    {::_pbi::TcParser::FastV8S1,
     {40, 3, 0, PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespaceResponse, _impl_.changed_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespaceResponse, _impl_.request_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // repeated string topics = 2;
    {PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespaceResponse, _impl_.topics_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
    // optional bool filtered = 3 [default = false];
    {PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespaceResponse, _impl_.filtered_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional string topics_hash = 4;
    {PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespaceResponse, _impl_.topics_hash_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bool changed = 5 [default = true];
    {PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespaceResponse, _impl_.changed_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandGetTopicsOfNamespaceResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // repeated string topics = 2;
  for (int i = 0, n = this->_internal_topics_size(); i < n; ++i) {
    const auto& s = this->_internal_topics().Get(i);
    target = stream->WriteString(2, s, target);
  }

  // optional bool filtered = 3 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_filtered(), target);
  }

  // optional string topics_hash = 4;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_topics_hash();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional bool changed = 5 [default = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_changed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
  return target;
}

::size_t CommandGetTopicsOfNamespaceResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string topics = 2;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_topics().size());
  for (int i = 0, n = _internal_topics().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_topics().Get(i));
  }
  // optional string topics_hash = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_topics_hash());
  }

  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (cached_has_bits & 0x0000000cu) {
    // optional bool filtered = 3 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2;
    }

    // optional bool changed = 5 [default = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandGetTopicsOfNamespaceResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandGetTopicsOfNamespaceResponse*>(
      &from));
}

void CommandGetTopicsOfNamespaceResponse::MergeFrom(const CommandGetTopicsOfNamespaceResponse& from) {
  CommandGetTopicsOfNamespaceResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_topics()->MergeFrom(from._internal_topics());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_topics_hash(from._internal_topics_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.filtered_ = from._impl_.filtered_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.changed_ = from._impl_.changed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandGetTopicsOfNamespaceResponse::CopyFrom(const CommandGetTopicsOfNamespaceResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandGetTopicsOfNamespaceResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandGetTopicsOfNamespaceResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandGetTopicsOfNamespaceResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandGetTopicsOfNamespaceResponse::InternalSwap(CommandGetTopicsOfNamespaceResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.topics_.InternalSwap(&other->_impl_.topics_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.topics_hash_, &other->_impl_.topics_hash_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespaceResponse, _impl_.changed_)
      + sizeof(CommandGetTopicsOfNamespaceResponse::_impl_.changed_)
      - PROTOBUF_FIELD_OFFSET(CommandGetTopicsOfNamespaceResponse, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandGetTopicsOfNamespaceResponse::GetTypeName() const {
  return "pulsar.proto.CommandGetTopicsOfNamespaceResponse";
}

// ===================================================================

class CommandWatchTopicList::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandWatchTopicList>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandWatchTopicList, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_watcher_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_namespace_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_topics_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_topics_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001b) ^ 0x0000001b) != 0;
  }
};

CommandWatchTopicList::CommandWatchTopicList(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandWatchTopicList)
}
inline PROTOBUF_NDEBUG_INLINE CommandWatchTopicList::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        namespace__(arena, from.namespace__),
        topics_pattern_(arena, from.topics_pattern_),
        topics_hash_(arena, from.topics_hash_) {}

CommandWatchTopicList::CommandWatchTopicList(
    ::google::protobuf::Arena* arena,
    const CommandWatchTopicList& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandWatchTopicList* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, watcher_id_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::watcher_id_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandWatchTopicList)
}
inline PROTOBUF_NDEBUG_INLINE CommandWatchTopicList::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        namespace__(arena),
        topics_pattern_(arena),
        topics_hash_(arena) {}

inline void CommandWatchTopicList::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, watcher_id_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::watcher_id_));
}
CommandWatchTopicList::~CommandWatchTopicList() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandWatchTopicList)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandWatchTopicList::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.namespace__.Destroy();
  _impl_.topics_pattern_.Destroy();
  _impl_.topics_hash_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandWatchTopicList::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandWatchTopicList)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.namespace__.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.topics_pattern_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.topics_hash_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.watcher_id_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.watcher_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandWatchTopicList::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2> CommandWatchTopicList::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandWatchTopicList, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandWatchTopicList_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 3, 0, PROTOBUF_FIELD_OFFSET(CommandWatchTopicList, _impl_.request_id_)}},
    // required uint64 watcher_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 4, 0, PROTOBUF_FIELD_OFFSET(CommandWatchTopicList, _impl_.watcher_id_)}},
    // required string namespace = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(CommandWatchTopicList, _impl_.namespace__)}},
    // required string topics_pattern = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(CommandWatchTopicList, _impl_.topics_pattern_)}},
    // optional string topics_hash = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 2, 0, PROTOBUF_FIELD_OFFSET(CommandWatchTopicList, _impl_.topics_hash_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandWatchTopicList, _impl_.request_id_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint64 watcher_id = 2;
    {PROTOBUF_FIELD_OFFSET(CommandWatchTopicList, _impl_.watcher_id_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required string namespace = 3;
    {PROTOBUF_FIELD_OFFSET(CommandWatchTopicList, _impl_.namespace__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // required string topics_pattern = 4;
    {PROTOBUF_FIELD_OFFSET(CommandWatchTopicList, _impl_.topics_pattern_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string topics_hash = 5;
    {PROTOBUF_FIELD_OFFSET(CommandWatchTopicList, _impl_.topics_hash_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandWatchTopicList::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandWatchTopicList)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // required uint64 watcher_id = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_watcher_id(), target);
  }

  // required string namespace = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_namespace_();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // required string topics_pattern = 4;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_topics_pattern();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional string topics_hash = 5;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_topics_hash();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandWatchTopicList)
  return target;
}

::size_t CommandWatchTopicList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandWatchTopicList)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required string namespace = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_namespace_());
    }

    // required string topics_pattern = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_topics_pattern());
    }

  }
  // optional string topics_hash = 5;
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_topics_hash());
  }

  if (cached_has_bits & 0x00000018u) {
    // required uint64 request_id = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_request_id());
    }

    // required uint64 watcher_id = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_watcher_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandWatchTopicList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandWatchTopicList*>(
      &from));
}

void CommandWatchTopicList::MergeFrom(const CommandWatchTopicList& from) {
  CommandWatchTopicList* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandWatchTopicList)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_namespace_(from._internal_namespace_());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_topics_pattern(from._internal_topics_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_topics_hash(from._internal_topics_hash());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.watcher_id_ = from._impl_.watcher_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandWatchTopicList::CopyFrom(const CommandWatchTopicList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandWatchTopicList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandWatchTopicList::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandWatchTopicList::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandWatchTopicList::InternalSwap(CommandWatchTopicList* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.namespace__, &other->_impl_.namespace__, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.topics_pattern_, &other->_impl_.topics_pattern_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.topics_hash_, &other->_impl_.topics_hash_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandWatchTopicList, _impl_.watcher_id_)
      + sizeof(CommandWatchTopicList::_impl_.watcher_id_)
      - PROTOBUF_FIELD_OFFSET(CommandWatchTopicList, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandWatchTopicList::GetTypeName() const {
  return "pulsar.proto.CommandWatchTopicList";
}

// ===================================================================

class CommandWatchTopicListSuccess::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandWatchTopicListSuccess>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandWatchTopicListSuccess, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_watcher_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_topics_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

CommandWatchTopicListSuccess::CommandWatchTopicListSuccess(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandWatchTopicListSuccess)
}
inline PROTOBUF_NDEBUG_INLINE CommandWatchTopicListSuccess::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        topic_{visibility, arena, from.topic_},
        topics_hash_(arena, from.topics_hash_) {}

CommandWatchTopicListSuccess::CommandWatchTopicListSuccess(
    ::google::protobuf::Arena* arena,
    const CommandWatchTopicListSuccess& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandWatchTopicListSuccess* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, watcher_id_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::watcher_id_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandWatchTopicListSuccess)
}
inline PROTOBUF_NDEBUG_INLINE CommandWatchTopicListSuccess::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        topic_{visibility, arena},
        topics_hash_(arena) {}

inline void CommandWatchTopicListSuccess::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, watcher_id_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::watcher_id_));
}
CommandWatchTopicListSuccess::~CommandWatchTopicListSuccess() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandWatchTopicListSuccess)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandWatchTopicListSuccess::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.topics_hash_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandWatchTopicListSuccess::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandWatchTopicListSuccess)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.topic_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.topics_hash_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.watcher_id_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.watcher_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandWatchTopicListSuccess::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> CommandWatchTopicListSuccess::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandWatchTopicListSuccess, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandWatchTopicListSuccess_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // required string topics_hash = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(CommandWatchTopicListSuccess, _impl_.topics_hash_)}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandWatchTopicListSuccess, _impl_.request_id_)}},
    // required uint64 watcher_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(CommandWatchTopicListSuccess, _impl_.watcher_id_)}},
    // repeated string topic = 3;
    {::_pbi::TcParser::FastBR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(CommandWatchTopicListSuccess, _impl_.topic_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandWatchTopicListSuccess, _impl_.request_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint64 watcher_id = 2;
    {PROTOBUF_FIELD_OFFSET(CommandWatchTopicListSuccess, _impl_.watcher_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // repeated string topic = 3;
    {PROTOBUF_FIELD_OFFSET(CommandWatchTopicListSuccess, _impl_.topic_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
    // required string topics_hash = 4;
    {PROTOBUF_FIELD_OFFSET(CommandWatchTopicListSuccess, _impl_.topics_hash_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandWatchTopicListSuccess::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandWatchTopicListSuccess)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // required uint64 watcher_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_watcher_id(), target);
  }

  // repeated string topic = 3;
  for (int i = 0, n = this->_internal_topic_size(); i < n; ++i) {
    const auto& s = this->_internal_topic().Get(i);
    target = stream->WriteString(3, s, target);
  }

  // required string topics_hash = 4;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_topics_hash();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandWatchTopicListSuccess)
  return target;
}

::size_t CommandWatchTopicListSuccess::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandWatchTopicListSuccess)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string topic = 3;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_topic().size());
  for (int i = 0, n = _internal_topic().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_topic().Get(i));
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // required string topics_hash = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_topics_hash());
    }

    // required uint64 request_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_request_id());
    }

    // required uint64 watcher_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_watcher_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandWatchTopicListSuccess::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandWatchTopicListSuccess*>(
      &from));
}

void CommandWatchTopicListSuccess::MergeFrom(const CommandWatchTopicListSuccess& from) {
  CommandWatchTopicListSuccess* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandWatchTopicListSuccess)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_topic()->MergeFrom(from._internal_topic());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_topics_hash(from._internal_topics_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.watcher_id_ = from._impl_.watcher_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandWatchTopicListSuccess::CopyFrom(const CommandWatchTopicListSuccess& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandWatchTopicListSuccess)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandWatchTopicListSuccess::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandWatchTopicListSuccess::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandWatchTopicListSuccess::InternalSwap(CommandWatchTopicListSuccess* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.topic_.InternalSwap(&other->_impl_.topic_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.topics_hash_, &other->_impl_.topics_hash_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandWatchTopicListSuccess, _impl_.watcher_id_)
      + sizeof(CommandWatchTopicListSuccess::_impl_.watcher_id_)
      - PROTOBUF_FIELD_OFFSET(CommandWatchTopicListSuccess, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandWatchTopicListSuccess::GetTypeName() const {
  return "pulsar.proto.CommandWatchTopicListSuccess";
}

// ===================================================================

class CommandWatchTopicUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandWatchTopicUpdate>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandWatchTopicUpdate, _impl_._has_bits_);
  static void set_has_watcher_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_topics_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CommandWatchTopicUpdate::CommandWatchTopicUpdate(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandWatchTopicUpdate)
}
inline PROTOBUF_NDEBUG_INLINE CommandWatchTopicUpdate::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        new_topics_{visibility, arena, from.new_topics_},
        deleted_topics_{visibility, arena, from.deleted_topics_},
        topics_hash_(arena, from.topics_hash_) {}

CommandWatchTopicUpdate::CommandWatchTopicUpdate(
    ::google::protobuf::Arena* arena,
    const CommandWatchTopicUpdate& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandWatchTopicUpdate* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  _impl_.watcher_id_ = from._impl_.watcher_id_;

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandWatchTopicUpdate)
}
inline PROTOBUF_NDEBUG_INLINE CommandWatchTopicUpdate::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        new_topics_{visibility, arena},
        deleted_topics_{visibility, arena},
        topics_hash_(arena) {}

inline void CommandWatchTopicUpdate::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.watcher_id_ = {};
}
CommandWatchTopicUpdate::~CommandWatchTopicUpdate() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandWatchTopicUpdate)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandWatchTopicUpdate::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.topics_hash_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandWatchTopicUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandWatchTopicUpdate)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.new_topics_.Clear();
  _impl_.deleted_topics_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.topics_hash_.ClearNonDefaultToEmpty();
  }
  _impl_.watcher_id_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandWatchTopicUpdate::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> CommandWatchTopicUpdate::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandWatchTopicUpdate, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandWatchTopicUpdate_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // required string topics_hash = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(CommandWatchTopicUpdate, _impl_.topics_hash_)}},
    // required uint64 watcher_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandWatchTopicUpdate, _impl_.watcher_id_)}},
    // repeated string new_topics = 2;
    {::_pbi::TcParser::FastBR1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(CommandWatchTopicUpdate, _impl_.new_topics_)}},
    // repeated string deleted_topics = 3;
    {::_pbi::TcParser::FastBR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(CommandWatchTopicUpdate, _impl_.deleted_topics_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 watcher_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandWatchTopicUpdate, _impl_.watcher_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // repeated string new_topics = 2;
    {PROTOBUF_FIELD_OFFSET(CommandWatchTopicUpdate, _impl_.new_topics_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
    // repeated string deleted_topics = 3;
    {PROTOBUF_FIELD_OFFSET(CommandWatchTopicUpdate, _impl_.deleted_topics_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
    // required string topics_hash = 4;
    {PROTOBUF_FIELD_OFFSET(CommandWatchTopicUpdate, _impl_.topics_hash_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandWatchTopicUpdate::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandWatchTopicUpdate)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 watcher_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_watcher_id(), target);
  }

  // repeated string new_topics = 2;
  for (int i = 0, n = this->_internal_new_topics_size(); i < n; ++i) {
    const auto& s = this->_internal_new_topics().Get(i);
    target = stream->WriteString(2, s, target);
  }

  // repeated string deleted_topics = 3;
  for (int i = 0, n = this->_internal_deleted_topics_size(); i < n; ++i) {
    const auto& s = this->_internal_deleted_topics().Get(i);
    target = stream->WriteString(3, s, target);
  }

  // required string topics_hash = 4;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_topics_hash();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandWatchTopicUpdate)
  return target;
}

::size_t CommandWatchTopicUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandWatchTopicUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string new_topics = 2;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_new_topics().size());
  for (int i = 0, n = _internal_new_topics().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_new_topics().Get(i));
  }
  // repeated string deleted_topics = 3;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_deleted_topics().size());
  for (int i = 0, n = _internal_deleted_topics().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_deleted_topics().Get(i));
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required string topics_hash = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_topics_hash());
    }

    // required uint64 watcher_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_watcher_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandWatchTopicUpdate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandWatchTopicUpdate*>(
      &from));
}

void CommandWatchTopicUpdate::MergeFrom(const CommandWatchTopicUpdate& from) {
  CommandWatchTopicUpdate* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandWatchTopicUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_new_topics()->MergeFrom(from._internal_new_topics());
  _this->_internal_mutable_deleted_topics()->MergeFrom(from._internal_deleted_topics());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_topics_hash(from._internal_topics_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.watcher_id_ = from._impl_.watcher_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandWatchTopicUpdate::CopyFrom(const CommandWatchTopicUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandWatchTopicUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandWatchTopicUpdate::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandWatchTopicUpdate::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandWatchTopicUpdate::InternalSwap(CommandWatchTopicUpdate* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.new_topics_.InternalSwap(&other->_impl_.new_topics_);
  _impl_.deleted_topics_.InternalSwap(&other->_impl_.deleted_topics_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.topics_hash_, &other->_impl_.topics_hash_, arena);
        swap(_impl_.watcher_id_, other->_impl_.watcher_id_);
}

std::string CommandWatchTopicUpdate::GetTypeName() const {
  return "pulsar.proto.CommandWatchTopicUpdate";
}

// ===================================================================

class CommandWatchTopicListClose::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandWatchTopicListClose>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandWatchTopicListClose, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_watcher_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CommandWatchTopicListClose::CommandWatchTopicListClose(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandWatchTopicListClose)
}
CommandWatchTopicListClose::CommandWatchTopicListClose(
    ::google::protobuf::Arena* arena, const CommandWatchTopicListClose& from)
    : CommandWatchTopicListClose(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CommandWatchTopicListClose::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CommandWatchTopicListClose::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, watcher_id_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::watcher_id_));
}
CommandWatchTopicListClose::~CommandWatchTopicListClose() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandWatchTopicListClose)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandWatchTopicListClose::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandWatchTopicListClose::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandWatchTopicListClose)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.watcher_id_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.watcher_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandWatchTopicListClose::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> CommandWatchTopicListClose::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandWatchTopicListClose, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandWatchTopicListClose_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // required uint64 watcher_id = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CommandWatchTopicListClose, _impl_.watcher_id_)}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(CommandWatchTopicListClose, _impl_.request_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandWatchTopicListClose, _impl_.request_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint64 watcher_id = 2;
    {PROTOBUF_FIELD_OFFSET(CommandWatchTopicListClose, _impl_.watcher_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandWatchTopicListClose::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandWatchTopicListClose)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // required uint64 watcher_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_watcher_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandWatchTopicListClose)
  return target;
}

::size_t CommandWatchTopicListClose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandWatchTopicListClose)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required uint64 request_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_request_id());
    }

    // required uint64 watcher_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_watcher_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandWatchTopicListClose::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandWatchTopicListClose*>(
      &from));
}

void CommandWatchTopicListClose::MergeFrom(const CommandWatchTopicListClose& from) {
  CommandWatchTopicListClose* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandWatchTopicListClose)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.watcher_id_ = from._impl_.watcher_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandWatchTopicListClose::CopyFrom(const CommandWatchTopicListClose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandWatchTopicListClose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandWatchTopicListClose::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandWatchTopicListClose::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandWatchTopicListClose::InternalSwap(CommandWatchTopicListClose* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandWatchTopicListClose, _impl_.watcher_id_)
      + sizeof(CommandWatchTopicListClose::_impl_.watcher_id_)
      - PROTOBUF_FIELD_OFFSET(CommandWatchTopicListClose, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandWatchTopicListClose::GetTypeName() const {
  return "pulsar.proto.CommandWatchTopicListClose";
}

// ===================================================================

class CommandGetSchema::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandGetSchema>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandGetSchema, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_schema_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

CommandGetSchema::CommandGetSchema(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandGetSchema)
}
inline PROTOBUF_NDEBUG_INLINE CommandGetSchema::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        topic_(arena, from.topic_),
        schema_version_(arena, from.schema_version_) {}

CommandGetSchema::CommandGetSchema(
    ::google::protobuf::Arena* arena,
    const CommandGetSchema& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandGetSchema* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  _impl_.request_id_ = from._impl_.request_id_;

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandGetSchema)
}
inline PROTOBUF_NDEBUG_INLINE CommandGetSchema::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        topic_(arena),
        schema_version_(arena) {}

inline void CommandGetSchema::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.request_id_ = {};
}
CommandGetSchema::~CommandGetSchema() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandGetSchema)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandGetSchema::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.topic_.Destroy();
  _impl_.schema_version_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandGetSchema::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandGetSchema)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.schema_version_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandGetSchema::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> CommandGetSchema::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandGetSchema, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandGetSchema_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(CommandGetSchema, _impl_.request_id_)}},
    // required string topic = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(CommandGetSchema, _impl_.topic_)}},
    // optional bytes schema_version = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 1, 0, PROTOBUF_FIELD_OFFSET(CommandGetSchema, _impl_.schema_version_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandGetSchema, _impl_.request_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required string topic = 2;
    {PROTOBUF_FIELD_OFFSET(CommandGetSchema, _impl_.topic_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes schema_version = 3;
    {PROTOBUF_FIELD_OFFSET(CommandGetSchema, _impl_.schema_version_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandGetSchema::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandGetSchema)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // required string topic = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_topic();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional bytes schema_version = 3;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_schema_version();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandGetSchema)
  return target;
}

::size_t CommandGetSchema::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandGetSchema)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // required string topic = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_topic());
  }

  // optional bytes schema_version = 3;
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                    this->_internal_schema_version());
  }

  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandGetSchema::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandGetSchema*>(
      &from));
}

void CommandGetSchema::MergeFrom(const CommandGetSchema& from) {
  CommandGetSchema* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandGetSchema)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_topic(from._internal_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_schema_version(from._internal_schema_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandGetSchema::CopyFrom(const CommandGetSchema& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandGetSchema)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandGetSchema::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandGetSchema::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandGetSchema::InternalSwap(CommandGetSchema* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.topic_, &other->_impl_.topic_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.schema_version_, &other->_impl_.schema_version_, arena);
        swap(_impl_.request_id_, other->_impl_.request_id_);
}

std::string CommandGetSchema::GetTypeName() const {
  return "pulsar.proto.CommandGetSchema";
}

// ===================================================================

class CommandGetSchemaResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandGetSchemaResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandGetSchemaResponse, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pulsar::proto::Schema& schema(const CommandGetSchemaResponse* msg);
  static void set_has_schema(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_schema_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

const ::pulsar::proto::Schema& CommandGetSchemaResponse::_Internal::schema(const CommandGetSchemaResponse* msg) {
  return *msg->_impl_.schema_;
}
CommandGetSchemaResponse::CommandGetSchemaResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandGetSchemaResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandGetSchemaResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        error_message_(arena, from.error_message_),
        schema_version_(arena, from.schema_version_) {}

CommandGetSchemaResponse::CommandGetSchemaResponse(
    ::google::protobuf::Arena* arena,
    const CommandGetSchemaResponse& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandGetSchemaResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.schema_ = (cached_has_bits & 0x00000004u)
                ? CreateMaybeMessage<::pulsar::proto::Schema>(arena, *from._impl_.schema_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, error_code_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_code_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandGetSchemaResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandGetSchemaResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        error_message_(arena),
        schema_version_(arena) {}

inline void CommandGetSchemaResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, schema_),
           0,
           offsetof(Impl_, error_code_) -
               offsetof(Impl_, schema_) +
               sizeof(Impl_::error_code_));
}
CommandGetSchemaResponse::~CommandGetSchemaResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandGetSchemaResponse)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandGetSchemaResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.error_message_.Destroy();
  _impl_.schema_version_.Destroy();
  delete _impl_.schema_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandGetSchemaResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandGetSchemaResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.error_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.schema_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.schema_ != nullptr);
      _impl_.schema_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.error_code_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.error_code_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandGetSchemaResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 2, 0, 2> CommandGetSchemaResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandGetSchemaResponse, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandGetSchemaResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 3, 0, PROTOBUF_FIELD_OFFSET(CommandGetSchemaResponse, _impl_.request_id_)}},
    // optional .pulsar.proto.ServerError error_code = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 4, 25, PROTOBUF_FIELD_OFFSET(CommandGetSchemaResponse, _impl_.error_code_)}},
    // optional string error_message = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(CommandGetSchemaResponse, _impl_.error_message_)}},
    // optional .pulsar.proto.Schema schema = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 2, 1, PROTOBUF_FIELD_OFFSET(CommandGetSchemaResponse, _impl_.schema_)}},
    // optional bytes schema_version = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 1, 0, PROTOBUF_FIELD_OFFSET(CommandGetSchemaResponse, _impl_.schema_version_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandGetSchemaResponse, _impl_.request_id_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.ServerError error_code = 2;
    {PROTOBUF_FIELD_OFFSET(CommandGetSchemaResponse, _impl_.error_code_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string error_message = 3;
    {PROTOBUF_FIELD_OFFSET(CommandGetSchemaResponse, _impl_.error_message_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .pulsar.proto.Schema schema = 4;
    {PROTOBUF_FIELD_OFFSET(CommandGetSchemaResponse, _impl_.schema_), _Internal::kHasBitsOffset + 2, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bytes schema_version = 5;
    {PROTOBUF_FIELD_OFFSET(CommandGetSchemaResponse, _impl_.schema_version_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {0, 26},
    {::_pbi::TcParser::GetTable<::pulsar::proto::Schema>()},
  }}, {{
  }},
};

::uint8_t* CommandGetSchemaResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandGetSchemaResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // optional .pulsar.proto.ServerError error_code = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_error_code(), target);
  }

  // optional string error_message = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_error_message();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional .pulsar.proto.Schema schema = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, _Internal::schema(this),
        _Internal::schema(this).GetCachedSize(), target, stream);
  }

  // optional bytes schema_version = 5;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_schema_version();
    target = stream->WriteBytesMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandGetSchemaResponse)
  return target;
}

::size_t CommandGetSchemaResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandGetSchemaResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string error_message = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_error_message());
    }

    // optional bytes schema_version = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_schema_version());
    }

    // optional .pulsar.proto.Schema schema = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.schema_);
    }

  }
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000008u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  // optional .pulsar.proto.ServerError error_code = 2;
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_error_code());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandGetSchemaResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandGetSchemaResponse*>(
      &from));
}

void CommandGetSchemaResponse::MergeFrom(const CommandGetSchemaResponse& from) {
  CommandGetSchemaResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandGetSchemaResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_schema_version(from._internal_schema_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_schema()->::pulsar::proto::Schema::MergeFrom(
          from._internal_schema());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.error_code_ = from._impl_.error_code_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandGetSchemaResponse::CopyFrom(const CommandGetSchemaResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandGetSchemaResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandGetSchemaResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (!_impl_.schema_->IsInitialized()) return false;
  }
  return true;
}

::_pbi::CachedSize* CommandGetSchemaResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandGetSchemaResponse::InternalSwap(CommandGetSchemaResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.error_message_, &other->_impl_.error_message_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.schema_version_, &other->_impl_.schema_version_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandGetSchemaResponse, _impl_.error_code_)
      + sizeof(CommandGetSchemaResponse::_impl_.error_code_)
      - PROTOBUF_FIELD_OFFSET(CommandGetSchemaResponse, _impl_.schema_)>(
          reinterpret_cast<char*>(&_impl_.schema_),
          reinterpret_cast<char*>(&other->_impl_.schema_));
}

std::string CommandGetSchemaResponse::GetTypeName() const {
  return "pulsar.proto.CommandGetSchemaResponse";
}

// ===================================================================

class CommandGetOrCreateSchema::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandGetOrCreateSchema>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchema, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pulsar::proto::Schema& schema(const CommandGetOrCreateSchema* msg);
  static void set_has_schema(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::pulsar::proto::Schema& CommandGetOrCreateSchema::_Internal::schema(const CommandGetOrCreateSchema* msg) {
  return *msg->_impl_.schema_;
}
CommandGetOrCreateSchema::CommandGetOrCreateSchema(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandGetOrCreateSchema)
}
inline PROTOBUF_NDEBUG_INLINE CommandGetOrCreateSchema::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        topic_(arena, from.topic_) {}

CommandGetOrCreateSchema::CommandGetOrCreateSchema(
    ::google::protobuf::Arena* arena,
    const CommandGetOrCreateSchema& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandGetOrCreateSchema* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.schema_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::pulsar::proto::Schema>(arena, *from._impl_.schema_)
                : nullptr;
  _impl_.request_id_ = from._impl_.request_id_;

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandGetOrCreateSchema)
}
inline PROTOBUF_NDEBUG_INLINE CommandGetOrCreateSchema::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        topic_(arena) {}

inline void CommandGetOrCreateSchema::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, schema_),
           0,
           offsetof(Impl_, request_id_) -
               offsetof(Impl_, schema_) +
               sizeof(Impl_::request_id_));
}
CommandGetOrCreateSchema::~CommandGetOrCreateSchema() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandGetOrCreateSchema)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandGetOrCreateSchema::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.topic_.Destroy();
  delete _impl_.schema_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandGetOrCreateSchema::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandGetOrCreateSchema)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.schema_ != nullptr);
      _impl_.schema_->Clear();
    }
  }
  _impl_.request_id_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandGetOrCreateSchema::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> CommandGetOrCreateSchema::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchema, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandGetOrCreateSchema_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchema, _impl_.request_id_)}},
    // required string topic = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchema, _impl_.topic_)}},
    // required .pulsar.proto.Schema schema = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 0, PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchema, _impl_.schema_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchema, _impl_.request_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required string topic = 2;
    {PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchema, _impl_.topic_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // required .pulsar.proto.Schema schema = 3;
    {PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchema, _impl_.schema_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::Schema>()},
  }}, {{
  }},
};

::uint8_t* CommandGetOrCreateSchema::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandGetOrCreateSchema)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // required string topic = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_topic();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // required .pulsar.proto.Schema schema = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::schema(this),
        _Internal::schema(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandGetOrCreateSchema)
  return target;
}

::size_t CommandGetOrCreateSchema::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandGetOrCreateSchema)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // required string topic = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_topic());
    }

    // required .pulsar.proto.Schema schema = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.schema_);
    }

    // required uint64 request_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_request_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandGetOrCreateSchema::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandGetOrCreateSchema*>(
      &from));
}

void CommandGetOrCreateSchema::MergeFrom(const CommandGetOrCreateSchema& from) {
  CommandGetOrCreateSchema* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandGetOrCreateSchema)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_topic(from._internal_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_schema()->::pulsar::proto::Schema::MergeFrom(
          from._internal_schema());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandGetOrCreateSchema::CopyFrom(const CommandGetOrCreateSchema& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandGetOrCreateSchema)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandGetOrCreateSchema::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!_impl_.schema_->IsInitialized()) return false;
  }
  return true;
}

::_pbi::CachedSize* CommandGetOrCreateSchema::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandGetOrCreateSchema::InternalSwap(CommandGetOrCreateSchema* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.topic_, &other->_impl_.topic_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchema, _impl_.request_id_)
      + sizeof(CommandGetOrCreateSchema::_impl_.request_id_)
      - PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchema, _impl_.schema_)>(
          reinterpret_cast<char*>(&_impl_.schema_),
          reinterpret_cast<char*>(&other->_impl_.schema_));
}

std::string CommandGetOrCreateSchema::GetTypeName() const {
  return "pulsar.proto.CommandGetOrCreateSchema";
}

// ===================================================================

class CommandGetOrCreateSchemaResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandGetOrCreateSchemaResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchemaResponse, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_schema_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

CommandGetOrCreateSchemaResponse::CommandGetOrCreateSchemaResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandGetOrCreateSchemaResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandGetOrCreateSchemaResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        error_message_(arena, from.error_message_),
        schema_version_(arena, from.schema_version_) {}

CommandGetOrCreateSchemaResponse::CommandGetOrCreateSchemaResponse(
    ::google::protobuf::Arena* arena,
    const CommandGetOrCreateSchemaResponse& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandGetOrCreateSchemaResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, error_code_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_code_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandGetOrCreateSchemaResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandGetOrCreateSchemaResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        error_message_(arena),
        schema_version_(arena) {}

inline void CommandGetOrCreateSchemaResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, error_code_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_code_));
}
CommandGetOrCreateSchemaResponse::~CommandGetOrCreateSchemaResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandGetOrCreateSchemaResponse)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandGetOrCreateSchemaResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.error_message_.Destroy();
  _impl_.schema_version_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandGetOrCreateSchemaResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandGetOrCreateSchemaResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.error_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.schema_version_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.error_code_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.error_code_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandGetOrCreateSchemaResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2> CommandGetOrCreateSchemaResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchemaResponse, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandGetOrCreateSchemaResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional bytes schema_version = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchemaResponse, _impl_.schema_version_)}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchemaResponse, _impl_.request_id_)}},
    // optional .pulsar.proto.ServerError error_code = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 3, 25, PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchemaResponse, _impl_.error_code_)}},
    // optional string error_message = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchemaResponse, _impl_.error_message_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchemaResponse, _impl_.request_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.ServerError error_code = 2;
    {PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchemaResponse, _impl_.error_code_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string error_message = 3;
    {PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchemaResponse, _impl_.error_message_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes schema_version = 4;
    {PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchemaResponse, _impl_.schema_version_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {0, 26},
  }}, {{
  }},
};

::uint8_t* CommandGetOrCreateSchemaResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandGetOrCreateSchemaResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // optional .pulsar.proto.ServerError error_code = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_error_code(), target);
  }

  // optional string error_message = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_error_message();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional bytes schema_version = 4;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_schema_version();
    target = stream->WriteBytesMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandGetOrCreateSchemaResponse)
  return target;
}

::size_t CommandGetOrCreateSchemaResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandGetOrCreateSchemaResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string error_message = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_error_message());
    }

    // optional bytes schema_version = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_schema_version());
    }

  }
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  // optional .pulsar.proto.ServerError error_code = 2;
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_error_code());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandGetOrCreateSchemaResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandGetOrCreateSchemaResponse*>(
      &from));
}

void CommandGetOrCreateSchemaResponse::MergeFrom(const CommandGetOrCreateSchemaResponse& from) {
  CommandGetOrCreateSchemaResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandGetOrCreateSchemaResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_schema_version(from._internal_schema_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.error_code_ = from._impl_.error_code_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandGetOrCreateSchemaResponse::CopyFrom(const CommandGetOrCreateSchemaResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandGetOrCreateSchemaResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandGetOrCreateSchemaResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandGetOrCreateSchemaResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandGetOrCreateSchemaResponse::InternalSwap(CommandGetOrCreateSchemaResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.error_message_, &other->_impl_.error_message_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.schema_version_, &other->_impl_.schema_version_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchemaResponse, _impl_.error_code_)
      + sizeof(CommandGetOrCreateSchemaResponse::_impl_.error_code_)
      - PROTOBUF_FIELD_OFFSET(CommandGetOrCreateSchemaResponse, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandGetOrCreateSchemaResponse::GetTypeName() const {
  return "pulsar.proto.CommandGetOrCreateSchemaResponse";
}

// ===================================================================

class CommandTcClientConnectRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandTcClientConnectRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandTcClientConnectRequest, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tc_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CommandTcClientConnectRequest::CommandTcClientConnectRequest(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandTcClientConnectRequest)
}
CommandTcClientConnectRequest::CommandTcClientConnectRequest(
    ::google::protobuf::Arena* arena, const CommandTcClientConnectRequest& from)
    : CommandTcClientConnectRequest(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CommandTcClientConnectRequest::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CommandTcClientConnectRequest::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, tc_id_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::tc_id_));
}
CommandTcClientConnectRequest::~CommandTcClientConnectRequest() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandTcClientConnectRequest)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandTcClientConnectRequest::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandTcClientConnectRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandTcClientConnectRequest)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.tc_id_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.tc_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandTcClientConnectRequest::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> CommandTcClientConnectRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandTcClientConnectRequest, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandTcClientConnectRequest_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // required uint64 tc_id = 2 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CommandTcClientConnectRequest, _impl_.tc_id_)}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(CommandTcClientConnectRequest, _impl_.request_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandTcClientConnectRequest, _impl_.request_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // required uint64 tc_id = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandTcClientConnectRequest, _impl_.tc_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandTcClientConnectRequest::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandTcClientConnectRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // required uint64 tc_id = 2 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_tc_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandTcClientConnectRequest)
  return target;
}

::size_t CommandTcClientConnectRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandTcClientConnectRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required uint64 request_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_request_id());
    }

    // required uint64 tc_id = 2 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_tc_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandTcClientConnectRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandTcClientConnectRequest*>(
      &from));
}

void CommandTcClientConnectRequest::MergeFrom(const CommandTcClientConnectRequest& from) {
  CommandTcClientConnectRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandTcClientConnectRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tc_id_ = from._impl_.tc_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandTcClientConnectRequest::CopyFrom(const CommandTcClientConnectRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandTcClientConnectRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandTcClientConnectRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandTcClientConnectRequest::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandTcClientConnectRequest::InternalSwap(CommandTcClientConnectRequest* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandTcClientConnectRequest, _impl_.tc_id_)
      + sizeof(CommandTcClientConnectRequest::_impl_.tc_id_)
      - PROTOBUF_FIELD_OFFSET(CommandTcClientConnectRequest, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandTcClientConnectRequest::GetTypeName() const {
  return "pulsar.proto.CommandTcClientConnectRequest";
}

// ===================================================================

class CommandTcClientConnectResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandTcClientConnectResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandTcClientConnectResponse, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandTcClientConnectResponse::CommandTcClientConnectResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandTcClientConnectResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandTcClientConnectResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_(arena, from.message_) {}

CommandTcClientConnectResponse::CommandTcClientConnectResponse(
    ::google::protobuf::Arena* arena,
    const CommandTcClientConnectResponse& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandTcClientConnectResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandTcClientConnectResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandTcClientConnectResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        message_(arena) {}

inline void CommandTcClientConnectResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));
}
CommandTcClientConnectResponse::~CommandTcClientConnectResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandTcClientConnectResponse)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandTcClientConnectResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.message_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandTcClientConnectResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandTcClientConnectResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.error_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.error_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandTcClientConnectResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> CommandTcClientConnectResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandTcClientConnectResponse, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandTcClientConnectResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandTcClientConnectResponse, _impl_.request_id_)}},
    // optional .pulsar.proto.ServerError error = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 2, 25, PROTOBUF_FIELD_OFFSET(CommandTcClientConnectResponse, _impl_.error_)}},
    // optional string message = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(CommandTcClientConnectResponse, _impl_.message_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandTcClientConnectResponse, _impl_.request_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.ServerError error = 2;
    {PROTOBUF_FIELD_OFFSET(CommandTcClientConnectResponse, _impl_.error_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string message = 3;
    {PROTOBUF_FIELD_OFFSET(CommandTcClientConnectResponse, _impl_.message_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {0, 26},
  }}, {{
  }},
};

::uint8_t* CommandTcClientConnectResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandTcClientConnectResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // optional .pulsar.proto.ServerError error = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_error(), target);
  }

  // optional string message = 3;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_message();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandTcClientConnectResponse)
  return target;
}

::size_t CommandTcClientConnectResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandTcClientConnectResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  // optional .pulsar.proto.ServerError error = 2;
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandTcClientConnectResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandTcClientConnectResponse*>(
      &from));
}

void CommandTcClientConnectResponse::MergeFrom(const CommandTcClientConnectResponse& from) {
  CommandTcClientConnectResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandTcClientConnectResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandTcClientConnectResponse::CopyFrom(const CommandTcClientConnectResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandTcClientConnectResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandTcClientConnectResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandTcClientConnectResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandTcClientConnectResponse::InternalSwap(CommandTcClientConnectResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandTcClientConnectResponse, _impl_.error_)
      + sizeof(CommandTcClientConnectResponse::_impl_.error_)
      - PROTOBUF_FIELD_OFFSET(CommandTcClientConnectResponse, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandTcClientConnectResponse::GetTypeName() const {
  return "pulsar.proto.CommandTcClientConnectResponse";
}

// ===================================================================

class CommandNewTxn::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandNewTxn>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandNewTxn, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_txn_ttl_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tc_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CommandNewTxn::CommandNewTxn(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandNewTxn)
}
CommandNewTxn::CommandNewTxn(
    ::google::protobuf::Arena* arena, const CommandNewTxn& from)
    : CommandNewTxn(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CommandNewTxn::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CommandNewTxn::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, tc_id_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::tc_id_));
}
CommandNewTxn::~CommandNewTxn() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandNewTxn)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandNewTxn::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandNewTxn::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandNewTxn)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.tc_id_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.tc_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandNewTxn::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> CommandNewTxn::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandNewTxn, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandNewTxn_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(CommandNewTxn, _impl_.request_id_)}},
    // optional uint64 txn_ttl_seconds = 2 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CommandNewTxn, _impl_.txn_ttl_seconds_)}},
    // optional uint64 tc_id = 3 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(CommandNewTxn, _impl_.tc_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandNewTxn, _impl_.request_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txn_ttl_seconds = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandNewTxn, _impl_.txn_ttl_seconds_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 tc_id = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandNewTxn, _impl_.tc_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandNewTxn::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandNewTxn)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // optional uint64 txn_ttl_seconds = 2 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_txn_ttl_seconds(), target);
  }

  // optional uint64 tc_id = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_tc_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandNewTxn)
  return target;
}

::size_t CommandNewTxn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandNewTxn)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // required uint64 request_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (cached_has_bits & 0x00000006u) {
    // optional uint64 txn_ttl_seconds = 2 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txn_ttl_seconds());
    }

    // optional uint64 tc_id = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_tc_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandNewTxn::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandNewTxn*>(
      &from));
}

void CommandNewTxn::MergeFrom(const CommandNewTxn& from) {
  CommandNewTxn* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandNewTxn)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.txn_ttl_seconds_ = from._impl_.txn_ttl_seconds_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.tc_id_ = from._impl_.tc_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandNewTxn::CopyFrom(const CommandNewTxn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandNewTxn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandNewTxn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandNewTxn::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandNewTxn::InternalSwap(CommandNewTxn* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandNewTxn, _impl_.tc_id_)
      + sizeof(CommandNewTxn::_impl_.tc_id_)
      - PROTOBUF_FIELD_OFFSET(CommandNewTxn, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandNewTxn::GetTypeName() const {
  return "pulsar.proto.CommandNewTxn";
}

// ===================================================================

class CommandNewTxnResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandNewTxnResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandNewTxnResponse, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandNewTxnResponse::CommandNewTxnResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandNewTxnResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandNewTxnResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_(arena, from.message_) {}

CommandNewTxnResponse::CommandNewTxnResponse(
    ::google::protobuf::Arena* arena,
    const CommandNewTxnResponse& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandNewTxnResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandNewTxnResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandNewTxnResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        message_(arena) {}

inline void CommandNewTxnResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));
}
CommandNewTxnResponse::~CommandNewTxnResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandNewTxnResponse)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandNewTxnResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.message_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandNewTxnResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandNewTxnResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.error_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.error_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandNewTxnResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 1, 0, 2> CommandNewTxnResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandNewTxnResponse, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandNewTxnResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandNewTxnResponse, _impl_.request_id_)}},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(CommandNewTxnResponse, _impl_.txnid_least_bits_)}},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(CommandNewTxnResponse, _impl_.txnid_most_bits_)}},
    // optional .pulsar.proto.ServerError error = 4;
    {::_pbi::TcParser::FastEr0S1,
     {32, 4, 25, PROTOBUF_FIELD_OFFSET(CommandNewTxnResponse, _impl_.error_)}},
    // optional string message = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 0, 0, PROTOBUF_FIELD_OFFSET(CommandNewTxnResponse, _impl_.message_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandNewTxnResponse, _impl_.request_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandNewTxnResponse, _impl_.txnid_least_bits_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandNewTxnResponse, _impl_.txnid_most_bits_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.ServerError error = 4;
    {PROTOBUF_FIELD_OFFSET(CommandNewTxnResponse, _impl_.error_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string message = 5;
    {PROTOBUF_FIELD_OFFSET(CommandNewTxnResponse, _impl_.message_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {0, 26},
  }}, {{
  }},
};

::uint8_t* CommandNewTxnResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandNewTxnResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.ServerError error = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_error(), target);
  }

  // optional string message = 5;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_message();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandNewTxnResponse)
  return target;
}

::size_t CommandNewTxnResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandNewTxnResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_most_bits());
    }

    // optional .pulsar.proto.ServerError error = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandNewTxnResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandNewTxnResponse*>(
      &from));
}

void CommandNewTxnResponse::MergeFrom(const CommandNewTxnResponse& from) {
  CommandNewTxnResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandNewTxnResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.txnid_least_bits_ = from._impl_.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.txnid_most_bits_ = from._impl_.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandNewTxnResponse::CopyFrom(const CommandNewTxnResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandNewTxnResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandNewTxnResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandNewTxnResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandNewTxnResponse::InternalSwap(CommandNewTxnResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandNewTxnResponse, _impl_.error_)
      + sizeof(CommandNewTxnResponse::_impl_.error_)
      - PROTOBUF_FIELD_OFFSET(CommandNewTxnResponse, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandNewTxnResponse::GetTypeName() const {
  return "pulsar.proto.CommandNewTxnResponse";
}

// ===================================================================

class CommandAddPartitionToTxn::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandAddPartitionToTxn>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxn, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CommandAddPartitionToTxn::CommandAddPartitionToTxn(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandAddPartitionToTxn)
}
inline PROTOBUF_NDEBUG_INLINE CommandAddPartitionToTxn::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        partitions_{visibility, arena, from.partitions_} {}

CommandAddPartitionToTxn::CommandAddPartitionToTxn(
    ::google::protobuf::Arena* arena,
    const CommandAddPartitionToTxn& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandAddPartitionToTxn* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, txnid_most_bits_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::txnid_most_bits_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandAddPartitionToTxn)
}
inline PROTOBUF_NDEBUG_INLINE CommandAddPartitionToTxn::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        partitions_{visibility, arena} {}

inline void CommandAddPartitionToTxn::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, txnid_most_bits_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::txnid_most_bits_));
}
CommandAddPartitionToTxn::~CommandAddPartitionToTxn() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandAddPartitionToTxn)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandAddPartitionToTxn::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandAddPartitionToTxn::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandAddPartitionToTxn)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.partitions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.txnid_most_bits_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.txnid_most_bits_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandAddPartitionToTxn::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> CommandAddPartitionToTxn::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxn, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CommandAddPartitionToTxn_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // repeated string partitions = 4;
    {::_pbi::TcParser::FastBR1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxn, _impl_.partitions_)}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxn, _impl_.request_id_)}},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxn, _impl_.txnid_least_bits_)}},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxn, _impl_.txnid_most_bits_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxn, _impl_.request_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxn, _impl_.txnid_least_bits_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxn, _impl_.txnid_most_bits_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // repeated string partitions = 4;
    {PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxn, _impl_.partitions_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CommandAddPartitionToTxn::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandAddPartitionToTxn)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_txnid_most_bits(), target);
  }

  // repeated string partitions = 4;
  for (int i = 0, n = this->_internal_partitions_size(); i < n; ++i) {
    const auto& s = this->_internal_partitions().Get(i);
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandAddPartitionToTxn)
  return target;
}

::size_t CommandAddPartitionToTxn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandAddPartitionToTxn)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string partitions = 4;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_partitions().size());
  for (int i = 0, n = _internal_partitions().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_partitions().Get(i));
  }
  // required uint64 request_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (cached_has_bits & 0x00000006u) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_most_bits());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandAddPartitionToTxn::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandAddPartitionToTxn*>(
      &from));
}

void CommandAddPartitionToTxn::MergeFrom(const CommandAddPartitionToTxn& from) {
  CommandAddPartitionToTxn* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandAddPartitionToTxn)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_partitions()->MergeFrom(from._internal_partitions());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.txnid_least_bits_ = from._impl_.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.txnid_most_bits_ = from._impl_.txnid_most_bits_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandAddPartitionToTxn::CopyFrom(const CommandAddPartitionToTxn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandAddPartitionToTxn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandAddPartitionToTxn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandAddPartitionToTxn::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandAddPartitionToTxn::InternalSwap(CommandAddPartitionToTxn* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.partitions_.InternalSwap(&other->_impl_.partitions_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxn, _impl_.txnid_most_bits_)
      + sizeof(CommandAddPartitionToTxn::_impl_.txnid_most_bits_)
      - PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxn, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandAddPartitionToTxn::GetTypeName() const {
  return "pulsar.proto.CommandAddPartitionToTxn";
}

// ===================================================================

class CommandAddPartitionToTxnResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandAddPartitionToTxnResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxnResponse, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandAddPartitionToTxnResponse::CommandAddPartitionToTxnResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandAddPartitionToTxnResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandAddPartitionToTxnResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_(arena, from.message_) {}

CommandAddPartitionToTxnResponse::CommandAddPartitionToTxnResponse(
    ::google::protobuf::Arena* arena,
    const CommandAddPartitionToTxnResponse& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandAddPartitionToTxnResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandAddPartitionToTxnResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandAddPartitionToTxnResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        message_(arena) {}

inline void CommandAddPartitionToTxnResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));
}
CommandAddPartitionToTxnResponse::~CommandAddPartitionToTxnResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandAddPartitionToTxnResponse)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandAddPartitionToTxnResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.message_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandAddPartitionToTxnResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandAddPartitionToTxnResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.error_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.error_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandAddPartitionToTxnResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 1, 0, 2> CommandAddPartitionToTxnResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxnResponse, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandAddPartitionToTxnResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxnResponse, _impl_.request_id_)}},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxnResponse, _impl_.txnid_least_bits_)}},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxnResponse, _impl_.txnid_most_bits_)}},
    // optional .pulsar.proto.ServerError error = 4;
    {::_pbi::TcParser::FastEr0S1,
     {32, 4, 25, PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxnResponse, _impl_.error_)}},
    // optional string message = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 0, 0, PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxnResponse, _impl_.message_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxnResponse, _impl_.request_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxnResponse, _impl_.txnid_least_bits_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxnResponse, _impl_.txnid_most_bits_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.ServerError error = 4;
    {PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxnResponse, _impl_.error_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string message = 5;
    {PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxnResponse, _impl_.message_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {0, 26},
  }}, {{
  }},
};

::uint8_t* CommandAddPartitionToTxnResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandAddPartitionToTxnResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.ServerError error = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_error(), target);
  }

  // optional string message = 5;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_message();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandAddPartitionToTxnResponse)
  return target;
}

::size_t CommandAddPartitionToTxnResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandAddPartitionToTxnResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_most_bits());
    }

    // optional .pulsar.proto.ServerError error = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandAddPartitionToTxnResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandAddPartitionToTxnResponse*>(
      &from));
}

void CommandAddPartitionToTxnResponse::MergeFrom(const CommandAddPartitionToTxnResponse& from) {
  CommandAddPartitionToTxnResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandAddPartitionToTxnResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.txnid_least_bits_ = from._impl_.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.txnid_most_bits_ = from._impl_.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandAddPartitionToTxnResponse::CopyFrom(const CommandAddPartitionToTxnResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandAddPartitionToTxnResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandAddPartitionToTxnResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandAddPartitionToTxnResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandAddPartitionToTxnResponse::InternalSwap(CommandAddPartitionToTxnResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxnResponse, _impl_.error_)
      + sizeof(CommandAddPartitionToTxnResponse::_impl_.error_)
      - PROTOBUF_FIELD_OFFSET(CommandAddPartitionToTxnResponse, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandAddPartitionToTxnResponse::GetTypeName() const {
  return "pulsar.proto.CommandAddPartitionToTxnResponse";
}

// ===================================================================

class Subscription::_Internal {
 public:
  using HasBits = decltype(std::declval<Subscription>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Subscription, _impl_._has_bits_);
  static void set_has_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_subscription(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

Subscription::Subscription(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.Subscription)
}
inline PROTOBUF_NDEBUG_INLINE Subscription::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        topic_(arena, from.topic_),
        subscription_(arena, from.subscription_) {}

Subscription::Subscription(
    ::google::protobuf::Arena* arena,
    const Subscription& from)
    : ::google::protobuf::MessageLite(arena) {
  Subscription* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.Subscription)
}
inline PROTOBUF_NDEBUG_INLINE Subscription::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        topic_(arena),
        subscription_(arena) {}

inline void Subscription::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
Subscription::~Subscription() {
  // @@protoc_insertion_point(destructor:pulsar.proto.Subscription)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void Subscription::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.topic_.Destroy();
  _impl_.subscription_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void Subscription::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.Subscription)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.topic_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.subscription_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Subscription::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> Subscription::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Subscription, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Subscription_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // required string subscription = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(Subscription, _impl_.subscription_)}},
    // required string topic = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Subscription, _impl_.topic_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string topic = 1;
    {PROTOBUF_FIELD_OFFSET(Subscription, _impl_.topic_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // required string subscription = 2;
    {PROTOBUF_FIELD_OFFSET(Subscription, _impl_.subscription_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* Subscription::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.Subscription)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string topic = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_topic();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required string subscription = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_subscription();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.Subscription)
  return target;
}

::size_t Subscription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.Subscription)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // required string topic = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_topic());
    }

    // required string subscription = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_subscription());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void Subscription::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Subscription*>(
      &from));
}

void Subscription::MergeFrom(const Subscription& from) {
  Subscription* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.Subscription)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_topic(from._internal_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_subscription(from._internal_subscription());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Subscription::CopyFrom(const Subscription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.Subscription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Subscription::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* Subscription::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void Subscription::InternalSwap(Subscription* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.topic_, &other->_impl_.topic_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.subscription_, &other->_impl_.subscription_, arena);
}

std::string Subscription::GetTypeName() const {
  return "pulsar.proto.Subscription";
}

// ===================================================================

class CommandAddSubscriptionToTxn::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandAddSubscriptionToTxn>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxn, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CommandAddSubscriptionToTxn::CommandAddSubscriptionToTxn(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandAddSubscriptionToTxn)
}
inline PROTOBUF_NDEBUG_INLINE CommandAddSubscriptionToTxn::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        subscription_{visibility, arena, from.subscription_} {}

CommandAddSubscriptionToTxn::CommandAddSubscriptionToTxn(
    ::google::protobuf::Arena* arena,
    const CommandAddSubscriptionToTxn& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandAddSubscriptionToTxn* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, txnid_most_bits_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::txnid_most_bits_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandAddSubscriptionToTxn)
}
inline PROTOBUF_NDEBUG_INLINE CommandAddSubscriptionToTxn::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        subscription_{visibility, arena} {}

inline void CommandAddSubscriptionToTxn::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, txnid_most_bits_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::txnid_most_bits_));
}
CommandAddSubscriptionToTxn::~CommandAddSubscriptionToTxn() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandAddSubscriptionToTxn)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandAddSubscriptionToTxn::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandAddSubscriptionToTxn::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandAddSubscriptionToTxn)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subscription_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.txnid_most_bits_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.txnid_most_bits_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandAddSubscriptionToTxn::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2> CommandAddSubscriptionToTxn::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxn, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandAddSubscriptionToTxn_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // repeated .pulsar.proto.Subscription subscription = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxn, _impl_.subscription_)}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxn, _impl_.request_id_)}},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxn, _impl_.txnid_least_bits_)}},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxn, _impl_.txnid_most_bits_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxn, _impl_.request_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxn, _impl_.txnid_least_bits_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxn, _impl_.txnid_most_bits_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // repeated .pulsar.proto.Subscription subscription = 4;
    {PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxn, _impl_.subscription_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::Subscription>()},
  }}, {{
  }},
};

::uint8_t* CommandAddSubscriptionToTxn::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandAddSubscriptionToTxn)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_txnid_most_bits(), target);
  }

  // repeated .pulsar.proto.Subscription subscription = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_subscription_size()); i < n; i++) {
    const auto& repfield = this->_internal_subscription().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandAddSubscriptionToTxn)
  return target;
}

::size_t CommandAddSubscriptionToTxn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandAddSubscriptionToTxn)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulsar.proto.Subscription subscription = 4;
  total_size += 1UL * this->_internal_subscription_size();
  for (const auto& msg : this->_internal_subscription()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // required uint64 request_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (cached_has_bits & 0x00000006u) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_most_bits());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandAddSubscriptionToTxn::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandAddSubscriptionToTxn*>(
      &from));
}

void CommandAddSubscriptionToTxn::MergeFrom(const CommandAddSubscriptionToTxn& from) {
  CommandAddSubscriptionToTxn* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandAddSubscriptionToTxn)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_subscription()->MergeFrom(
      from._internal_subscription());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.txnid_least_bits_ = from._impl_.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.txnid_most_bits_ = from._impl_.txnid_most_bits_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandAddSubscriptionToTxn::CopyFrom(const CommandAddSubscriptionToTxn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandAddSubscriptionToTxn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandAddSubscriptionToTxn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(_internal_subscription()))
    return false;
  return true;
}

::_pbi::CachedSize* CommandAddSubscriptionToTxn::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandAddSubscriptionToTxn::InternalSwap(CommandAddSubscriptionToTxn* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.subscription_.InternalSwap(&other->_impl_.subscription_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxn, _impl_.txnid_most_bits_)
      + sizeof(CommandAddSubscriptionToTxn::_impl_.txnid_most_bits_)
      - PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxn, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandAddSubscriptionToTxn::GetTypeName() const {
  return "pulsar.proto.CommandAddSubscriptionToTxn";
}

// ===================================================================

class CommandAddSubscriptionToTxnResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandAddSubscriptionToTxnResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxnResponse, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandAddSubscriptionToTxnResponse::CommandAddSubscriptionToTxnResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandAddSubscriptionToTxnResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandAddSubscriptionToTxnResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_(arena, from.message_) {}

CommandAddSubscriptionToTxnResponse::CommandAddSubscriptionToTxnResponse(
    ::google::protobuf::Arena* arena,
    const CommandAddSubscriptionToTxnResponse& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandAddSubscriptionToTxnResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandAddSubscriptionToTxnResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandAddSubscriptionToTxnResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        message_(arena) {}

inline void CommandAddSubscriptionToTxnResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));
}
CommandAddSubscriptionToTxnResponse::~CommandAddSubscriptionToTxnResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandAddSubscriptionToTxnResponse)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandAddSubscriptionToTxnResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.message_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandAddSubscriptionToTxnResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandAddSubscriptionToTxnResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.error_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.error_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandAddSubscriptionToTxnResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 1, 0, 2> CommandAddSubscriptionToTxnResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxnResponse, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandAddSubscriptionToTxnResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxnResponse, _impl_.request_id_)}},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxnResponse, _impl_.txnid_least_bits_)}},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxnResponse, _impl_.txnid_most_bits_)}},
    // optional .pulsar.proto.ServerError error = 4;
    {::_pbi::TcParser::FastEr0S1,
     {32, 4, 25, PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxnResponse, _impl_.error_)}},
    // optional string message = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 0, 0, PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxnResponse, _impl_.message_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxnResponse, _impl_.request_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxnResponse, _impl_.txnid_least_bits_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxnResponse, _impl_.txnid_most_bits_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.ServerError error = 4;
    {PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxnResponse, _impl_.error_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string message = 5;
    {PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxnResponse, _impl_.message_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {0, 26},
  }}, {{
  }},
};

::uint8_t* CommandAddSubscriptionToTxnResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandAddSubscriptionToTxnResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.ServerError error = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_error(), target);
  }

  // optional string message = 5;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_message();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandAddSubscriptionToTxnResponse)
  return target;
}

::size_t CommandAddSubscriptionToTxnResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandAddSubscriptionToTxnResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_most_bits());
    }

    // optional .pulsar.proto.ServerError error = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandAddSubscriptionToTxnResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandAddSubscriptionToTxnResponse*>(
      &from));
}

void CommandAddSubscriptionToTxnResponse::MergeFrom(const CommandAddSubscriptionToTxnResponse& from) {
  CommandAddSubscriptionToTxnResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandAddSubscriptionToTxnResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.txnid_least_bits_ = from._impl_.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.txnid_most_bits_ = from._impl_.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandAddSubscriptionToTxnResponse::CopyFrom(const CommandAddSubscriptionToTxnResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandAddSubscriptionToTxnResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandAddSubscriptionToTxnResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandAddSubscriptionToTxnResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandAddSubscriptionToTxnResponse::InternalSwap(CommandAddSubscriptionToTxnResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxnResponse, _impl_.error_)
      + sizeof(CommandAddSubscriptionToTxnResponse::_impl_.error_)
      - PROTOBUF_FIELD_OFFSET(CommandAddSubscriptionToTxnResponse, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandAddSubscriptionToTxnResponse::GetTypeName() const {
  return "pulsar.proto.CommandAddSubscriptionToTxnResponse";
}

// ===================================================================

class CommandEndTxn::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandEndTxn>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandEndTxn, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txn_action(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CommandEndTxn::CommandEndTxn(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandEndTxn)
}
CommandEndTxn::CommandEndTxn(
    ::google::protobuf::Arena* arena, const CommandEndTxn& from)
    : CommandEndTxn(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CommandEndTxn::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CommandEndTxn::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, txn_action_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::txn_action_));
}
CommandEndTxn::~CommandEndTxn() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandEndTxn)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandEndTxn::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandEndTxn::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandEndTxn)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.txn_action_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.txn_action_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandEndTxn::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2> CommandEndTxn::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandEndTxn, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandEndTxn_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional .pulsar.proto.TxnAction txn_action = 4;
    {::_pbi::TcParser::FastEr0S1,
     {32, 3, 1, PROTOBUF_FIELD_OFFSET(CommandEndTxn, _impl_.txn_action_)}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxn, _impl_.request_id_)}},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxn, _impl_.txnid_least_bits_)}},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxn, _impl_.txnid_most_bits_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxn, _impl_.request_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandEndTxn, _impl_.txnid_least_bits_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandEndTxn, _impl_.txnid_most_bits_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.TxnAction txn_action = 4;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxn, _impl_.txn_action_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
  }}, {{
    {0, 2},
  }}, {{
  }},
};

::uint8_t* CommandEndTxn::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandEndTxn)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.TxnAction txn_action = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_txn_action(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandEndTxn)
  return target;
}

::size_t CommandEndTxn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandEndTxn)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // required uint64 request_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (cached_has_bits & 0x0000000eu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_most_bits());
    }

    // optional .pulsar.proto.TxnAction txn_action = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_txn_action());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandEndTxn::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandEndTxn*>(
      &from));
}

void CommandEndTxn::MergeFrom(const CommandEndTxn& from) {
  CommandEndTxn* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandEndTxn)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.txnid_least_bits_ = from._impl_.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.txnid_most_bits_ = from._impl_.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.txn_action_ = from._impl_.txn_action_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandEndTxn::CopyFrom(const CommandEndTxn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandEndTxn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandEndTxn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandEndTxn::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandEndTxn::InternalSwap(CommandEndTxn* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandEndTxn, _impl_.txn_action_)
      + sizeof(CommandEndTxn::_impl_.txn_action_)
      - PROTOBUF_FIELD_OFFSET(CommandEndTxn, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandEndTxn::GetTypeName() const {
  return "pulsar.proto.CommandEndTxn";
}

// ===================================================================

class CommandEndTxnResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandEndTxnResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandEndTxnResponse, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandEndTxnResponse::CommandEndTxnResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandEndTxnResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandEndTxnResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_(arena, from.message_) {}

CommandEndTxnResponse::CommandEndTxnResponse(
    ::google::protobuf::Arena* arena,
    const CommandEndTxnResponse& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandEndTxnResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandEndTxnResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandEndTxnResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        message_(arena) {}

inline void CommandEndTxnResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));
}
CommandEndTxnResponse::~CommandEndTxnResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandEndTxnResponse)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandEndTxnResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.message_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandEndTxnResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandEndTxnResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.error_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.error_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandEndTxnResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 1, 0, 2> CommandEndTxnResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandEndTxnResponse, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandEndTxnResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnResponse, _impl_.request_id_)}},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnResponse, _impl_.txnid_least_bits_)}},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnResponse, _impl_.txnid_most_bits_)}},
    // optional .pulsar.proto.ServerError error = 4;
    {::_pbi::TcParser::FastEr0S1,
     {32, 4, 25, PROTOBUF_FIELD_OFFSET(CommandEndTxnResponse, _impl_.error_)}},
    // optional string message = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 0, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnResponse, _impl_.message_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnResponse, _impl_.request_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnResponse, _impl_.txnid_least_bits_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnResponse, _impl_.txnid_most_bits_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.ServerError error = 4;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnResponse, _impl_.error_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string message = 5;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnResponse, _impl_.message_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {0, 26},
  }}, {{
  }},
};

::uint8_t* CommandEndTxnResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandEndTxnResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.ServerError error = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_error(), target);
  }

  // optional string message = 5;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_message();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandEndTxnResponse)
  return target;
}

::size_t CommandEndTxnResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandEndTxnResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_most_bits());
    }

    // optional .pulsar.proto.ServerError error = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandEndTxnResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandEndTxnResponse*>(
      &from));
}

void CommandEndTxnResponse::MergeFrom(const CommandEndTxnResponse& from) {
  CommandEndTxnResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandEndTxnResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.txnid_least_bits_ = from._impl_.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.txnid_most_bits_ = from._impl_.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandEndTxnResponse::CopyFrom(const CommandEndTxnResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandEndTxnResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandEndTxnResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandEndTxnResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandEndTxnResponse::InternalSwap(CommandEndTxnResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandEndTxnResponse, _impl_.error_)
      + sizeof(CommandEndTxnResponse::_impl_.error_)
      - PROTOBUF_FIELD_OFFSET(CommandEndTxnResponse, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandEndTxnResponse::GetTypeName() const {
  return "pulsar.proto.CommandEndTxnResponse";
}

// ===================================================================

class CommandEndTxnOnPartition::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandEndTxnOnPartition>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_topic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_txn_action(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_txnid_least_bits_of_low_watermark(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandEndTxnOnPartition::CommandEndTxnOnPartition(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandEndTxnOnPartition)
}
inline PROTOBUF_NDEBUG_INLINE CommandEndTxnOnPartition::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        topic_(arena, from.topic_) {}

CommandEndTxnOnPartition::CommandEndTxnOnPartition(
    ::google::protobuf::Arena* arena,
    const CommandEndTxnOnPartition& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandEndTxnOnPartition* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, txn_action_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::txn_action_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandEndTxnOnPartition)
}
inline PROTOBUF_NDEBUG_INLINE CommandEndTxnOnPartition::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        topic_(arena) {}

inline void CommandEndTxnOnPartition::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, txn_action_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::txn_action_));
}
CommandEndTxnOnPartition::~CommandEndTxnOnPartition() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandEndTxnOnPartition)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandEndTxnOnPartition::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.topic_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandEndTxnOnPartition::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandEndTxnOnPartition)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.topic_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.txn_action_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.txn_action_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandEndTxnOnPartition::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 1, 0, 2> CommandEndTxnOnPartition::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandEndTxnOnPartition_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, _impl_.request_id_)}},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, _impl_.txnid_least_bits_)}},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, _impl_.txnid_most_bits_)}},
    // optional string topic = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, _impl_.topic_)}},
    // optional .pulsar.proto.TxnAction txn_action = 5;
    {::_pbi::TcParser::FastEr0S1,
     {40, 5, 1, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, _impl_.txn_action_)}},
    // optional uint64 txnid_least_bits_of_low_watermark = 6;
    {::_pbi::TcParser::FastV64S1,
     {48, 4, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, _impl_.txnid_least_bits_of_low_watermark_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, _impl_.request_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, _impl_.txnid_least_bits_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, _impl_.txnid_most_bits_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional string topic = 4;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, _impl_.topic_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .pulsar.proto.TxnAction txn_action = 5;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, _impl_.txn_action_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional uint64 txnid_least_bits_of_low_watermark = 6;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, _impl_.txnid_least_bits_of_low_watermark_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }}, {{
    {0, 2},
  }}, {{
  }},
};

::uint8_t* CommandEndTxnOnPartition::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandEndTxnOnPartition)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_txnid_most_bits(), target);
  }

  // optional string topic = 4;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_topic();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional .pulsar.proto.TxnAction txn_action = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_txn_action(), target);
  }

  // optional uint64 txnid_least_bits_of_low_watermark = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_txnid_least_bits_of_low_watermark(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandEndTxnOnPartition)
  return target;
}

::size_t CommandEndTxnOnPartition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandEndTxnOnPartition)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string topic = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_topic());
  }

  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (cached_has_bits & 0x0000003cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_most_bits());
    }

    // optional uint64 txnid_least_bits_of_low_watermark = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_least_bits_of_low_watermark());
    }

    // optional .pulsar.proto.TxnAction txn_action = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_txn_action());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandEndTxnOnPartition::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandEndTxnOnPartition*>(
      &from));
}

void CommandEndTxnOnPartition::MergeFrom(const CommandEndTxnOnPartition& from) {
  CommandEndTxnOnPartition* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandEndTxnOnPartition)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_topic(from._internal_topic());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.txnid_least_bits_ = from._impl_.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.txnid_most_bits_ = from._impl_.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.txnid_least_bits_of_low_watermark_ = from._impl_.txnid_least_bits_of_low_watermark_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.txn_action_ = from._impl_.txn_action_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandEndTxnOnPartition::CopyFrom(const CommandEndTxnOnPartition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandEndTxnOnPartition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandEndTxnOnPartition::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandEndTxnOnPartition::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandEndTxnOnPartition::InternalSwap(CommandEndTxnOnPartition* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.topic_, &other->_impl_.topic_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, _impl_.txn_action_)
      + sizeof(CommandEndTxnOnPartition::_impl_.txn_action_)
      - PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartition, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandEndTxnOnPartition::GetTypeName() const {
  return "pulsar.proto.CommandEndTxnOnPartition";
}

// ===================================================================

class CommandEndTxnOnPartitionResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandEndTxnOnPartitionResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartitionResponse, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandEndTxnOnPartitionResponse::CommandEndTxnOnPartitionResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandEndTxnOnPartitionResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandEndTxnOnPartitionResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_(arena, from.message_) {}

CommandEndTxnOnPartitionResponse::CommandEndTxnOnPartitionResponse(
    ::google::protobuf::Arena* arena,
    const CommandEndTxnOnPartitionResponse& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandEndTxnOnPartitionResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandEndTxnOnPartitionResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandEndTxnOnPartitionResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        message_(arena) {}

inline void CommandEndTxnOnPartitionResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));
}
CommandEndTxnOnPartitionResponse::~CommandEndTxnOnPartitionResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandEndTxnOnPartitionResponse)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandEndTxnOnPartitionResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.message_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandEndTxnOnPartitionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandEndTxnOnPartitionResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.error_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.error_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandEndTxnOnPartitionResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 1, 0, 2> CommandEndTxnOnPartitionResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartitionResponse, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandEndTxnOnPartitionResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartitionResponse, _impl_.request_id_)}},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartitionResponse, _impl_.txnid_least_bits_)}},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartitionResponse, _impl_.txnid_most_bits_)}},
    // optional .pulsar.proto.ServerError error = 4;
    {::_pbi::TcParser::FastEr0S1,
     {32, 4, 25, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartitionResponse, _impl_.error_)}},
    // optional string message = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 0, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartitionResponse, _impl_.message_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartitionResponse, _impl_.request_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartitionResponse, _impl_.txnid_least_bits_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartitionResponse, _impl_.txnid_most_bits_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.ServerError error = 4;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartitionResponse, _impl_.error_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string message = 5;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartitionResponse, _impl_.message_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {0, 26},
  }}, {{
  }},
};

::uint8_t* CommandEndTxnOnPartitionResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandEndTxnOnPartitionResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.ServerError error = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_error(), target);
  }

  // optional string message = 5;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_message();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandEndTxnOnPartitionResponse)
  return target;
}

::size_t CommandEndTxnOnPartitionResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandEndTxnOnPartitionResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_most_bits());
    }

    // optional .pulsar.proto.ServerError error = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandEndTxnOnPartitionResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandEndTxnOnPartitionResponse*>(
      &from));
}

void CommandEndTxnOnPartitionResponse::MergeFrom(const CommandEndTxnOnPartitionResponse& from) {
  CommandEndTxnOnPartitionResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandEndTxnOnPartitionResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.txnid_least_bits_ = from._impl_.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.txnid_most_bits_ = from._impl_.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandEndTxnOnPartitionResponse::CopyFrom(const CommandEndTxnOnPartitionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandEndTxnOnPartitionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandEndTxnOnPartitionResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandEndTxnOnPartitionResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandEndTxnOnPartitionResponse::InternalSwap(CommandEndTxnOnPartitionResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartitionResponse, _impl_.error_)
      + sizeof(CommandEndTxnOnPartitionResponse::_impl_.error_)
      - PROTOBUF_FIELD_OFFSET(CommandEndTxnOnPartitionResponse, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandEndTxnOnPartitionResponse::GetTypeName() const {
  return "pulsar.proto.CommandEndTxnOnPartitionResponse";
}

// ===================================================================

class CommandEndTxnOnSubscription::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandEndTxnOnSubscription>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::pulsar::proto::Subscription& subscription(const CommandEndTxnOnSubscription* msg);
  static void set_has_subscription(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_txn_action(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_txnid_least_bits_of_low_watermark(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::pulsar::proto::Subscription& CommandEndTxnOnSubscription::_Internal::subscription(const CommandEndTxnOnSubscription* msg) {
  return *msg->_impl_.subscription_;
}
CommandEndTxnOnSubscription::CommandEndTxnOnSubscription(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandEndTxnOnSubscription)
}
inline PROTOBUF_NDEBUG_INLINE CommandEndTxnOnSubscription::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

CommandEndTxnOnSubscription::CommandEndTxnOnSubscription(
    ::google::protobuf::Arena* arena,
    const CommandEndTxnOnSubscription& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandEndTxnOnSubscription* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.subscription_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::pulsar::proto::Subscription>(arena, *from._impl_.subscription_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, txn_action_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::txn_action_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandEndTxnOnSubscription)
}
inline PROTOBUF_NDEBUG_INLINE CommandEndTxnOnSubscription::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CommandEndTxnOnSubscription::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, subscription_),
           0,
           offsetof(Impl_, txn_action_) -
               offsetof(Impl_, subscription_) +
               sizeof(Impl_::txn_action_));
}
CommandEndTxnOnSubscription::~CommandEndTxnOnSubscription() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandEndTxnOnSubscription)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandEndTxnOnSubscription::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.subscription_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandEndTxnOnSubscription::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandEndTxnOnSubscription)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.subscription_ != nullptr);
    _impl_.subscription_->Clear();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.txn_action_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.txn_action_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandEndTxnOnSubscription::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 2, 0, 2> CommandEndTxnOnSubscription::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandEndTxnOnSubscription_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, _impl_.request_id_)}},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, _impl_.txnid_least_bits_)}},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, _impl_.txnid_most_bits_)}},
    // optional .pulsar.proto.Subscription subscription = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, _impl_.subscription_)}},
    // optional .pulsar.proto.TxnAction txn_action = 5;
    {::_pbi::TcParser::FastEr0S1,
     {40, 5, 1, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, _impl_.txn_action_)}},
    // optional uint64 txnid_least_bits_of_low_watermark = 6;
    {::_pbi::TcParser::FastV64S1,
     {48, 4, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, _impl_.txnid_least_bits_of_low_watermark_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, _impl_.request_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, _impl_.txnid_least_bits_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, _impl_.txnid_most_bits_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.Subscription subscription = 4;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, _impl_.subscription_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.TxnAction txn_action = 5;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, _impl_.txn_action_), _Internal::kHasBitsOffset + 5, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional uint64 txnid_least_bits_of_low_watermark = 6;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, _impl_.txnid_least_bits_of_low_watermark_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pulsar::proto::Subscription>()},
    {0, 2},
  }}, {{
  }},
};

::uint8_t* CommandEndTxnOnSubscription::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandEndTxnOnSubscription)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.Subscription subscription = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, _Internal::subscription(this),
        _Internal::subscription(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.TxnAction txn_action = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_txn_action(), target);
  }

  // optional uint64 txnid_least_bits_of_low_watermark = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_txnid_least_bits_of_low_watermark(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandEndTxnOnSubscription)
  return target;
}

::size_t CommandEndTxnOnSubscription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandEndTxnOnSubscription)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .pulsar.proto.Subscription subscription = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.subscription_);
  }

  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (cached_has_bits & 0x0000003cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_most_bits());
    }

    // optional uint64 txnid_least_bits_of_low_watermark = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_least_bits_of_low_watermark());
    }

    // optional .pulsar.proto.TxnAction txn_action = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_txn_action());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandEndTxnOnSubscription::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandEndTxnOnSubscription*>(
      &from));
}

void CommandEndTxnOnSubscription::MergeFrom(const CommandEndTxnOnSubscription& from) {
  CommandEndTxnOnSubscription* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandEndTxnOnSubscription)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_subscription()->::pulsar::proto::Subscription::MergeFrom(
          from._internal_subscription());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.txnid_least_bits_ = from._impl_.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.txnid_most_bits_ = from._impl_.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.txnid_least_bits_of_low_watermark_ = from._impl_.txnid_least_bits_of_low_watermark_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.txn_action_ = from._impl_.txn_action_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandEndTxnOnSubscription::CopyFrom(const CommandEndTxnOnSubscription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandEndTxnOnSubscription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandEndTxnOnSubscription::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.subscription_->IsInitialized()) return false;
  }
  return true;
}

::_pbi::CachedSize* CommandEndTxnOnSubscription::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandEndTxnOnSubscription::InternalSwap(CommandEndTxnOnSubscription* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, _impl_.txn_action_)
      + sizeof(CommandEndTxnOnSubscription::_impl_.txn_action_)
      - PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscription, _impl_.subscription_)>(
          reinterpret_cast<char*>(&_impl_.subscription_),
          reinterpret_cast<char*>(&other->_impl_.subscription_));
}

std::string CommandEndTxnOnSubscription::GetTypeName() const {
  return "pulsar.proto.CommandEndTxnOnSubscription";
}

// ===================================================================

class CommandEndTxnOnSubscriptionResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandEndTxnOnSubscriptionResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscriptionResponse, _impl_._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_txnid_least_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txnid_most_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CommandEndTxnOnSubscriptionResponse::CommandEndTxnOnSubscriptionResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandEndTxnOnSubscriptionResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_(arena, from.message_) {}

CommandEndTxnOnSubscriptionResponse::CommandEndTxnOnSubscriptionResponse(
    ::google::protobuf::Arena* arena,
    const CommandEndTxnOnSubscriptionResponse& from)
    : ::google::protobuf::MessageLite(arena) {
  CommandEndTxnOnSubscriptionResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, request_id_),
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
}
inline PROTOBUF_NDEBUG_INLINE CommandEndTxnOnSubscriptionResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        message_(arena) {}

inline void CommandEndTxnOnSubscriptionResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, request_id_),
           0,
           offsetof(Impl_, error_) -
               offsetof(Impl_, request_id_) +
               sizeof(Impl_::error_));
}
CommandEndTxnOnSubscriptionResponse::~CommandEndTxnOnSubscriptionResponse() {
  // @@protoc_insertion_point(destructor:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void CommandEndTxnOnSubscriptionResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.message_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CommandEndTxnOnSubscriptionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.request_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.error_) -
        reinterpret_cast<char*>(&_impl_.request_id_)) + sizeof(_impl_.error_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommandEndTxnOnSubscriptionResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 1, 0, 2> CommandEndTxnOnSubscriptionResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscriptionResponse, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CommandEndTxnOnSubscriptionResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint64 request_id = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscriptionResponse, _impl_.request_id_)}},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscriptionResponse, _impl_.txnid_least_bits_)}},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {::_pbi::TcParser::FastV64S1,
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscriptionResponse, _impl_.txnid_most_bits_)}},
    // optional .pulsar.proto.ServerError error = 4;
    {::_pbi::TcParser::FastEr0S1,
     {32, 4, 25, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscriptionResponse, _impl_.error_)}},
    // optional string message = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 0, 0, PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscriptionResponse, _impl_.message_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint64 request_id = 1;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscriptionResponse, _impl_.request_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_least_bits = 2 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscriptionResponse, _impl_.txnid_least_bits_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 txnid_most_bits = 3 [default = 0];
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscriptionResponse, _impl_.txnid_most_bits_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .pulsar.proto.ServerError error = 4;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscriptionResponse, _impl_.error_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string message = 5;
    {PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscriptionResponse, _impl_.message_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {0, 26},
  }}, {{
  }},
};

::uint8_t* CommandEndTxnOnSubscriptionResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_request_id(), target);
  }

  // optional uint64 txnid_least_bits = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_txnid_least_bits(), target);
  }

  // optional uint64 txnid_most_bits = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_txnid_most_bits(), target);
  }

  // optional .pulsar.proto.ServerError error = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_error(), target);
  }

  // optional string message = 5;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_message();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
  return target;
}

::size_t CommandEndTxnOnSubscriptionResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  // required uint64 request_id = 1;
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_request_id());
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional uint64 txnid_least_bits = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_least_bits());
    }

    // optional uint64 txnid_most_bits = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_txnid_most_bits());
    }

    // optional .pulsar.proto.ServerError error = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void CommandEndTxnOnSubscriptionResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommandEndTxnOnSubscriptionResponse*>(
      &from));
}

void CommandEndTxnOnSubscriptionResponse::MergeFrom(const CommandEndTxnOnSubscriptionResponse& from) {
  CommandEndTxnOnSubscriptionResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.request_id_ = from._impl_.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.txnid_least_bits_ = from._impl_.txnid_least_bits_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.txnid_most_bits_ = from._impl_.txnid_most_bits_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommandEndTxnOnSubscriptionResponse::CopyFrom(const CommandEndTxnOnSubscriptionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.CommandEndTxnOnSubscriptionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CommandEndTxnOnSubscriptionResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  return true;
}

::_pbi::CachedSize* CommandEndTxnOnSubscriptionResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CommandEndTxnOnSubscriptionResponse::InternalSwap(CommandEndTxnOnSubscriptionResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscriptionResponse, _impl_.error_)
      + sizeof(CommandEndTxnOnSubscriptionResponse::_impl_.error_)
      - PROTOBUF_FIELD_OFFSET(CommandEndTxnOnSubscriptionResponse, _impl_.request_id_)>(
          reinterpret_cast<char*>(&_impl_.request_id_),
          reinterpret_cast<char*>(&other->_impl_.request_id_));
}

std::string CommandEndTxnOnSubscriptionResponse::GetTypeName() const {
  return "pulsar.proto.CommandEndTxnOnSubscriptionResponse";
}

// ===================================================================

class BaseCommand::_Internal {
 public:
  using HasBits = decltype(std::declval<BaseCommand>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[1] |= 67108864u;
  }
  static const ::pulsar::proto::CommandConnect& connect(const BaseCommand* msg);
  static void set_has_connect(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pulsar::proto::CommandConnected& connected(const BaseCommand* msg);
  static void set_has_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pulsar::proto::CommandSubscribe& subscribe(const BaseCommand* msg);
  static void set_has_subscribe(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::pulsar::proto::CommandProducer& producer(const BaseCommand* msg);
  static void set_has_producer(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::pulsar::proto::CommandSend& send(const BaseCommand* msg);
  static void set_has_send(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::pulsar::proto::CommandSendReceipt& send_receipt(const BaseCommand* msg);
  static void set_has_send_receipt(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::pulsar::proto::CommandSendError& send_error(const BaseCommand* msg);
  static void set_has_send_error(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::pulsar::proto::CommandMessage& message(const BaseCommand* msg);
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::pulsar::proto::CommandAck& ack(const BaseCommand* msg);
  static void set_has_ack(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::pulsar::proto::CommandFlow& flow(const BaseCommand* msg);
  static void set_has_flow(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::pulsar::proto::CommandUnsubscribe& unsubscribe(const BaseCommand* msg);
  static void set_has_unsubscribe(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::pulsar::proto::CommandSuccess& success(const BaseCommand* msg);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::pulsar::proto::CommandError& error(const BaseCommand* msg);
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::pulsar::proto::CommandCloseProducer& close_producer(const BaseCommand* msg);
  static void set_has_close_producer(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::pulsar::proto::CommandCloseConsumer& close_consumer(const BaseCommand* msg);
  static void set_has_close_consumer(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::pulsar::proto::CommandProducerSuccess& producer_success(const BaseCommand* msg);
  static void set_has_producer_success(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::pulsar::proto::CommandPing& ping(const BaseCommand* msg);
  static void set_has_ping(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::pulsar::proto::CommandPong& pong(const BaseCommand* msg);
  static void set_has_pong(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages& redeliverunacknowledgedmessages(const BaseCommand* msg);
  static void set_has_redeliverunacknowledgedmessages(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::pulsar::proto::CommandPartitionedTopicMetadata& partitionmetadata(const BaseCommand* msg);
  static void set_has_partitionmetadata(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::pulsar::proto::CommandPartitionedTopicMetadataResponse& partitionmetadataresponse(const BaseCommand* msg);
  static void set_has_partitionmetadataresponse(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::pulsar::proto::CommandLookupTopic& lookuptopic(const BaseCommand* msg);
  static void set_has_lookuptopic(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::pulsar::proto::CommandLookupTopicResponse& lookuptopicresponse(const BaseCommand* msg);
  static void set_has_lookuptopicresponse(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static const ::pulsar::proto::CommandConsumerStats& consumerstats(const BaseCommand* msg);
  static void set_has_consumerstats(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static const ::pulsar::proto::CommandConsumerStatsResponse& consumerstatsresponse(const BaseCommand* msg);
  static void set_has_consumerstatsresponse(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static const ::pulsar::proto::CommandReachedEndOfTopic& reachedendoftopic(const BaseCommand* msg);
  static void set_has_reachedendoftopic(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static const ::pulsar::proto::CommandSeek& seek(const BaseCommand* msg);
  static void set_has_seek(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static const ::pulsar::proto::CommandGetLastMessageId& getlastmessageid(const BaseCommand* msg);
  static void set_has_getlastmessageid(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static const ::pulsar::proto::CommandGetLastMessageIdResponse& getlastmessageidresponse(const BaseCommand* msg);
  static void set_has_getlastmessageidresponse(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static const ::pulsar::proto::CommandActiveConsumerChange& active_consumer_change(const BaseCommand* msg);
  static void set_has_active_consumer_change(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static const ::pulsar::proto::CommandGetTopicsOfNamespace& gettopicsofnamespace(const BaseCommand* msg);
  static void set_has_gettopicsofnamespace(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse& gettopicsofnamespaceresponse(const BaseCommand* msg);
  static void set_has_gettopicsofnamespaceresponse(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static const ::pulsar::proto::CommandGetSchema& getschema(const BaseCommand* msg);
  static void set_has_getschema(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static const ::pulsar::proto::CommandGetSchemaResponse& getschemaresponse(const BaseCommand* msg);
  static void set_has_getschemaresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static const ::pulsar::proto::CommandAuthChallenge& authchallenge(const BaseCommand* msg);
  static void set_has_authchallenge(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static const ::pulsar::proto::CommandAuthResponse& authresponse(const BaseCommand* msg);
  static void set_has_authresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static const ::pulsar::proto::CommandAckResponse& ackresponse(const BaseCommand* msg);
  static void set_has_ackresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static const ::pulsar::proto::CommandGetOrCreateSchema& getorcreateschema(const BaseCommand* msg);
  static void set_has_getorcreateschema(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static const ::pulsar::proto::CommandGetOrCreateSchemaResponse& getorcreateschemaresponse(const BaseCommand* msg);
  static void set_has_getorcreateschemaresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static const ::pulsar::proto::CommandNewTxn& newtxn(const BaseCommand* msg);
  static void set_has_newtxn(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static const ::pulsar::proto::CommandNewTxnResponse& newtxnresponse(const BaseCommand* msg);
  static void set_has_newtxnresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static const ::pulsar::proto::CommandAddPartitionToTxn& addpartitiontotxn(const BaseCommand* msg);
  static void set_has_addpartitiontotxn(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static const ::pulsar::proto::CommandAddPartitionToTxnResponse& addpartitiontotxnresponse(const BaseCommand* msg);
  static void set_has_addpartitiontotxnresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static const ::pulsar::proto::CommandAddSubscriptionToTxn& addsubscriptiontotxn(const BaseCommand* msg);
  static void set_has_addsubscriptiontotxn(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static const ::pulsar::proto::CommandAddSubscriptionToTxnResponse& addsubscriptiontotxnresponse(const BaseCommand* msg);
  static void set_has_addsubscriptiontotxnresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static const ::pulsar::proto::CommandEndTxn& endtxn(const BaseCommand* msg);
  static void set_has_endtxn(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static const ::pulsar::proto::CommandEndTxnResponse& endtxnresponse(const BaseCommand* msg);
  static void set_has_endtxnresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
  static const ::pulsar::proto::CommandEndTxnOnPartition& endtxnonpartition(const BaseCommand* msg);
  static void set_has_endtxnonpartition(HasBits* has_bits) {
    (*has_bits)[1] |= 32768u;
  }
  static const ::pulsar::proto::CommandEndTxnOnPartitionResponse& endtxnonpartitionresponse(const BaseCommand* msg);
  static void set_has_endtxnonpartitionresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 65536u;
  }
  static const ::pulsar::proto::CommandEndTxnOnSubscription& endtxnonsubscription(const BaseCommand* msg);
  static void set_has_endtxnonsubscription(HasBits* has_bits) {
    (*has_bits)[1] |= 131072u;
  }
  static const ::pulsar::proto::CommandEndTxnOnSubscriptionResponse& endtxnonsubscriptionresponse(const BaseCommand* msg);
  static void set_has_endtxnonsubscriptionresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 262144u;
  }
  static const ::pulsar::proto::CommandTcClientConnectRequest& tcclientconnectrequest(const BaseCommand* msg);
  static void set_has_tcclientconnectrequest(HasBits* has_bits) {
    (*has_bits)[1] |= 524288u;
  }
  static const ::pulsar::proto::CommandTcClientConnectResponse& tcclientconnectresponse(const BaseCommand* msg);
  static void set_has_tcclientconnectresponse(HasBits* has_bits) {
    (*has_bits)[1] |= 1048576u;
  }
  static const ::pulsar::proto::CommandWatchTopicList& watchtopiclist(const BaseCommand* msg);
  static void set_has_watchtopiclist(HasBits* has_bits) {
    (*has_bits)[1] |= 2097152u;
  }
  static const ::pulsar::proto::CommandWatchTopicListSuccess& watchtopiclistsuccess(const BaseCommand* msg);
  static void set_has_watchtopiclistsuccess(HasBits* has_bits) {
    (*has_bits)[1] |= 4194304u;
  }
  static const ::pulsar::proto::CommandWatchTopicUpdate& watchtopicupdate(const BaseCommand* msg);
  static void set_has_watchtopicupdate(HasBits* has_bits) {
    (*has_bits)[1] |= 8388608u;
  }
  static const ::pulsar::proto::CommandWatchTopicListClose& watchtopiclistclose(const BaseCommand* msg);
  static void set_has_watchtopiclistclose(HasBits* has_bits) {
    (*has_bits)[1] |= 16777216u;
  }
  static const ::pulsar::proto::CommandTopicMigrated& topicmigrated(const BaseCommand* msg);
  static void set_has_topicmigrated(HasBits* has_bits) {
    (*has_bits)[1] |= 33554432u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[1] & 0x04000000) ^ 0x04000000) != 0;
  }
};

const ::pulsar::proto::CommandConnect& BaseCommand::_Internal::connect(const BaseCommand* msg) {
  return *msg->_impl_.connect_;
}
const ::pulsar::proto::CommandConnected& BaseCommand::_Internal::connected(const BaseCommand* msg) {
  return *msg->_impl_.connected_;
}
const ::pulsar::proto::CommandSubscribe& BaseCommand::_Internal::subscribe(const BaseCommand* msg) {
  return *msg->_impl_.subscribe_;
}
const ::pulsar::proto::CommandProducer& BaseCommand::_Internal::producer(const BaseCommand* msg) {
  return *msg->_impl_.producer_;
}
const ::pulsar::proto::CommandSend& BaseCommand::_Internal::send(const BaseCommand* msg) {
  return *msg->_impl_.send_;
}
const ::pulsar::proto::CommandSendReceipt& BaseCommand::_Internal::send_receipt(const BaseCommand* msg) {
  return *msg->_impl_.send_receipt_;
}
const ::pulsar::proto::CommandSendError& BaseCommand::_Internal::send_error(const BaseCommand* msg) {
  return *msg->_impl_.send_error_;
}
const ::pulsar::proto::CommandMessage& BaseCommand::_Internal::message(const BaseCommand* msg) {
  return *msg->_impl_.message_;
}
const ::pulsar::proto::CommandAck& BaseCommand::_Internal::ack(const BaseCommand* msg) {
  return *msg->_impl_.ack_;
}
const ::pulsar::proto::CommandFlow& BaseCommand::_Internal::flow(const BaseCommand* msg) {
  return *msg->_impl_.flow_;
}
const ::pulsar::proto::CommandUnsubscribe& BaseCommand::_Internal::unsubscribe(const BaseCommand* msg) {
  return *msg->_impl_.unsubscribe_;
}
const ::pulsar::proto::CommandSuccess& BaseCommand::_Internal::success(const BaseCommand* msg) {
  return *msg->_impl_.success_;
}
const ::pulsar::proto::CommandError& BaseCommand::_Internal::error(const BaseCommand* msg) {
  return *msg->_impl_.error_;
}
const ::pulsar::proto::CommandCloseProducer& BaseCommand::_Internal::close_producer(const BaseCommand* msg) {
  return *msg->_impl_.close_producer_;
}
const ::pulsar::proto::CommandCloseConsumer& BaseCommand::_Internal::close_consumer(const BaseCommand* msg) {
  return *msg->_impl_.close_consumer_;
}
const ::pulsar::proto::CommandProducerSuccess& BaseCommand::_Internal::producer_success(const BaseCommand* msg) {
  return *msg->_impl_.producer_success_;
}
const ::pulsar::proto::CommandPing& BaseCommand::_Internal::ping(const BaseCommand* msg) {
  return *msg->_impl_.ping_;
}
const ::pulsar::proto::CommandPong& BaseCommand::_Internal::pong(const BaseCommand* msg) {
  return *msg->_impl_.pong_;
}
const ::pulsar::proto::CommandRedeliverUnacknowledgedMessages& BaseCommand::_Internal::redeliverunacknowledgedmessages(const BaseCommand* msg) {
  return *msg->_impl_.redeliverunacknowledgedmessages_;
}
const ::pulsar::proto::CommandPartitionedTopicMetadata& BaseCommand::_Internal::partitionmetadata(const BaseCommand* msg) {
  return *msg->_impl_.partitionmetadata_;
}
const ::pulsar::proto::CommandPartitionedTopicMetadataResponse& BaseCommand::_Internal::partitionmetadataresponse(const BaseCommand* msg) {
  return *msg->_impl_.partitionmetadataresponse_;
}
const ::pulsar::proto::CommandLookupTopic& BaseCommand::_Internal::lookuptopic(const BaseCommand* msg) {
  return *msg->_impl_.lookuptopic_;
}
const ::pulsar::proto::CommandLookupTopicResponse& BaseCommand::_Internal::lookuptopicresponse(const BaseCommand* msg) {
  return *msg->_impl_.lookuptopicresponse_;
}
const ::pulsar::proto::CommandConsumerStats& BaseCommand::_Internal::consumerstats(const BaseCommand* msg) {
  return *msg->_impl_.consumerstats_;
}
const ::pulsar::proto::CommandConsumerStatsResponse& BaseCommand::_Internal::consumerstatsresponse(const BaseCommand* msg) {
  return *msg->_impl_.consumerstatsresponse_;
}
const ::pulsar::proto::CommandReachedEndOfTopic& BaseCommand::_Internal::reachedendoftopic(const BaseCommand* msg) {
  return *msg->_impl_.reachedendoftopic_;
}
const ::pulsar::proto::CommandSeek& BaseCommand::_Internal::seek(const BaseCommand* msg) {
  return *msg->_impl_.seek_;
}
const ::pulsar::proto::CommandGetLastMessageId& BaseCommand::_Internal::getlastmessageid(const BaseCommand* msg) {
  return *msg->_impl_.getlastmessageid_;
}
const ::pulsar::proto::CommandGetLastMessageIdResponse& BaseCommand::_Internal::getlastmessageidresponse(const BaseCommand* msg) {
  return *msg->_impl_.getlastmessageidresponse_;
}
const ::pulsar::proto::CommandActiveConsumerChange& BaseCommand::_Internal::active_consumer_change(const BaseCommand* msg) {
  return *msg->_impl_.active_consumer_change_;
}
const ::pulsar::proto::CommandGetTopicsOfNamespace& BaseCommand::_Internal::gettopicsofnamespace(const BaseCommand* msg) {
  return *msg->_impl_.gettopicsofnamespace_;
}
const ::pulsar::proto::CommandGetTopicsOfNamespaceResponse& BaseCommand::_Internal::gettopicsofnamespaceresponse(const BaseCommand* msg) {
  return *msg->_impl_.gettopicsofnamespaceresponse_;
}
const ::pulsar::proto::CommandGetSchema& BaseCommand::_Internal::getschema(const BaseCommand* msg) {
  return *msg->_impl_.getschema_;
}
const ::pulsar::proto::CommandGetSchemaResponse& BaseCommand::_Internal::getschemaresponse(const BaseCommand* msg) {
  return *msg->_impl_.getschemaresponse_;
}
const ::pulsar::proto::CommandAuthChallenge& BaseCommand::_Internal::authchallenge(const BaseCommand* msg) {
  return *msg->_impl_.authchallenge_;
}
const ::pulsar::proto::CommandAuthResponse& BaseCommand::_Internal::authresponse(const BaseCommand* msg) {
  return *msg->_impl_.authresponse_;
}
const ::pulsar::proto::CommandAckResponse& BaseCommand::_Internal::ackresponse(const BaseCommand* msg) {
  return *msg->_impl_.ackresponse_;
}
const ::pulsar::proto::CommandGetOrCreateSchema& BaseCommand::_Internal::getorcreateschema(const BaseCommand* msg) {
  return *msg->_impl_.getorcreateschema_;
}
const ::pulsar::proto::CommandGetOrCreateSchemaResponse& BaseCommand::_Internal::getorcreateschemaresponse(const BaseCommand* msg) {
  return *msg->_impl_.getorcreateschemaresponse_;
}
const ::pulsar::proto::CommandNewTxn& BaseCommand::_Internal::newtxn(const BaseCommand* msg) {
  return *msg->_impl_.newtxn_;
}
const ::pulsar::proto::CommandNewTxnResponse& BaseCommand::_Internal::newtxnresponse(const BaseCommand* msg) {
  return *msg->_impl_.newtxnresponse_;
}
const ::pulsar::proto::CommandAddPartitionToTxn& BaseCommand::_Internal::addpartitiontotxn(const BaseCommand* msg) {
  return *msg->_impl_.addpartitiontotxn_;
}
const ::pulsar::proto::CommandAddPartitionToTxnResponse& BaseCommand::_Internal::addpartitiontotxnresponse(const BaseCommand* msg) {
  return *msg->_impl_.addpartitiontotxnresponse_;
}
const ::pulsar::proto::CommandAddSubscriptionToTxn& BaseCommand::_Internal::addsubscriptiontotxn(const BaseCommand* msg) {
  return *msg->_impl_.addsubscriptiontotxn_;
}
const ::pulsar::proto::CommandAddSubscriptionToTxnResponse& BaseCommand::_Internal::addsubscriptiontotxnresponse(const BaseCommand* msg) {
  return *msg->_impl_.addsubscriptiontotxnresponse_;
}
const ::pulsar::proto::CommandEndTxn& BaseCommand::_Internal::endtxn(const BaseCommand* msg) {
  return *msg->_impl_.endtxn_;
}
const ::pulsar::proto::CommandEndTxnResponse& BaseCommand::_Internal::endtxnresponse(const BaseCommand* msg) {
  return *msg->_impl_.endtxnresponse_;
}
const ::pulsar::proto::CommandEndTxnOnPartition& BaseCommand::_Internal::endtxnonpartition(const BaseCommand* msg) {
  return *msg->_impl_.endtxnonpartition_;
}
const ::pulsar::proto::CommandEndTxnOnPartitionResponse& BaseCommand::_Internal::endtxnonpartitionresponse(const BaseCommand* msg) {
  return *msg->_impl_.endtxnonpartitionresponse_;
}
const ::pulsar::proto::CommandEndTxnOnSubscription& BaseCommand::_Internal::endtxnonsubscription(const BaseCommand* msg) {
  return *msg->_impl_.endtxnonsubscription_;
}
const ::pulsar::proto::CommandEndTxnOnSubscriptionResponse& BaseCommand::_Internal::endtxnonsubscriptionresponse(const BaseCommand* msg) {
  return *msg->_impl_.endtxnonsubscriptionresponse_;
}
const ::pulsar::proto::CommandTcClientConnectRequest& BaseCommand::_Internal::tcclientconnectrequest(const BaseCommand* msg) {
  return *msg->_impl_.tcclientconnectrequest_;
}
const ::pulsar::proto::CommandTcClientConnectResponse& BaseCommand::_Internal::tcclientconnectresponse(const BaseCommand* msg) {
  return *msg->_impl_.tcclientconnectresponse_;
}
const ::pulsar::proto::CommandWatchTopicList& BaseCommand::_Internal::watchtopiclist(const BaseCommand* msg) {
  return *msg->_impl_.watchtopiclist_;
}
const ::pulsar::proto::CommandWatchTopicListSuccess& BaseCommand::_Internal::watchtopiclistsuccess(const BaseCommand* msg) {
  return *msg->_impl_.watchtopiclistsuccess_;
}
const ::pulsar::proto::CommandWatchTopicUpdate& BaseCommand::_Internal::watchtopicupdate(const BaseCommand* msg) {
  return *msg->_impl_.watchtopicupdate_;
}
const ::pulsar::proto::CommandWatchTopicListClose& BaseCommand::_Internal::watchtopiclistclose(const BaseCommand* msg) {
  return *msg->_impl_.watchtopiclistclose_;
}
const ::pulsar::proto::CommandTopicMigrated& BaseCommand::_Internal::topicmigrated(const BaseCommand* msg) {
  return *msg->_impl_.topicmigrated_;
}
BaseCommand::BaseCommand(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pulsar.proto.BaseCommand)
}
inline PROTOBUF_NDEBUG_INLINE BaseCommand::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

BaseCommand::BaseCommand(
    ::google::protobuf::Arena* arena,
    const BaseCommand& from)
    : ::google::protobuf::MessageLite(arena) {
  BaseCommand* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.connect_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::pulsar::proto::CommandConnect>(arena, *from._impl_.connect_)
                : nullptr;
  _impl_.connected_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::pulsar::proto::CommandConnected>(arena, *from._impl_.connected_)
                : nullptr;
  _impl_.subscribe_ = (cached_has_bits & 0x00000004u)
                ? CreateMaybeMessage<::pulsar::proto::CommandSubscribe>(arena, *from._impl_.subscribe_)
                : nullptr;
  _impl_.producer_ = (cached_has_bits & 0x00000008u)
                ? CreateMaybeMessage<::pulsar::proto::CommandProducer>(arena, *from._impl_.producer_)
                : nullptr;
  _impl_.send_ = (cached_has_bits & 0x00000010u)
                ? CreateMaybeMessage<::pulsar::proto::CommandSend>(arena, *from._impl_.send_)
                : nullptr;
  _impl_.send_receipt_ = (cached_has_bits & 0x00000020u)
                ? CreateMaybeMessage<::pulsar::proto::CommandSendReceipt>(arena, *from._impl_.send_receipt_)
                : nullptr;
  _impl_.send_error_ = (cached_has_bits & 0x00000040u)
                ? CreateMaybeMessage<::pulsar::proto::CommandSendError>(arena, *from._impl_.send_error_)
                : nullptr;
  _impl_.message_ = (cached_has_bits & 0x00000080u)
                ? CreateMaybeMessage<::pulsar::proto::CommandMessage>(arena, *from._impl_.message_)
                : nullptr;
  _impl_.ack_ = (cached_has_bits & 0x00000100u)
                ? CreateMaybeMessage<::pulsar::proto::CommandAck>(arena, *from._impl_.ack_)
                : nullptr;
  _impl_.flow_ = (cached_has_bits & 0x00000200u)
                ? CreateMaybeMessage<::pulsar::proto::CommandFlow>(arena, *from._impl_.flow_)
                : nullptr;
  _impl_.unsubscribe_ = (cached_has_bits & 0x00000400u)
                ? CreateMaybeMessage<::pulsar::proto::CommandUnsubscribe>(arena, *from._impl_.unsubscribe_)
                : nullptr;
  _impl_.success_ = (cached_has_bits & 0x00000800u)
                ? CreateMaybeMessage<::pulsar::proto::CommandSuccess>(arena, *from._impl_.success_)
                : nullptr;
  _impl_.error_ = (cached_has_bits & 0x00001000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandError>(arena, *from._impl_.error_)
                : nullptr;
  _impl_.close_producer_ = (cached_has_bits & 0x00002000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandCloseProducer>(arena, *from._impl_.close_producer_)
                : nullptr;
  _impl_.close_consumer_ = (cached_has_bits & 0x00004000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandCloseConsumer>(arena, *from._impl_.close_consumer_)
                : nullptr;
  _impl_.producer_success_ = (cached_has_bits & 0x00008000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandProducerSuccess>(arena, *from._impl_.producer_success_)
                : nullptr;
  _impl_.ping_ = (cached_has_bits & 0x00010000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandPing>(arena, *from._impl_.ping_)
                : nullptr;
  _impl_.pong_ = (cached_has_bits & 0x00020000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandPong>(arena, *from._impl_.pong_)
                : nullptr;
  _impl_.redeliverunacknowledgedmessages_ = (cached_has_bits & 0x00040000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandRedeliverUnacknowledgedMessages>(arena, *from._impl_.redeliverunacknowledgedmessages_)
                : nullptr;
  _impl_.partitionmetadata_ = (cached_has_bits & 0x00080000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandPartitionedTopicMetadata>(arena, *from._impl_.partitionmetadata_)
                : nullptr;
  _impl_.partitionmetadataresponse_ = (cached_has_bits & 0x00100000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandPartitionedTopicMetadataResponse>(arena, *from._impl_.partitionmetadataresponse_)
                : nullptr;
  _impl_.lookuptopic_ = (cached_has_bits & 0x00200000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandLookupTopic>(arena, *from._impl_.lookuptopic_)
                : nullptr;
  _impl_.lookuptopicresponse_ = (cached_has_bits & 0x00400000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandLookupTopicResponse>(arena, *from._impl_.lookuptopicresponse_)
                : nullptr;
  _impl_.consumerstats_ = (cached_has_bits & 0x00800000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandConsumerStats>(arena, *from._impl_.consumerstats_)
                : nullptr;
  _impl_.consumerstatsresponse_ = (cached_has_bits & 0x01000000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandConsumerStatsResponse>(arena, *from._impl_.consumerstatsresponse_)
                : nullptr;
  _impl_.reachedendoftopic_ = (cached_has_bits & 0x02000000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandReachedEndOfTopic>(arena, *from._impl_.reachedendoftopic_)
                : nullptr;
  _impl_.seek_ = (cached_has_bits & 0x04000000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandSeek>(arena, *from._impl_.seek_)
                : nullptr;
  _impl_.getlastmessageid_ = (cached_has_bits & 0x08000000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandGetLastMessageId>(arena, *from._impl_.getlastmessageid_)
                : nullptr;
  _impl_.getlastmessageidresponse_ = (cached_has_bits & 0x10000000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandGetLastMessageIdResponse>(arena, *from._impl_.getlastmessageidresponse_)
                : nullptr;
  _impl_.active_consumer_change_ = (cached_has_bits & 0x20000000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandActiveConsumerChange>(arena, *from._impl_.active_consumer_change_)
                : nullptr;
  _impl_.gettopicsofnamespace_ = (cached_has_bits & 0x40000000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandGetTopicsOfNamespace>(arena, *from._impl_.gettopicsofnamespace_)
                : nullptr;
  _impl_.gettopicsofnamespaceresponse_ = (cached_has_bits & 0x80000000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandGetTopicsOfNamespaceResponse>(arena, *from._impl_.gettopicsofnamespaceresponse_)
                : nullptr;
  cached_has_bits = _impl_._has_bits_[1];
  _impl_.getschema_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::pulsar::proto::CommandGetSchema>(arena, *from._impl_.getschema_)
                : nullptr;
  _impl_.getschemaresponse_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::pulsar::proto::CommandGetSchemaResponse>(arena, *from._impl_.getschemaresponse_)
                : nullptr;
  _impl_.authchallenge_ = (cached_has_bits & 0x00000004u)
                ? CreateMaybeMessage<::pulsar::proto::CommandAuthChallenge>(arena, *from._impl_.authchallenge_)
                : nullptr;
  _impl_.authresponse_ = (cached_has_bits & 0x00000008u)
                ? CreateMaybeMessage<::pulsar::proto::CommandAuthResponse>(arena, *from._impl_.authresponse_)
                : nullptr;
  _impl_.ackresponse_ = (cached_has_bits & 0x00000010u)
                ? CreateMaybeMessage<::pulsar::proto::CommandAckResponse>(arena, *from._impl_.ackresponse_)
                : nullptr;
  _impl_.getorcreateschema_ = (cached_has_bits & 0x00000020u)
                ? CreateMaybeMessage<::pulsar::proto::CommandGetOrCreateSchema>(arena, *from._impl_.getorcreateschema_)
                : nullptr;
  _impl_.getorcreateschemaresponse_ = (cached_has_bits & 0x00000040u)
                ? CreateMaybeMessage<::pulsar::proto::CommandGetOrCreateSchemaResponse>(arena, *from._impl_.getorcreateschemaresponse_)
                : nullptr;
  _impl_.newtxn_ = (cached_has_bits & 0x00000080u)
                ? CreateMaybeMessage<::pulsar::proto::CommandNewTxn>(arena, *from._impl_.newtxn_)
                : nullptr;
  _impl_.newtxnresponse_ = (cached_has_bits & 0x00000100u)
                ? CreateMaybeMessage<::pulsar::proto::CommandNewTxnResponse>(arena, *from._impl_.newtxnresponse_)
                : nullptr;
  _impl_.addpartitiontotxn_ = (cached_has_bits & 0x00000200u)
                ? CreateMaybeMessage<::pulsar::proto::CommandAddPartitionToTxn>(arena, *from._impl_.addpartitiontotxn_)
                : nullptr;
  _impl_.addpartitiontotxnresponse_ = (cached_has_bits & 0x00000400u)
                ? CreateMaybeMessage<::pulsar::proto::CommandAddPartitionToTxnResponse>(arena, *from._impl_.addpartitiontotxnresponse_)
                : nullptr;
  _impl_.addsubscriptiontotxn_ = (cached_has_bits & 0x00000800u)
                ? CreateMaybeMessage<::pulsar::proto::CommandAddSubscriptionToTxn>(arena, *from._impl_.addsubscriptiontotxn_)
                : nullptr;
  _impl_.addsubscriptiontotxnresponse_ = (cached_has_bits & 0x00001000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandAddSubscriptionToTxnResponse>(arena, *from._impl_.addsubscriptiontotxnresponse_)
                : nullptr;
  _impl_.endtxn_ = (cached_has_bits & 0x00002000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandEndTxn>(arena, *from._impl_.endtxn_)
                : nullptr;
  _impl_.endtxnresponse_ = (cached_has_bits & 0x00004000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandEndTxnResponse>(arena, *from._impl_.endtxnresponse_)
                : nullptr;
  _impl_.endtxnonpartition_ = (cached_has_bits & 0x00008000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandEndTxnOnPartition>(arena, *from._impl_.endtxnonpartition_)
                : nullptr;
  _impl_.endtxnonpartitionresponse_ = (cached_has_bits & 0x00010000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandEndTxnOnPartitionResponse>(arena, *from._impl_.endtxnonpartitionresponse_)
                : nullptr;
  _impl_.endtxnonsubscription_ = (cached_has_bits & 0x00020000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandEndTxnOnSubscription>(arena, *from._impl_.endtxnonsubscription_)
                : nullptr;
  _impl_.endtxnonsubscriptionresponse_ = (cached_has_bits & 0x00040000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandEndTxnOnSubscriptionResponse>(arena, *from._impl_.endtxnonsubscriptionresponse_)
                : nullptr;
  _impl_.tcclientconnectrequest_ = (cached_has_bits & 0x00080000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandTcClientConnectRequest>(arena, *from._impl_.tcclientconnectrequest_)
                : nullptr;
  _impl_.tcclientconnectresponse_ = (cached_has_bits & 0x00100000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandTcClientConnectResponse>(arena, *from._impl_.tcclientconnectresponse_)
                : nullptr;
  _impl_.watchtopiclist_ = (cached_has_bits & 0x00200000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandWatchTopicList>(arena, *from._impl_.watchtopiclist_)
                : nullptr;
  _impl_.watchtopiclistsuccess_ = (cached_has_bits & 0x00400000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandWatchTopicListSuccess>(arena, *from._impl_.watchtopiclistsuccess_)
                : nullptr;
  _impl_.watchtopicupdate_ = (cached_has_bits & 0x00800000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandWatchTopicUpdate>(arena, *from._impl_.watchtopicupdate_)
                : nullptr;
  _impl_.watchtopiclistclose_ = (cached_has_bits & 0x01000000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandWatchTopicListClose>(arena, *from._impl_.watchtopiclistclose_)
                : nullptr;
  _impl_.topicmigrated_ = (cached_has_bits & 0x02000000u)
                ? CreateMaybeMessage<::pulsar::proto::CommandTopicMigrated>(arena, *from._impl_.topicmigrated_)
                : nullptr;
  _impl_.type_ = from._impl_.type_;

  // @@protoc_insertion_point(copy_constructor:pulsar.proto.BaseCommand)
}
inline PROTOBUF_NDEBUG_INLINE BaseCommand::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        type_{static_cast< ::pulsar::proto::BaseCommand_Type >(2)} {}

inline void BaseCommand::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, connect_),
           0,
           offsetof(Impl_, topicmigrated_) -
               offsetof(Impl_, connect_) +
               sizeof(Impl_::topicmigrated_));
}
BaseCommand::~BaseCommand() {
  // @@protoc_insertion_point(destructor:pulsar.proto.BaseCommand)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void BaseCommand::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.connect_;
  delete _impl_.connected_;
  delete _impl_.subscribe_;
  delete _impl_.producer_;
  delete _impl_.send_;
  delete _impl_.send_receipt_;
  delete _impl_.send_error_;
  delete _impl_.message_;
  delete _impl_.ack_;
  delete _impl_.flow_;
  delete _impl_.unsubscribe_;
  delete _impl_.success_;
  delete _impl_.error_;
  delete _impl_.close_producer_;
  delete _impl_.close_consumer_;
  delete _impl_.producer_success_;
  delete _impl_.ping_;
  delete _impl_.pong_;
  delete _impl_.redeliverunacknowledgedmessages_;
  delete _impl_.partitionmetadata_;
  delete _impl_.partitionmetadataresponse_;
  delete _impl_.lookuptopic_;
  delete _impl_.lookuptopicresponse_;
  delete _impl_.consumerstats_;
  delete _impl_.consumerstatsresponse_;
  delete _impl_.reachedendoftopic_;
  delete _impl_.seek_;
  delete _impl_.getlastmessageid_;
  delete _impl_.getlastmessageidresponse_;
  delete _impl_.active_consumer_change_;
  delete _impl_.gettopicsofnamespace_;
  delete _impl_.gettopicsofnamespaceresponse_;
  delete _impl_.getschema_;
  delete _impl_.getschemaresponse_;
  delete _impl_.authchallenge_;
  delete _impl_.authresponse_;
  delete _impl_.ackresponse_;
  delete _impl_.getorcreateschema_;
  delete _impl_.getorcreateschemaresponse_;
  delete _impl_.newtxn_;
  delete _impl_.newtxnresponse_;
  delete _impl_.addpartitiontotxn_;
  delete _impl_.addpartitiontotxnresponse_;
  delete _impl_.addsubscriptiontotxn_;
  delete _impl_.addsubscriptiontotxnresponse_;
  delete _impl_.endtxn_;
  delete _impl_.endtxnresponse_;
  delete _impl_.endtxnonpartition_;
  delete _impl_.endtxnonpartitionresponse_;
  delete _impl_.endtxnonsubscription_;
  delete _impl_.endtxnonsubscriptionresponse_;
  delete _impl_.tcclientconnectrequest_;
  delete _impl_.tcclientconnectresponse_;
  delete _impl_.watchtopiclist_;
  delete _impl_.watchtopiclistsuccess_;
  delete _impl_.watchtopicupdate_;
  delete _impl_.watchtopiclistclose_;
  delete _impl_.topicmigrated_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void BaseCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:pulsar.proto.BaseCommand)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.connect_ != nullptr);
      _impl_.connect_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.connected_ != nullptr);
      _impl_.connected_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.subscribe_ != nullptr);
      _impl_.subscribe_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.producer_ != nullptr);
      _impl_.producer_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.send_ != nullptr);
      _impl_.send_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.send_receipt_ != nullptr);
      _impl_.send_receipt_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(_impl_.send_error_ != nullptr);
      _impl_.send_error_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      ABSL_DCHECK(_impl_.message_ != nullptr);
      _impl_.message_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      ABSL_DCHECK(_impl_.ack_ != nullptr);
      _impl_.ack_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      ABSL_DCHECK(_impl_.flow_ != nullptr);
      _impl_.flow_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      ABSL_DCHECK(_impl_.unsubscribe_ != nullptr);
      _impl_.unsubscribe_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      ABSL_DCHECK(_impl_.success_ != nullptr);
      _impl_.success_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      ABSL_DCHECK(_impl_.error_ != nullptr);
      _impl_.error_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      ABSL_DCHECK(_impl_.close_producer_ != nullptr);
      _impl_.close_producer_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      ABSL_DCHECK(_impl_.close_consumer_ != nullptr);
      _impl_.close_consumer_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      ABSL_DCHECK(_impl_.producer_success_ != nullptr);
      _impl_.producer_success_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      ABSL_DCHECK(_impl_.ping_ != nullptr);
      _impl_.ping_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      ABSL_DCHECK(_impl_.pong_ != nullptr);
      _impl_.pong_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      ABSL_DCHECK(_impl_.redeliverunacknowledgedmessages_ != nullptr);
      _impl_.redeliverunacknowledgedmessages_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      ABSL_DCHECK(_impl_.partitionmetadata_ != nullptr);
      _impl_.partitionmetadata_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      ABSL_DCHECK(_impl_.partitionmetadataresponse_ != nullptr);
      _impl_.partitionmetadataresponse_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      ABSL_DCHECK(_impl_.lookuptopic_ != nullptr);
      _impl_.lookuptopic_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      ABSL_DCHECK(_impl_.lookuptopicresponse_ != nullptr);
      _impl_.lookuptopicresponse_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      ABSL_DCHECK(_impl_.consumerstats_ != nullptr);
      _impl_.consumerstats_->Clear();
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      ABSL_DCHECK(_impl_.consumerstatsresponse_ != nullptr);
      _impl_.consumerstatsresponse_->Clear();
    }
    if (cached_has_bits & 0x02000000u) {
      ABSL_DCHECK(_impl_.reachedendoftopic_ != nullptr);
      _impl_.reachedendoftopic_->Clear();
    }
    if (cached_has_bits & 0x04000000u) {
      ABSL_DCHECK(_impl_.seek_ != nullptr);
      _impl_.seek_->Clear();
    }
    if (cached_has_bits & 0x08000000u) {
      ABSL_DCHECK(_impl_.getlastmessageid_ != nullptr);
      _impl_.getlastmessageid_->Clear();
    }
    if (cached_has_bits & 0x10000000u) {
      ABSL_DCHECK(_impl_.getlastmessageidresponse_ != nullptr);
      _impl_.getlastmessageidresponse_->Clear();
    }
    if (cached_has_bits & 0x20000000u) {
      ABSL_DCHECK(_impl_.active_consumer_change_ != nullptr);
      _impl_.active_consumer_change_->Clear();
    }
    if (cached_has_bits & 0x40000000u) {
      ABSL_DCHECK(_impl_.gettopicsofnamespace_ != nullptr);
      _impl_.gettopicsofnamespace_->Clear();
    }
    if (cached_has_bits & 0x80000000u) {
      ABSL_DCHECK(_impl_.gettopicsofnamespaceresponse_ != nullptr);
      _impl_.gettopicsofnamespaceresponse_->Clear();
    }
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.getschema_ != nullptr);
      _impl_.getschema_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.getschemaresponse_ != nullptr);
      _impl_.getschemaresponse_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.authchallenge_ != nullptr);
      _impl_.authchallenge_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.authresponse_ != nullptr);
      _impl_.authresponse_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.ackresponse_ != nullptr);
      _impl_.ackresponse_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.getorcreateschema_ != nullptr);
      _impl_.getorcreateschema_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(_impl_.getorcreateschemaresponse_ != nullptr);
      _impl_.getorcreateschemaresponse_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      ABSL_DCHECK(_impl_.newtxn_ != nullptr);
      _impl_.newtxn_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      ABSL_DCHECK(_impl_.newtxnresponse_ != nullptr);
      _impl_.newtxnresponse_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      ABSL_DCHECK(_impl_.addpartitiontotxn_ != nullptr);
      _impl_.addpartitiontotxn_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      ABSL_DCHECK(_impl_.addpartitiontotxnresponse_ != nullptr);
      _impl_.addpartitiontotxnresponse_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      ABSL_DCHECK(_impl_.addsubscriptiontotxn_ != nullptr);
      _impl_.addsubscriptiontotxn_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      ABSL_DCHECK(_impl_.addsubscriptiontotxnresponse_ != nullptr);
      _impl_.addsubscriptiontotxnresponse_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      ABSL_DCHECK(_impl_.endtxn_ != nullptr);
      _impl_.endtxn_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      ABSL_DCHECK(_impl_.endtxnresponse_ != nullptr);
      _impl_.endtxnresponse_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      ABSL_DCHECK(_impl_.endtxnonpartition_ != nullptr);
      _impl_.endtxnonpartition_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      ABSL_DCHECK(_impl_.endtxnonpartitionresponse_ != nullptr);
      _impl_.endtxnonpartitionresponse_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      ABSL_DCHECK(_impl_.endtxnonsubscription_ != nullptr);
      _impl_.endtxnonsubscription_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      ABSL_DCHECK(_impl_.endtxnonsubscriptionresponse_ != nullptr);
      _impl_.endtxnonsubscriptionresponse_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      ABSL_DCHECK(_impl_.tcclientconnectrequest_ != nullptr);
      _impl_.tcclientconnectrequest_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      ABSL_DCHECK(_impl_.tcclientconnectresponse_ != nullptr);
      _impl_.tcclientconnectresponse_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      ABSL_DCHECK(_impl_.watchtopiclist_ != nullptr);
      _impl_.watchtopiclist_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      ABSL_DCHECK(_impl_.watchtopiclistsuccess_ != nullptr);
      _impl_.watchtopiclistsuccess_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      ABSL_DCHECK(_impl_.watchtopicupdate_ != nullptr);
      _impl_.watchtopicupdate_->Clear();
    }
  }
  if (cached_has_bits & 0x07000000u) {
    if (cached_has_bits & 0x01000000u) {
      ABSL_DCHECK(_impl_.watchtopiclistclose_ != nullptr);
      _impl_.watchtopiclistclose_->Clear();
    }
    if (cached_has_bits & 0x02000000u) {
      ABSL_DCHECK(_impl_.topicmigrated_ != nullptr);
      _impl_.topicmigrated_->Clear();
    }
    _impl_.type_ = 2;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BaseCommand::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 59, 59, 0, 11> BaseCommand::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_._has_bits_),
    0, // no _extensions_
    68, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    0,  // skipmap
    offsetof(decltype(_table_), field_entries),
    59,  // num_field_entries
    59,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_BaseCommand_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional .pulsar.proto.CommandConnect connect = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 1, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.connect_)}},
    // optional .pulsar.proto.CommandConnected connected = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 2, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.connected_)}},
    // optional .pulsar.proto.CommandSubscribe subscribe = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 2, 3, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.subscribe_)}},
    // optional .pulsar.proto.CommandProducer producer = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 3, 4, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.producer_)}},
    // optional .pulsar.proto.CommandSend send = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 4, 5, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.send_)}},
    // optional .pulsar.proto.CommandSendReceipt send_receipt = 7;
    {::_pbi::TcParser::FastMtS1,
     {58, 5, 6, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.send_receipt_)}},
    // optional .pulsar.proto.CommandSendError send_error = 8;
    {::_pbi::TcParser::FastMtS1,
     {66, 6, 7, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.send_error_)}},
    // optional .pulsar.proto.CommandMessage message = 9;
    {::_pbi::TcParser::FastMtS1,
     {74, 7, 8, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.message_)}},
    // optional .pulsar.proto.CommandAck ack = 10;
    {::_pbi::TcParser::FastMtS1,
     {82, 8, 9, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.ack_)}},
    // optional .pulsar.proto.CommandFlow flow = 11;
    {::_pbi::TcParser::FastMtS1,
     {90, 9, 10, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.flow_)}},
    // optional .pulsar.proto.CommandUnsubscribe unsubscribe = 12;
    {::_pbi::TcParser::FastMtS1,
     {98, 10, 11, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.unsubscribe_)}},
    // optional .pulsar.proto.CommandSuccess success = 13;
    {::_pbi::TcParser::FastMtS1,
     {106, 11, 12, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.success_)}},
    // optional .pulsar.proto.CommandError error = 14;
    {::_pbi::TcParser::FastMtS1,
     {114, 12, 13, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.error_)}},
    // optional .pulsar.proto.CommandCloseProducer close_producer = 15;
    {::_pbi::TcParser::FastMtS1,
     {122, 13, 14, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.close_producer_)}},
    // optional .pulsar.proto.CommandCloseConsumer close_consumer = 16;
    {::_pbi::TcParser::FastMtS2,
     {386, 14, 15, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.close_consumer_)}},
    // optional .pulsar.proto.CommandProducerSuccess producer_success = 17;
    {::_pbi::TcParser::FastMtS2,
     {394, 15, 16, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.producer_success_)}},
    // optional .pulsar.proto.CommandPing ping = 18;
    {::_pbi::TcParser::FastMtS2,
     {402, 16, 17, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.ping_)}},
    // optional .pulsar.proto.CommandPong pong = 19;
    {::_pbi::TcParser::FastMtS2,
     {410, 17, 18, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.pong_)}},
    // optional .pulsar.proto.CommandRedeliverUnacknowledgedMessages redeliverUnacknowledgedMessages = 20;
    {::_pbi::TcParser::FastMtS2,
     {418, 18, 19, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.redeliverunacknowledgedmessages_)}},
    // optional .pulsar.proto.CommandPartitionedTopicMetadata partitionMetadata = 21;
    {::_pbi::TcParser::FastMtS2,
     {426, 19, 20, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.partitionmetadata_)}},
    // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse partitionMetadataResponse = 22;
    {::_pbi::TcParser::FastMtS2,
     {434, 20, 21, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.partitionmetadataresponse_)}},
    // optional .pulsar.proto.CommandLookupTopic lookupTopic = 23;
    {::_pbi::TcParser::FastMtS2,
     {442, 21, 22, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.lookuptopic_)}},
    // optional .pulsar.proto.CommandLookupTopicResponse lookupTopicResponse = 24;
    {::_pbi::TcParser::FastMtS2,
     {450, 22, 23, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.lookuptopicresponse_)}},
    // optional .pulsar.proto.CommandConsumerStats consumerStats = 25;
    {::_pbi::TcParser::FastMtS2,
     {458, 23, 24, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.consumerstats_)}},
    // optional .pulsar.proto.CommandConsumerStatsResponse consumerStatsResponse = 26;
    {::_pbi::TcParser::FastMtS2,
     {466, 24, 25, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.consumerstatsresponse_)}},
    // optional .pulsar.proto.CommandReachedEndOfTopic reachedEndOfTopic = 27;
    {::_pbi::TcParser::FastMtS2,
     {474, 25, 26, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.reachedendoftopic_)}},
    // optional .pulsar.proto.CommandSeek seek = 28;
    {::_pbi::TcParser::FastMtS2,
     {482, 26, 27, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.seek_)}},
    // optional .pulsar.proto.CommandGetLastMessageId getLastMessageId = 29;
    {::_pbi::TcParser::FastMtS2,
     {490, 27, 28, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.getlastmessageid_)}},
    // optional .pulsar.proto.CommandGetLastMessageIdResponse getLastMessageIdResponse = 30;
    {::_pbi::TcParser::FastMtS2,
     {498, 28, 29, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.getlastmessageidresponse_)}},
    // optional .pulsar.proto.CommandActiveConsumerChange active_consumer_change = 31;
    {::_pbi::TcParser::FastMtS2,
     {506, 29, 30, PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.active_consumer_change_)}},
  }}, {{
    33, 0, 3,
    65280, 32, 1, 40, 65520, 55,
    65535, 65535
  }}, {{
    // required .pulsar.proto.BaseCommand.Type type = 1;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.type_), _Internal::kHasBitsOffset + 58, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnum)},
    // optional .pulsar.proto.CommandConnect connect = 2;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.connect_), _Internal::kHasBitsOffset + 0, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandConnected connected = 3;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.connected_), _Internal::kHasBitsOffset + 1, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandSubscribe subscribe = 4;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.subscribe_), _Internal::kHasBitsOffset + 2, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandProducer producer = 5;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.producer_), _Internal::kHasBitsOffset + 3, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandSend send = 6;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.send_), _Internal::kHasBitsOffset + 4, 5,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandSendReceipt send_receipt = 7;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.send_receipt_), _Internal::kHasBitsOffset + 5, 6,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandSendError send_error = 8;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.send_error_), _Internal::kHasBitsOffset + 6, 7,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandMessage message = 9;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.message_), _Internal::kHasBitsOffset + 7, 8,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandAck ack = 10;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.ack_), _Internal::kHasBitsOffset + 8, 9,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandFlow flow = 11;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.flow_), _Internal::kHasBitsOffset + 9, 10,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandUnsubscribe unsubscribe = 12;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.unsubscribe_), _Internal::kHasBitsOffset + 10, 11,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandSuccess success = 13;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.success_), _Internal::kHasBitsOffset + 11, 12,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandError error = 14;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.error_), _Internal::kHasBitsOffset + 12, 13,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandCloseProducer close_producer = 15;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.close_producer_), _Internal::kHasBitsOffset + 13, 14,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandCloseConsumer close_consumer = 16;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.close_consumer_), _Internal::kHasBitsOffset + 14, 15,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandProducerSuccess producer_success = 17;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.producer_success_), _Internal::kHasBitsOffset + 15, 16,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandPing ping = 18;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.ping_), _Internal::kHasBitsOffset + 16, 17,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandPong pong = 19;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.pong_), _Internal::kHasBitsOffset + 17, 18,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandRedeliverUnacknowledgedMessages redeliverUnacknowledgedMessages = 20;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.redeliverunacknowledgedmessages_), _Internal::kHasBitsOffset + 18, 19,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandPartitionedTopicMetadata partitionMetadata = 21;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.partitionmetadata_), _Internal::kHasBitsOffset + 19, 20,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse partitionMetadataResponse = 22;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.partitionmetadataresponse_), _Internal::kHasBitsOffset + 20, 21,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandLookupTopic lookupTopic = 23;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.lookuptopic_), _Internal::kHasBitsOffset + 21, 22,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandLookupTopicResponse lookupTopicResponse = 24;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.lookuptopicresponse_), _Internal::kHasBitsOffset + 22, 23,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandConsumerStats consumerStats = 25;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.consumerstats_), _Internal::kHasBitsOffset + 23, 24,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandConsumerStatsResponse consumerStatsResponse = 26;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.consumerstatsresponse_), _Internal::kHasBitsOffset + 24, 25,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandReachedEndOfTopic reachedEndOfTopic = 27;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.reachedendoftopic_), _Internal::kHasBitsOffset + 25, 26,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandSeek seek = 28;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.seek_), _Internal::kHasBitsOffset + 26, 27,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandGetLastMessageId getLastMessageId = 29;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.getlastmessageid_), _Internal::kHasBitsOffset + 27, 28,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandGetLastMessageIdResponse getLastMessageIdResponse = 30;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.getlastmessageidresponse_), _Internal::kHasBitsOffset + 28, 29,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandActiveConsumerChange active_consumer_change = 31;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.active_consumer_change_), _Internal::kHasBitsOffset + 29, 30,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandGetTopicsOfNamespace getTopicsOfNamespace = 32;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.gettopicsofnamespace_), _Internal::kHasBitsOffset + 30, 31,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandGetTopicsOfNamespaceResponse getTopicsOfNamespaceResponse = 33;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.gettopicsofnamespaceresponse_), _Internal::kHasBitsOffset + 31, 32,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandGetSchema getSchema = 34;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.getschema_), _Internal::kHasBitsOffset + 32, 33,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandGetSchemaResponse getSchemaResponse = 35;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.getschemaresponse_), _Internal::kHasBitsOffset + 33, 34,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandAuthChallenge authChallenge = 36;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.authchallenge_), _Internal::kHasBitsOffset + 34, 35,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandAuthResponse authResponse = 37;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.authresponse_), _Internal::kHasBitsOffset + 35, 36,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandAckResponse ackResponse = 38;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.ackresponse_), _Internal::kHasBitsOffset + 36, 37,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandGetOrCreateSchema getOrCreateSchema = 39;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.getorcreateschema_), _Internal::kHasBitsOffset + 37, 38,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandGetOrCreateSchemaResponse getOrCreateSchemaResponse = 40;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.getorcreateschemaresponse_), _Internal::kHasBitsOffset + 38, 39,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandNewTxn newTxn = 50;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.newtxn_), _Internal::kHasBitsOffset + 39, 40,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandNewTxnResponse newTxnResponse = 51;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.newtxnresponse_), _Internal::kHasBitsOffset + 40, 41,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandAddPartitionToTxn addPartitionToTxn = 52;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.addpartitiontotxn_), _Internal::kHasBitsOffset + 41, 42,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandAddPartitionToTxnResponse addPartitionToTxnResponse = 53;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.addpartitiontotxnresponse_), _Internal::kHasBitsOffset + 42, 43,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandAddSubscriptionToTxn addSubscriptionToTxn = 54;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.addsubscriptiontotxn_), _Internal::kHasBitsOffset + 43, 44,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandAddSubscriptionToTxnResponse addSubscriptionToTxnResponse = 55;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.addsubscriptiontotxnresponse_), _Internal::kHasBitsOffset + 44, 45,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandEndTxn endTxn = 56;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.endtxn_), _Internal::kHasBitsOffset + 45, 46,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandEndTxnResponse endTxnResponse = 57;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.endtxnresponse_), _Internal::kHasBitsOffset + 46, 47,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandEndTxnOnPartition endTxnOnPartition = 58;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.endtxnonpartition_), _Internal::kHasBitsOffset + 47, 48,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandEndTxnOnPartitionResponse endTxnOnPartitionResponse = 59;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.endtxnonpartitionresponse_), _Internal::kHasBitsOffset + 48, 49,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandEndTxnOnSubscription endTxnOnSubscription = 60;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.endtxnonsubscription_), _Internal::kHasBitsOffset + 49, 50,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandEndTxnOnSubscriptionResponse endTxnOnSubscriptionResponse = 61;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.endtxnonsubscriptionresponse_), _Internal::kHasBitsOffset + 50, 51,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandTcClientConnectRequest tcClientConnectRequest = 62;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.tcclientconnectrequest_), _Internal::kHasBitsOffset + 51, 52,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandTcClientConnectResponse tcClientConnectResponse = 63;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.tcclientconnectresponse_), _Internal::kHasBitsOffset + 52, 53,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandWatchTopicList watchTopicList = 64;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.watchtopiclist_), _Internal::kHasBitsOffset + 53, 54,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandWatchTopicListSuccess watchTopicListSuccess = 65;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.watchtopiclistsuccess_), _Internal::kHasBitsOffset + 54, 55,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandWatchTopicUpdate watchTopicUpdate = 66;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.watchtopicupdate_), _Internal::kHasBitsOffset + 55, 56,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandWatchTopicListClose watchTopicListClose = 67;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.watchtopiclistclose_), _Internal::kHasBitsOffset + 56, 57,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .pulsar.proto.CommandTopicMigrated topicMigrated = 68;
    {PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.topicmigrated_), _Internal::kHasBitsOffset + 57, 58,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::FieldAuxEnumData{}, ::pulsar::proto::BaseCommand_Type_internal_data_},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandConnect>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandConnected>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandSubscribe>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandProducer>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandSend>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandSendReceipt>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandSendError>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandMessage>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandAck>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandFlow>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandUnsubscribe>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandSuccess>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandError>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandCloseProducer>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandCloseConsumer>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandProducerSuccess>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandPing>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandPong>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandRedeliverUnacknowledgedMessages>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandPartitionedTopicMetadata>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandPartitionedTopicMetadataResponse>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandLookupTopic>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandLookupTopicResponse>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandConsumerStats>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandConsumerStatsResponse>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandReachedEndOfTopic>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandSeek>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandGetLastMessageId>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandGetLastMessageIdResponse>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandActiveConsumerChange>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandGetTopicsOfNamespace>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandGetTopicsOfNamespaceResponse>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandGetSchema>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandGetSchemaResponse>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandAuthChallenge>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandAuthResponse>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandAckResponse>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandGetOrCreateSchema>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandGetOrCreateSchemaResponse>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandNewTxn>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandNewTxnResponse>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandAddPartitionToTxn>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandAddPartitionToTxnResponse>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandAddSubscriptionToTxn>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandAddSubscriptionToTxnResponse>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandEndTxn>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandEndTxnResponse>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandEndTxnOnPartition>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandEndTxnOnPartitionResponse>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandEndTxnOnSubscription>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandEndTxnOnSubscriptionResponse>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandTcClientConnectRequest>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandTcClientConnectResponse>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandWatchTopicList>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandWatchTopicListSuccess>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandWatchTopicUpdate>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandWatchTopicListClose>()},
    {::_pbi::TcParser::GetTable<::pulsar::proto::CommandTopicMigrated>()},
  }}, {{
  }},
};

::uint8_t* BaseCommand::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulsar.proto.BaseCommand)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[1];
  // required .pulsar.proto.BaseCommand.Type type = 1;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_type(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .pulsar.proto.CommandConnect connect = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::connect(this),
        _Internal::connect(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandConnected connected = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::connected(this),
        _Internal::connected(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandSubscribe subscribe = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, _Internal::subscribe(this),
        _Internal::subscribe(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandProducer producer = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, _Internal::producer(this),
        _Internal::producer(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandSend send = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        6, _Internal::send(this),
        _Internal::send(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandSendReceipt send_receipt = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        7, _Internal::send_receipt(this),
        _Internal::send_receipt(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandSendError send_error = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        8, _Internal::send_error(this),
        _Internal::send_error(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandMessage message = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        9, _Internal::message(this),
        _Internal::message(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandAck ack = 10;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        10, _Internal::ack(this),
        _Internal::ack(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandFlow flow = 11;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        11, _Internal::flow(this),
        _Internal::flow(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandUnsubscribe unsubscribe = 12;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        12, _Internal::unsubscribe(this),
        _Internal::unsubscribe(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandSuccess success = 13;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        13, _Internal::success(this),
        _Internal::success(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandError error = 14;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        14, _Internal::error(this),
        _Internal::error(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandCloseProducer close_producer = 15;
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        15, _Internal::close_producer(this),
        _Internal::close_producer(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandCloseConsumer close_consumer = 16;
  if (cached_has_bits & 0x00004000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        16, _Internal::close_consumer(this),
        _Internal::close_consumer(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandProducerSuccess producer_success = 17;
  if (cached_has_bits & 0x00008000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        17, _Internal::producer_success(this),
        _Internal::producer_success(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandPing ping = 18;
  if (cached_has_bits & 0x00010000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        18, _Internal::ping(this),
        _Internal::ping(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandPong pong = 19;
  if (cached_has_bits & 0x00020000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        19, _Internal::pong(this),
        _Internal::pong(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandRedeliverUnacknowledgedMessages redeliverUnacknowledgedMessages = 20;
  if (cached_has_bits & 0x00040000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        20, _Internal::redeliverunacknowledgedmessages(this),
        _Internal::redeliverunacknowledgedmessages(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandPartitionedTopicMetadata partitionMetadata = 21;
  if (cached_has_bits & 0x00080000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        21, _Internal::partitionmetadata(this),
        _Internal::partitionmetadata(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse partitionMetadataResponse = 22;
  if (cached_has_bits & 0x00100000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        22, _Internal::partitionmetadataresponse(this),
        _Internal::partitionmetadataresponse(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandLookupTopic lookupTopic = 23;
  if (cached_has_bits & 0x00200000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        23, _Internal::lookuptopic(this),
        _Internal::lookuptopic(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandLookupTopicResponse lookupTopicResponse = 24;
  if (cached_has_bits & 0x00400000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        24, _Internal::lookuptopicresponse(this),
        _Internal::lookuptopicresponse(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandConsumerStats consumerStats = 25;
  if (cached_has_bits & 0x00800000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        25, _Internal::consumerstats(this),
        _Internal::consumerstats(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandConsumerStatsResponse consumerStatsResponse = 26;
  if (cached_has_bits & 0x01000000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        26, _Internal::consumerstatsresponse(this),
        _Internal::consumerstatsresponse(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandReachedEndOfTopic reachedEndOfTopic = 27;
  if (cached_has_bits & 0x02000000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        27, _Internal::reachedendoftopic(this),
        _Internal::reachedendoftopic(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandSeek seek = 28;
  if (cached_has_bits & 0x04000000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        28, _Internal::seek(this),
        _Internal::seek(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandGetLastMessageId getLastMessageId = 29;
  if (cached_has_bits & 0x08000000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        29, _Internal::getlastmessageid(this),
        _Internal::getlastmessageid(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandGetLastMessageIdResponse getLastMessageIdResponse = 30;
  if (cached_has_bits & 0x10000000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        30, _Internal::getlastmessageidresponse(this),
        _Internal::getlastmessageidresponse(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandActiveConsumerChange active_consumer_change = 31;
  if (cached_has_bits & 0x20000000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        31, _Internal::active_consumer_change(this),
        _Internal::active_consumer_change(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandGetTopicsOfNamespace getTopicsOfNamespace = 32;
  if (cached_has_bits & 0x40000000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        32, _Internal::gettopicsofnamespace(this),
        _Internal::gettopicsofnamespace(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandGetTopicsOfNamespaceResponse getTopicsOfNamespaceResponse = 33;
  if (cached_has_bits & 0x80000000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        33, _Internal::gettopicsofnamespaceresponse(this),
        _Internal::gettopicsofnamespaceresponse(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional .pulsar.proto.CommandGetSchema getSchema = 34;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        34, _Internal::getschema(this),
        _Internal::getschema(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandGetSchemaResponse getSchemaResponse = 35;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        35, _Internal::getschemaresponse(this),
        _Internal::getschemaresponse(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandAuthChallenge authChallenge = 36;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        36, _Internal::authchallenge(this),
        _Internal::authchallenge(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandAuthResponse authResponse = 37;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        37, _Internal::authresponse(this),
        _Internal::authresponse(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandAckResponse ackResponse = 38;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        38, _Internal::ackresponse(this),
        _Internal::ackresponse(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandGetOrCreateSchema getOrCreateSchema = 39;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        39, _Internal::getorcreateschema(this),
        _Internal::getorcreateschema(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandGetOrCreateSchemaResponse getOrCreateSchemaResponse = 40;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        40, _Internal::getorcreateschemaresponse(this),
        _Internal::getorcreateschemaresponse(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandNewTxn newTxn = 50;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        50, _Internal::newtxn(this),
        _Internal::newtxn(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandNewTxnResponse newTxnResponse = 51;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        51, _Internal::newtxnresponse(this),
        _Internal::newtxnresponse(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandAddPartitionToTxn addPartitionToTxn = 52;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        52, _Internal::addpartitiontotxn(this),
        _Internal::addpartitiontotxn(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandAddPartitionToTxnResponse addPartitionToTxnResponse = 53;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        53, _Internal::addpartitiontotxnresponse(this),
        _Internal::addpartitiontotxnresponse(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandAddSubscriptionToTxn addSubscriptionToTxn = 54;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        54, _Internal::addsubscriptiontotxn(this),
        _Internal::addsubscriptiontotxn(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandAddSubscriptionToTxnResponse addSubscriptionToTxnResponse = 55;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        55, _Internal::addsubscriptiontotxnresponse(this),
        _Internal::addsubscriptiontotxnresponse(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandEndTxn endTxn = 56;
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        56, _Internal::endtxn(this),
        _Internal::endtxn(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandEndTxnResponse endTxnResponse = 57;
  if (cached_has_bits & 0x00004000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        57, _Internal::endtxnresponse(this),
        _Internal::endtxnresponse(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandEndTxnOnPartition endTxnOnPartition = 58;
  if (cached_has_bits & 0x00008000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        58, _Internal::endtxnonpartition(this),
        _Internal::endtxnonpartition(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandEndTxnOnPartitionResponse endTxnOnPartitionResponse = 59;
  if (cached_has_bits & 0x00010000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        59, _Internal::endtxnonpartitionresponse(this),
        _Internal::endtxnonpartitionresponse(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandEndTxnOnSubscription endTxnOnSubscription = 60;
  if (cached_has_bits & 0x00020000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        60, _Internal::endtxnonsubscription(this),
        _Internal::endtxnonsubscription(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandEndTxnOnSubscriptionResponse endTxnOnSubscriptionResponse = 61;
  if (cached_has_bits & 0x00040000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        61, _Internal::endtxnonsubscriptionresponse(this),
        _Internal::endtxnonsubscriptionresponse(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandTcClientConnectRequest tcClientConnectRequest = 62;
  if (cached_has_bits & 0x00080000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        62, _Internal::tcclientconnectrequest(this),
        _Internal::tcclientconnectrequest(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandTcClientConnectResponse tcClientConnectResponse = 63;
  if (cached_has_bits & 0x00100000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        63, _Internal::tcclientconnectresponse(this),
        _Internal::tcclientconnectresponse(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandWatchTopicList watchTopicList = 64;
  if (cached_has_bits & 0x00200000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        64, _Internal::watchtopiclist(this),
        _Internal::watchtopiclist(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandWatchTopicListSuccess watchTopicListSuccess = 65;
  if (cached_has_bits & 0x00400000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        65, _Internal::watchtopiclistsuccess(this),
        _Internal::watchtopiclistsuccess(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandWatchTopicUpdate watchTopicUpdate = 66;
  if (cached_has_bits & 0x00800000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        66, _Internal::watchtopicupdate(this),
        _Internal::watchtopicupdate(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandWatchTopicListClose watchTopicListClose = 67;
  if (cached_has_bits & 0x01000000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        67, _Internal::watchtopiclistclose(this),
        _Internal::watchtopiclistclose(this).GetCachedSize(), target, stream);
  }

  // optional .pulsar.proto.CommandTopicMigrated topicMigrated = 68;
  if (cached_has_bits & 0x02000000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        68, _Internal::topicmigrated(this),
        _Internal::topicmigrated(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulsar.proto.BaseCommand)
  return target;
}

::size_t BaseCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulsar.proto.BaseCommand)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .pulsar.proto.CommandConnect connect = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.connect_);
    }

    // optional .pulsar.proto.CommandConnected connected = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.connected_);
    }

    // optional .pulsar.proto.CommandSubscribe subscribe = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.subscribe_);
    }

    // optional .pulsar.proto.CommandProducer producer = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.producer_);
    }

    // optional .pulsar.proto.CommandSend send = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.send_);
    }

    // optional .pulsar.proto.CommandSendReceipt send_receipt = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.send_receipt_);
    }

    // optional .pulsar.proto.CommandSendError send_error = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.send_error_);
    }

    // optional .pulsar.proto.CommandMessage message = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.message_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .pulsar.proto.CommandAck ack = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.ack_);
    }

    // optional .pulsar.proto.CommandFlow flow = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.flow_);
    }

    // optional .pulsar.proto.CommandUnsubscribe unsubscribe = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.unsubscribe_);
    }

    // optional .pulsar.proto.CommandSuccess success = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.success_);
    }

    // optional .pulsar.proto.CommandError error = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.error_);
    }

    // optional .pulsar.proto.CommandCloseProducer close_producer = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.close_producer_);
    }

    // optional .pulsar.proto.CommandCloseConsumer close_consumer = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.close_consumer_);
    }

    // optional .pulsar.proto.CommandProducerSuccess producer_success = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.producer_success_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .pulsar.proto.CommandPing ping = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.ping_);
    }

    // optional .pulsar.proto.CommandPong pong = 19;
    if (cached_has_bits & 0x00020000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.pong_);
    }

    // optional .pulsar.proto.CommandRedeliverUnacknowledgedMessages redeliverUnacknowledgedMessages = 20;
    if (cached_has_bits & 0x00040000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.redeliverunacknowledgedmessages_);
    }

    // optional .pulsar.proto.CommandPartitionedTopicMetadata partitionMetadata = 21;
    if (cached_has_bits & 0x00080000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.partitionmetadata_);
    }

    // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse partitionMetadataResponse = 22;
    if (cached_has_bits & 0x00100000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.partitionmetadataresponse_);
    }

    // optional .pulsar.proto.CommandLookupTopic lookupTopic = 23;
    if (cached_has_bits & 0x00200000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.lookuptopic_);
    }

    // optional .pulsar.proto.CommandLookupTopicResponse lookupTopicResponse = 24;
    if (cached_has_bits & 0x00400000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.lookuptopicresponse_);
    }

    // optional .pulsar.proto.CommandConsumerStats consumerStats = 25;
    if (cached_has_bits & 0x00800000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.consumerstats_);
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional .pulsar.proto.CommandConsumerStatsResponse consumerStatsResponse = 26;
    if (cached_has_bits & 0x01000000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.consumerstatsresponse_);
    }

    // optional .pulsar.proto.CommandReachedEndOfTopic reachedEndOfTopic = 27;
    if (cached_has_bits & 0x02000000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.reachedendoftopic_);
    }

    // optional .pulsar.proto.CommandSeek seek = 28;
    if (cached_has_bits & 0x04000000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.seek_);
    }

    // optional .pulsar.proto.CommandGetLastMessageId getLastMessageId = 29;
    if (cached_has_bits & 0x08000000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.getlastmessageid_);
    }

    // optional .pulsar.proto.CommandGetLastMessageIdResponse getLastMessageIdResponse = 30;
    if (cached_has_bits & 0x10000000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.getlastmessageidresponse_);
    }

    // optional .pulsar.proto.CommandActiveConsumerChange active_consumer_change = 31;
    if (cached_has_bits & 0x20000000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.active_consumer_change_);
    }

    // optional .pulsar.proto.CommandGetTopicsOfNamespace getTopicsOfNamespace = 32;
    if (cached_has_bits & 0x40000000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.gettopicsofnamespace_);
    }

    // optional .pulsar.proto.CommandGetTopicsOfNamespaceResponse getTopicsOfNamespaceResponse = 33;
    if (cached_has_bits & 0x80000000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.gettopicsofnamespaceresponse_);
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional .pulsar.proto.CommandGetSchema getSchema = 34;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.getschema_);
    }

    // optional .pulsar.proto.CommandGetSchemaResponse getSchemaResponse = 35;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.getschemaresponse_);
    }

    // optional .pulsar.proto.CommandAuthChallenge authChallenge = 36;
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.authchallenge_);
    }

    // optional .pulsar.proto.CommandAuthResponse authResponse = 37;
    if (cached_has_bits & 0x00000008u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.authresponse_);
    }

    // optional .pulsar.proto.CommandAckResponse ackResponse = 38;
    if (cached_has_bits & 0x00000010u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.ackresponse_);
    }

    // optional .pulsar.proto.CommandGetOrCreateSchema getOrCreateSchema = 39;
    if (cached_has_bits & 0x00000020u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.getorcreateschema_);
    }

    // optional .pulsar.proto.CommandGetOrCreateSchemaResponse getOrCreateSchemaResponse = 40;
    if (cached_has_bits & 0x00000040u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.getorcreateschemaresponse_);
    }

    // optional .pulsar.proto.CommandNewTxn newTxn = 50;
    if (cached_has_bits & 0x00000080u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.newtxn_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .pulsar.proto.CommandNewTxnResponse newTxnResponse = 51;
    if (cached_has_bits & 0x00000100u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.newtxnresponse_);
    }

    // optional .pulsar.proto.CommandAddPartitionToTxn addPartitionToTxn = 52;
    if (cached_has_bits & 0x00000200u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.addpartitiontotxn_);
    }

    // optional .pulsar.proto.CommandAddPartitionToTxnResponse addPartitionToTxnResponse = 53;
    if (cached_has_bits & 0x00000400u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.addpartitiontotxnresponse_);
    }

    // optional .pulsar.proto.CommandAddSubscriptionToTxn addSubscriptionToTxn = 54;
    if (cached_has_bits & 0x00000800u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.addsubscriptiontotxn_);
    }

    // optional .pulsar.proto.CommandAddSubscriptionToTxnResponse addSubscriptionToTxnResponse = 55;
    if (cached_has_bits & 0x00001000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.addsubscriptiontotxnresponse_);
    }

    // optional .pulsar.proto.CommandEndTxn endTxn = 56;
    if (cached_has_bits & 0x00002000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.endtxn_);
    }

    // optional .pulsar.proto.CommandEndTxnResponse endTxnResponse = 57;
    if (cached_has_bits & 0x00004000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.endtxnresponse_);
    }

    // optional .pulsar.proto.CommandEndTxnOnPartition endTxnOnPartition = 58;
    if (cached_has_bits & 0x00008000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.endtxnonpartition_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .pulsar.proto.CommandEndTxnOnPartitionResponse endTxnOnPartitionResponse = 59;
    if (cached_has_bits & 0x00010000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.endtxnonpartitionresponse_);
    }

    // optional .pulsar.proto.CommandEndTxnOnSubscription endTxnOnSubscription = 60;
    if (cached_has_bits & 0x00020000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.endtxnonsubscription_);
    }

    // optional .pulsar.proto.CommandEndTxnOnSubscriptionResponse endTxnOnSubscriptionResponse = 61;
    if (cached_has_bits & 0x00040000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.endtxnonsubscriptionresponse_);
    }

    // optional .pulsar.proto.CommandTcClientConnectRequest tcClientConnectRequest = 62;
    if (cached_has_bits & 0x00080000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.tcclientconnectrequest_);
    }

    // optional .pulsar.proto.CommandTcClientConnectResponse tcClientConnectResponse = 63;
    if (cached_has_bits & 0x00100000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.tcclientconnectresponse_);
    }

    // optional .pulsar.proto.CommandWatchTopicList watchTopicList = 64;
    if (cached_has_bits & 0x00200000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.watchtopiclist_);
    }

    // optional .pulsar.proto.CommandWatchTopicListSuccess watchTopicListSuccess = 65;
    if (cached_has_bits & 0x00400000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.watchtopiclistsuccess_);
    }

    // optional .pulsar.proto.CommandWatchTopicUpdate watchTopicUpdate = 66;
    if (cached_has_bits & 0x00800000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.watchtopicupdate_);
    }

  }
  if (cached_has_bits & 0x03000000u) {
    // optional .pulsar.proto.CommandWatchTopicListClose watchTopicListClose = 67;
    if (cached_has_bits & 0x01000000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.watchtopiclistclose_);
    }

    // optional .pulsar.proto.CommandTopicMigrated topicMigrated = 68;
    if (cached_has_bits & 0x02000000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.topicmigrated_);
    }

  }
  // required .pulsar.proto.BaseCommand.Type type = 1;
  if (cached_has_bits & 0x04000000u) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BaseCommand::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BaseCommand*>(
      &from));
}

void BaseCommand::MergeFrom(const BaseCommand& from) {
  BaseCommand* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:pulsar.proto.BaseCommand)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_connect()->::pulsar::proto::CommandConnect::MergeFrom(
          from._internal_connect());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_connected()->::pulsar::proto::CommandConnected::MergeFrom(
          from._internal_connected());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_subscribe()->::pulsar::proto::CommandSubscribe::MergeFrom(
          from._internal_subscribe());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_producer()->::pulsar::proto::CommandProducer::MergeFrom(
          from._internal_producer());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_send()->::pulsar::proto::CommandSend::MergeFrom(
          from._internal_send());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_send_receipt()->::pulsar::proto::CommandSendReceipt::MergeFrom(
          from._internal_send_receipt());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_send_error()->::pulsar::proto::CommandSendError::MergeFrom(
          from._internal_send_error());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_message()->::pulsar::proto::CommandMessage::MergeFrom(
          from._internal_message());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_ack()->::pulsar::proto::CommandAck::MergeFrom(
          from._internal_ack());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_flow()->::pulsar::proto::CommandFlow::MergeFrom(
          from._internal_flow());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_unsubscribe()->::pulsar::proto::CommandUnsubscribe::MergeFrom(
          from._internal_unsubscribe());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_success()->::pulsar::proto::CommandSuccess::MergeFrom(
          from._internal_success());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_error()->::pulsar::proto::CommandError::MergeFrom(
          from._internal_error());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_close_producer()->::pulsar::proto::CommandCloseProducer::MergeFrom(
          from._internal_close_producer());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_close_consumer()->::pulsar::proto::CommandCloseConsumer::MergeFrom(
          from._internal_close_consumer());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_producer_success()->::pulsar::proto::CommandProducerSuccess::MergeFrom(
          from._internal_producer_success());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_internal_mutable_ping()->::pulsar::proto::CommandPing::MergeFrom(
          from._internal_ping());
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_internal_mutable_pong()->::pulsar::proto::CommandPong::MergeFrom(
          from._internal_pong());
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_internal_mutable_redeliverunacknowledgedmessages()->::pulsar::proto::CommandRedeliverUnacknowledgedMessages::MergeFrom(
          from._internal_redeliverunacknowledgedmessages());
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_internal_mutable_partitionmetadata()->::pulsar::proto::CommandPartitionedTopicMetadata::MergeFrom(
          from._internal_partitionmetadata());
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_internal_mutable_partitionmetadataresponse()->::pulsar::proto::CommandPartitionedTopicMetadataResponse::MergeFrom(
          from._internal_partitionmetadataresponse());
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_internal_mutable_lookuptopic()->::pulsar::proto::CommandLookupTopic::MergeFrom(
          from._internal_lookuptopic());
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_internal_mutable_lookuptopicresponse()->::pulsar::proto::CommandLookupTopicResponse::MergeFrom(
          from._internal_lookuptopicresponse());
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_internal_mutable_consumerstats()->::pulsar::proto::CommandConsumerStats::MergeFrom(
          from._internal_consumerstats());
    }
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_internal_mutable_consumerstatsresponse()->::pulsar::proto::CommandConsumerStatsResponse::MergeFrom(
          from._internal_consumerstatsresponse());
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_internal_mutable_reachedendoftopic()->::pulsar::proto::CommandReachedEndOfTopic::MergeFrom(
          from._internal_reachedendoftopic());
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_internal_mutable_seek()->::pulsar::proto::CommandSeek::MergeFrom(
          from._internal_seek());
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_internal_mutable_getlastmessageid()->::pulsar::proto::CommandGetLastMessageId::MergeFrom(
          from._internal_getlastmessageid());
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_internal_mutable_getlastmessageidresponse()->::pulsar::proto::CommandGetLastMessageIdResponse::MergeFrom(
          from._internal_getlastmessageidresponse());
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_internal_mutable_active_consumer_change()->::pulsar::proto::CommandActiveConsumerChange::MergeFrom(
          from._internal_active_consumer_change());
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_internal_mutable_gettopicsofnamespace()->::pulsar::proto::CommandGetTopicsOfNamespace::MergeFrom(
          from._internal_gettopicsofnamespace());
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_internal_mutable_gettopicsofnamespaceresponse()->::pulsar::proto::CommandGetTopicsOfNamespaceResponse::MergeFrom(
          from._internal_gettopicsofnamespaceresponse());
    }
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_getschema()->::pulsar::proto::CommandGetSchema::MergeFrom(
          from._internal_getschema());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_getschemaresponse()->::pulsar::proto::CommandGetSchemaResponse::MergeFrom(
          from._internal_getschemaresponse());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_authchallenge()->::pulsar::proto::CommandAuthChallenge::MergeFrom(
          from._internal_authchallenge());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_authresponse()->::pulsar::proto::CommandAuthResponse::MergeFrom(
          from._internal_authresponse());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_ackresponse()->::pulsar::proto::CommandAckResponse::MergeFrom(
          from._internal_ackresponse());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_getorcreateschema()->::pulsar::proto::CommandGetOrCreateSchema::MergeFrom(
          from._internal_getorcreateschema());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_getorcreateschemaresponse()->::pulsar::proto::CommandGetOrCreateSchemaResponse::MergeFrom(
          from._internal_getorcreateschemaresponse());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_newtxn()->::pulsar::proto::CommandNewTxn::MergeFrom(
          from._internal_newtxn());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_newtxnresponse()->::pulsar::proto::CommandNewTxnResponse::MergeFrom(
          from._internal_newtxnresponse());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_addpartitiontotxn()->::pulsar::proto::CommandAddPartitionToTxn::MergeFrom(
          from._internal_addpartitiontotxn());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_addpartitiontotxnresponse()->::pulsar::proto::CommandAddPartitionToTxnResponse::MergeFrom(
          from._internal_addpartitiontotxnresponse());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_addsubscriptiontotxn()->::pulsar::proto::CommandAddSubscriptionToTxn::MergeFrom(
          from._internal_addsubscriptiontotxn());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_addsubscriptiontotxnresponse()->::pulsar::proto::CommandAddSubscriptionToTxnResponse::MergeFrom(
          from._internal_addsubscriptiontotxnresponse());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_endtxn()->::pulsar::proto::CommandEndTxn::MergeFrom(
          from._internal_endtxn());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_endtxnresponse()->::pulsar::proto::CommandEndTxnResponse::MergeFrom(
          from._internal_endtxnresponse());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_endtxnonpartition()->::pulsar::proto::CommandEndTxnOnPartition::MergeFrom(
          from._internal_endtxnonpartition());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_internal_mutable_endtxnonpartitionresponse()->::pulsar::proto::CommandEndTxnOnPartitionResponse::MergeFrom(
          from._internal_endtxnonpartitionresponse());
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_internal_mutable_endtxnonsubscription()->::pulsar::proto::CommandEndTxnOnSubscription::MergeFrom(
          from._internal_endtxnonsubscription());
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_internal_mutable_endtxnonsubscriptionresponse()->::pulsar::proto::CommandEndTxnOnSubscriptionResponse::MergeFrom(
          from._internal_endtxnonsubscriptionresponse());
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_internal_mutable_tcclientconnectrequest()->::pulsar::proto::CommandTcClientConnectRequest::MergeFrom(
          from._internal_tcclientconnectrequest());
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_internal_mutable_tcclientconnectresponse()->::pulsar::proto::CommandTcClientConnectResponse::MergeFrom(
          from._internal_tcclientconnectresponse());
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_internal_mutable_watchtopiclist()->::pulsar::proto::CommandWatchTopicList::MergeFrom(
          from._internal_watchtopiclist());
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_internal_mutable_watchtopiclistsuccess()->::pulsar::proto::CommandWatchTopicListSuccess::MergeFrom(
          from._internal_watchtopiclistsuccess());
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_internal_mutable_watchtopicupdate()->::pulsar::proto::CommandWatchTopicUpdate::MergeFrom(
          from._internal_watchtopicupdate());
    }
  }
  if (cached_has_bits & 0x07000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_internal_mutable_watchtopiclistclose()->::pulsar::proto::CommandWatchTopicListClose::MergeFrom(
          from._internal_watchtopiclistclose());
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_internal_mutable_topicmigrated()->::pulsar::proto::CommandTopicMigrated::MergeFrom(
          from._internal_topicmigrated());
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BaseCommand::CopyFrom(const BaseCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulsar.proto.BaseCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool BaseCommand::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) {
    return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.connect_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!_impl_.connected_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (!_impl_.subscribe_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (!_impl_.producer_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000010u) != 0) {
    if (!_impl_.send_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000020u) != 0) {
    if (!_impl_.send_receipt_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000040u) != 0) {
    if (!_impl_.send_error_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000080u) != 0) {
    if (!_impl_.message_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000100u) != 0) {
    if (!_impl_.ack_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000200u) != 0) {
    if (!_impl_.flow_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000400u) != 0) {
    if (!_impl_.unsubscribe_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000800u) != 0) {
    if (!_impl_.success_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00001000u) != 0) {
    if (!_impl_.error_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00002000u) != 0) {
    if (!_impl_.close_producer_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00004000u) != 0) {
    if (!_impl_.close_consumer_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00008000u) != 0) {
    if (!_impl_.producer_success_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00040000u) != 0) {
    if (!_impl_.redeliverunacknowledgedmessages_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00080000u) != 0) {
    if (!_impl_.partitionmetadata_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00100000u) != 0) {
    if (!_impl_.partitionmetadataresponse_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00200000u) != 0) {
    if (!_impl_.lookuptopic_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00400000u) != 0) {
    if (!_impl_.lookuptopicresponse_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00800000u) != 0) {
    if (!_impl_.consumerstats_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x01000000u) != 0) {
    if (!_impl_.consumerstatsresponse_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x02000000u) != 0) {
    if (!_impl_.reachedendoftopic_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x04000000u) != 0) {
    if (!_impl_.seek_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x08000000u) != 0) {
    if (!_impl_.getlastmessageid_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x10000000u) != 0) {
    if (!_impl_.getlastmessageidresponse_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x20000000u) != 0) {
    if (!_impl_.active_consumer_change_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x40000000u) != 0) {
    if (!_impl_.gettopicsofnamespace_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x80000000u) != 0) {
    if (!_impl_.gettopicsofnamespaceresponse_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00000001u) != 0) {
    if (!_impl_.getschema_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00000002u) != 0) {
    if (!_impl_.getschemaresponse_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00000010u) != 0) {
    if (!_impl_.ackresponse_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00000020u) != 0) {
    if (!_impl_.getorcreateschema_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00000040u) != 0) {
    if (!_impl_.getorcreateschemaresponse_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00000080u) != 0) {
    if (!_impl_.newtxn_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00000100u) != 0) {
    if (!_impl_.newtxnresponse_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00000200u) != 0) {
    if (!_impl_.addpartitiontotxn_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00000400u) != 0) {
    if (!_impl_.addpartitiontotxnresponse_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00000800u) != 0) {
    if (!_impl_.addsubscriptiontotxn_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00001000u) != 0) {
    if (!_impl_.addsubscriptiontotxnresponse_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00002000u) != 0) {
    if (!_impl_.endtxn_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00004000u) != 0) {
    if (!_impl_.endtxnresponse_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00008000u) != 0) {
    if (!_impl_.endtxnonpartition_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00010000u) != 0) {
    if (!_impl_.endtxnonpartitionresponse_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00020000u) != 0) {
    if (!_impl_.endtxnonsubscription_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00040000u) != 0) {
    if (!_impl_.endtxnonsubscriptionresponse_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00080000u) != 0) {
    if (!_impl_.tcclientconnectrequest_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00100000u) != 0) {
    if (!_impl_.tcclientconnectresponse_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00200000u) != 0) {
    if (!_impl_.watchtopiclist_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00400000u) != 0) {
    if (!_impl_.watchtopiclistsuccess_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x00800000u) != 0) {
    if (!_impl_.watchtopicupdate_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x01000000u) != 0) {
    if (!_impl_.watchtopiclistclose_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[1] & 0x02000000u) != 0) {
    if (!_impl_.topicmigrated_->IsInitialized()) return false;
  }
  return true;
}

::_pbi::CachedSize* BaseCommand::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void BaseCommand::InternalSwap(BaseCommand* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.type_)
      + sizeof(BaseCommand::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(BaseCommand, _impl_.connect_)>(
          reinterpret_cast<char*>(&_impl_.connect_),
          reinterpret_cast<char*>(&other->_impl_.connect_));
}

std::string BaseCommand::GetTypeName() const {
  return "pulsar.proto.BaseCommand";
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace pulsar
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
